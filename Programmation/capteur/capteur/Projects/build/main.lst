ARM GAS  /tmp/cceAljft.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"main.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.text.MX_GPIO_Init,"ax",%progbits
  21              		.align	2
  22              		.thumb
  23              		.thumb_func
  25              	MX_GPIO_Init:
  26              	.LFB130:
  27              		.file 1 "../Src/main.c"
   1:../Src/main.c **** /**
   2:../Src/main.c ****   ******************************************************************************
   3:../Src/main.c ****   * File Name          : main.c
   4:../Src/main.c ****   * Date               : 09/02/2018 09:50:48
   5:../Src/main.c ****   * Description        : Main program body
   6:../Src/main.c ****   ******************************************************************************
   7:../Src/main.c ****   *
   8:../Src/main.c ****   * COPYRIGHT(c) 2018 STMicroelectronics
   9:../Src/main.c ****   *
  10:../Src/main.c ****   * Redistribution and use in source and binary forms, with or without modification,
  11:../Src/main.c ****   * are permitted provided that the following conditions are met:
  12:../Src/main.c ****   *   1. Redistributions of source code must retain the above copyright notice,
  13:../Src/main.c ****   *      this list of conditions and the following disclaimer.
  14:../Src/main.c ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
  15:../Src/main.c ****   *      this list of conditions and the following disclaimer in the documentation
  16:../Src/main.c ****   *      and/or other materials provided with the distribution.
  17:../Src/main.c ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
  18:../Src/main.c ****   *      may be used to endorse or promote products derived from this software
  19:../Src/main.c ****   *      without specific prior written permission.
  20:../Src/main.c ****   *
  21:../Src/main.c ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:../Src/main.c ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:../Src/main.c ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  24:../Src/main.c ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  25:../Src/main.c ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  26:../Src/main.c ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  27:../Src/main.c ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  28:../Src/main.c ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  29:../Src/main.c ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  30:../Src/main.c ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31:../Src/main.c ****   *
ARM GAS  /tmp/cceAljft.s 			page 2


  32:../Src/main.c ****   ******************************************************************************
  33:../Src/main.c ****   */
  34:../Src/main.c **** 
  35:../Src/main.c **** /* Includes ------------------------------------------------------------------*/
  36:../Src/main.c **** #include "stm32f4xx_hal.h"
  37:../Src/main.c **** 
  38:../Src/main.c **** /* USER CODE BEGIN Includes */
  39:../Src/main.c **** #include <string.h>
  40:../Src/main.c **** #include "X-NUCLEO-53L0A1.h"
  41:../Src/main.c **** #include "vl53l0x_api.h"
  42:../Src/main.c **** #include <limits.h>
  43:../Src/main.c **** 
  44:../Src/main.c **** /**
  45:../Src/main.c ****  * @defgroup Configuration Static configuration
  46:../Src/main.c ****  * @{
  47:../Src/main.c ****  */
  48:../Src/main.c **** #define HAVE_ALARM_DEMO 0
  49:../Src/main.c **** 
  50:../Src/main.c **** /** Time the initial 53L0 message is shown at power up */
  51:../Src/main.c **** #define WelcomeTime 660
  52:../Src/main.c **** 
  53:../Src/main.c **** /** Time the initial 53L0 message is shown at power up */
  54:../Src/main.c **** #define ModeChangeDispTime  500
  55:../Src/main.c **** 
  56:../Src/main.c **** /**
  57:../Src/main.c ****  * Time considered as  a "long push" on push button
  58:../Src/main.c ****  */
  59:../Src/main.c **** #define PressBPSwicthTime   1000
  60:../Src/main.c **** 
  61:../Src/main.c **** /** @}  */ /* config group */
  62:../Src/main.c **** 
  63:../Src/main.c **** #ifndef MIN
  64:../Src/main.c **** #   define MIN(a,b) ((a) < (b) ? (a) : (b))
  65:../Src/main.c **** #endif
  66:../Src/main.c **** 
  67:../Src/main.c **** #define B1_Pin GPIO_PIN_13
  68:../Src/main.c **** #define B1_GPIO_Port GPIOC
  69:../Src/main.c **** #define LD2_Pin GPIO_PIN_5
  70:../Src/main.c **** #define LD2_GPIO_Port GPIOA
  71:../Src/main.c **** 
  72:../Src/main.c **** #ifndef ARRAY_SIZE
  73:../Src/main.c **** #   define ARRAY_SIZE(x) (sizeof((x))/sizeof((x)[0]))
  74:../Src/main.c **** #endif
  75:../Src/main.c **** 
  76:../Src/main.c **** /**
  77:../Src/main.c ****  * @defgroup ErrCode Errors code shown on display
  78:../Src/main.c ****  * @{
  79:../Src/main.c ****  */
  80:../Src/main.c **** #define ERR_DETECT             -1
  81:../Src/main.c **** #define ERR_DEMO_RANGE_ONE     1
  82:../Src/main.c **** #define ERR_DEMO_RANGE_MULTI   2
  83:../Src/main.c **** 
  84:../Src/main.c **** 
  85:../Src/main.c **** /** }@} */ /* defgroup ErrCode */
  86:../Src/main.c **** 
  87:../Src/main.c **** 
  88:../Src/main.c **** /* USER CODE END Includes */
ARM GAS  /tmp/cceAljft.s 			page 3


  89:../Src/main.c **** 
  90:../Src/main.c **** /* Private variables ---------------------------------------------------------*/
  91:../Src/main.c **** I2C_HandleTypeDef hi2c1;
  92:../Src/main.c **** 
  93:../Src/main.c **** TIM_HandleTypeDef htim3;
  94:../Src/main.c **** 
  95:../Src/main.c **** /* USER CODE BEGIN PV */
  96:../Src/main.c **** /* Private variables ---------------------------------------------------------*/
  97:../Src/main.c **** 
  98:../Src/main.c **** const char TxtRangeValue[]  = "rng";
  99:../Src/main.c **** const char TxtBarGraph[]    = "bar";
 100:../Src/main.c **** #if HAVE_ALARM_DEMO
 101:../Src/main.c **** const char TxtAlarm[]       = "Alr";
 102:../Src/main.c **** #endif
 103:../Src/main.c **** 
 104:../Src/main.c **** 
 105:../Src/main.c **** typedef enum {
 106:../Src/main.c **** 	LONG_RANGE 		= 0, /*!< Long range mode */
 107:../Src/main.c **** 	HIGH_SPEED 		= 1, /*!< High speed mode */
 108:../Src/main.c **** 	HIGH_ACCURACY	= 2, /*!< High accuracy mode */
 109:../Src/main.c **** } RangingConfig_e;
 110:../Src/main.c **** char *RangingConfigTxt[3] = {"LR", "HS", "HA"};
 111:../Src/main.c **** 
 112:../Src/main.c **** typedef enum {
 113:../Src/main.c **** 	RANGE_VALUE 	= 0, /*!< Range displayed in cm */
 114:../Src/main.c **** 	BAR_GRAPH 		= 1, /*!< Range displayed as a bar graph : one bar per sensor */
 115:../Src/main.c **** } DemoMode_e;
 116:../Src/main.c **** char *DemoModeTxt[2] = {"rng", "bar"};
 117:../Src/main.c **** 
 118:../Src/main.c **** /**
 119:../Src/main.c ****  * Global ranging struct
 120:../Src/main.c ****  */
 121:../Src/main.c **** VL53L0X_RangingMeasurementData_t RangingMeasurementData;
 122:../Src/main.c **** 
 123:../Src/main.c **** 
 124:../Src/main.c **** /** leaky factor for filtered range
 125:../Src/main.c ****  *
 126:../Src/main.c ****  * r(n) = averaged_r(n-1)*leaky +r(n)(1-leaky)
 127:../Src/main.c ****  *
 128:../Src/main.c ****  * */
 129:../Src/main.c **** int LeakyFactorFix8 = (int)( 0.6 *256);
 130:../Src/main.c **** /** How many device detect set by @a DetectSensors()*/
 131:../Src/main.c **** int nDevPresent=0;
 132:../Src/main.c **** /** bit is index in VL53L0XDevs that is not necessary the dev id of the BSP */
 133:../Src/main.c **** int nDevMask;
 134:../Src/main.c **** 
 135:../Src/main.c **** 
 136:../Src/main.c **** VL53L0X_Dev_t VL53L0XDevs[]={
 137:../Src/main.c ****         {.Id=XNUCLEO53L0A1_DEV_LEFT, .DevLetter='l', .I2cHandle=&XNUCLEO53L0A1_hi2c, .I2cDevAddr=0x
 138:../Src/main.c ****         {.Id=XNUCLEO53L0A1_DEV_CENTER, .DevLetter='c', .I2cHandle=&XNUCLEO53L0A1_hi2c, .I2cDevAddr=
 139:../Src/main.c ****         {.Id=XNUCLEO53L0A1_DEV_RIGHT, .DevLetter='r', .I2cHandle=&XNUCLEO53L0A1_hi2c, .I2cDevAddr=0
 140:../Src/main.c **** };
 141:../Src/main.c **** 
 142:../Src/main.c **** /** range low (and high) in @a RangeToLetter()
 143:../Src/main.c ****  *
 144:../Src/main.c ****  * used for displaying  multiple sensor as bar graph
 145:../Src/main.c ****  */
ARM GAS  /tmp/cceAljft.s 			page 4


 146:../Src/main.c **** int RangeLow=100;
 147:../Src/main.c **** 
 148:../Src/main.c **** /** range medium in @a RangeToLetter()
 149:../Src/main.c ****  *
 150:../Src/main.c ****  * used for displaying  multiple sensor as bar graph
 151:../Src/main.c ****  */
 152:../Src/main.c **** int RangeMedium=300;
 153:../Src/main.c **** 
 154:../Src/main.c **** /** Timer
 155:../Src/main.c ****  *
 156:../Src/main.c ****  * Used to get time stamp for UART logging
 157:../Src/main.c ****  */
 158:../Src/main.c **** TIM_HandleTypeDef htim5;
 159:../Src/main.c **** 
 160:../Src/main.c **** /* TIM5 init function */
 161:../Src/main.c **** void MX_TIM5_Init(void)
 162:../Src/main.c **** {
 163:../Src/main.c **** 
 164:../Src/main.c ****   TIM_MasterConfigTypeDef sMasterConfig;
 165:../Src/main.c ****   TIM_OC_InitTypeDef sConfigOC;
 166:../Src/main.c **** 
 167:../Src/main.c ****   htim5.Instance = TIM5;
 168:../Src/main.c ****   htim5.Init.Prescaler = 83;
 169:../Src/main.c ****   htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 170:../Src/main.c ****   htim5.Init.Period = 0xFFFFFFFF;
 171:../Src/main.c ****   htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 172:../Src/main.c ****   HAL_TIM_OC_Init(&htim5);
 173:../Src/main.c **** 
 174:../Src/main.c ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 175:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 176:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig);
 177:../Src/main.c **** 
 178:../Src/main.c ****   sConfigOC.OCMode = TIM_OCMODE_TIMING;
 179:../Src/main.c ****   sConfigOC.Pulse = 0;
 180:../Src/main.c ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 181:../Src/main.c ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 182:../Src/main.c ****   HAL_TIM_OC_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1);
 183:../Src/main.c **** 
 184:../Src/main.c **** }
 185:../Src/main.c **** 
 186:../Src/main.c **** void TimeStamp_Init(){
 187:../Src/main.c ****     MX_TIM5_Init();
 188:../Src/main.c **** }
 189:../Src/main.c **** 
 190:../Src/main.c **** void TimeStamp_Reset(){
 191:../Src/main.c ****     HAL_TIM_Base_Start(&htim5);
 192:../Src/main.c ****     htim5.Instance->CNT=0;
 193:../Src/main.c **** }
 194:../Src/main.c **** 
 195:../Src/main.c **** uint32_t TimeStamp_Get(){
 196:../Src/main.c ****     return htim5.Instance->CNT;
 197:../Src/main.c **** }
 198:../Src/main.c **** 
 199:../Src/main.c **** /* USER CODE END PV */
 200:../Src/main.c **** 
 201:../Src/main.c **** /* Private function prototypes -----------------------------------------------*/
 202:../Src/main.c **** void SystemClock_Config(void);
ARM GAS  /tmp/cceAljft.s 			page 5


 203:../Src/main.c **** static void MX_GPIO_Init(void);
 204:../Src/main.c **** static void MX_I2C1_Init(void);
 205:../Src/main.c **** static void MX_TIM3_Init(void);
 206:../Src/main.c **** 
 207:../Src/main.c **** /* USER CODE BEGIN PFP */
 208:../Src/main.c **** /* Private function prototypes -----------------------------------------------*/
 209:../Src/main.c **** void ResetAndDetectSensor(int SetDisplay);
 210:../Src/main.c **** 
 211:../Src/main.c **** /* USER CODE END PFP */
 212:../Src/main.c **** 
 213:../Src/main.c **** /* USER CODE BEGIN 0 */
 214:../Src/main.c **** 
 215:../Src/main.c **** #define debug_printf    trace_printf
 216:../Src/main.c **** char WelcomeMsg[]="Hi I am Ranging VL53L0X mcu " MCU_NAME "\n";
 217:../Src/main.c **** 
 218:../Src/main.c **** #if HAVE_ALARM_DEMO
 219:../Src/main.c **** volatile int IntrCount;
 220:../Src/main.c **** volatile int LastIntrPin;
 221:../Src/main.c **** volatile int LastIntrId;
 222:../Src/main.c **** volatile int IntrCounts[3];
 223:../Src/main.c **** #endif
 224:../Src/main.c **** 
 225:../Src/main.c **** #define BSP_BP_PORT GPIOC
 226:../Src/main.c **** #define BSP_BP_PIN  GPIO_PIN_13
 227:../Src/main.c **** 
 228:../Src/main.c **** int BSP_GetPushButton(void){
 229:../Src/main.c ****     GPIO_PinState state ;
 230:../Src/main.c ****     state = HAL_GPIO_ReadPin(BSP_BP_PORT, BSP_BP_PIN);
 231:../Src/main.c ****     return state;
 232:../Src/main.c **** }
 233:../Src/main.c **** 
 234:../Src/main.c **** /**
 235:../Src/main.c ****  * When button is already pressed it waits for user to release it.
 236:../Src/main.c ****  * if button remains pressed for a given time it returns true.
 237:../Src/main.c ****  * This is used to detect mode switch by long press on blue Push Button
 238:../Src/main.c ****  *
 239:../Src/main.c ****  * As soon as time is elapsed -rb- is displayed to let user know the mode
 240:../Src/main.c ****  * switch is taken into account
 241:../Src/main.c ****  *
 242:../Src/main.c ****  * @return True if button remains pressed more than specified time
 243:../Src/main.c ****  */
 244:../Src/main.c **** int PusbButton_WaitUnPress(void){
 245:../Src/main.c ****     uint32_t TimeStarted;
 246:../Src/main.c ****     TimeStarted = HAL_GetTick();
 247:../Src/main.c ****     while( !BSP_GetPushButton() ){ ; /* debounce */
 248:../Src/main.c ****         if(HAL_GetTick()- TimeStarted> PressBPSwicthTime){
 249:../Src/main.c ****             XNUCLEO53L0A1_SetDisplayString (" rb ");
 250:../Src/main.c ****         }
 251:../Src/main.c ****     }
 252:../Src/main.c ****     return  HAL_GetTick() - TimeStarted>PressBPSwicthTime;
 253:../Src/main.c **** 
 254:../Src/main.c **** }
 255:../Src/main.c **** 
 256:../Src/main.c **** #if HAVE_ALARM_DEMO
 257:../Src/main.c **** /**
 258:../Src/main.c ****  * Interrupt handler called each time an interrupt is produced by the ranging sensor (in ALARM mode
 259:../Src/main.c ****  * @param err
ARM GAS  /tmp/cceAljft.s 			page 6


 260:../Src/main.c ****  */
 261:../Src/main.c **** void VL53L0A1_EXTI_Callback(int DevNo, int GPIO_Pin){
 262:../Src/main.c ****     IntrCount++;
 263:../Src/main.c ****     LastIntrPin=GPIO_Pin;
 264:../Src/main.c ****     LastIntrId=DevNo;
 265:../Src/main.c **** 
 266:../Src/main.c ****     if( DevNo< ARRAY_SIZE(IntrCounts)  ){
 267:../Src/main.c ****         IntrCounts[DevNo]++;
 268:../Src/main.c ****     }
 269:../Src/main.c **** }
 270:../Src/main.c **** #endif
 271:../Src/main.c **** 
 272:../Src/main.c **** 
 273:../Src/main.c **** /**
 274:../Src/main.c ****  * Handle Error
 275:../Src/main.c ****  *
 276:../Src/main.c ****  * Set err on display and loop forever
 277:../Src/main.c ****  * @param err Error case code
 278:../Src/main.c ****  */
 279:../Src/main.c **** void HandleError(int err){
 280:../Src/main.c ****     char msg[16];
 281:../Src/main.c ****     sprintf(msg,"Er%d", err);
 282:../Src/main.c ****     XNUCLEO53L0A1_SetDisplayString(msg);
 283:../Src/main.c ****     while(1){};
 284:../Src/main.c **** }
 285:../Src/main.c **** 
 286:../Src/main.c **** /**
 287:../Src/main.c ****  * Reset all sensor then do presence detection
 288:../Src/main.c ****  *
 289:../Src/main.c ****  * All present devices are data initiated and assigned to their final I2C address
 290:../Src/main.c ****  * @return
 291:../Src/main.c ****  */
 292:../Src/main.c **** int DetectSensors(int SetDisplay) {
 293:../Src/main.c ****     int i;
 294:../Src/main.c ****     uint16_t Id;
 295:../Src/main.c ****     int status;
 296:../Src/main.c ****     int FinalAddress;
 297:../Src/main.c **** 
 298:../Src/main.c ****     char PresentMsg[5]="    ";
 299:../Src/main.c ****     /* Reset all */
 300:../Src/main.c ****     nDevPresent = 0;
 301:../Src/main.c ****     for (i = 0; i < 3; i++)
 302:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 303:../Src/main.c **** 
 304:../Src/main.c ****     /* detect all sensors (even on-board)*/
 305:../Src/main.c ****     for (i = 0; i < 3; i++) {
 306:../Src/main.c ****         VL53L0X_Dev_t *pDev;
 307:../Src/main.c ****         pDev = &VL53L0XDevs[i];
 308:../Src/main.c ****         pDev->I2cDevAddr = 0x52;
 309:../Src/main.c ****         pDev->Present = 0;
 310:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId( pDev->Id, 1);
 311:../Src/main.c ****         HAL_Delay(2);
 312:../Src/main.c ****         FinalAddress=0x52+(i+1)*2;
 313:../Src/main.c **** 
 314:../Src/main.c ****         do {
 315:../Src/main.c ****         	/* Set I2C standard mode (400 KHz) before doing the first register access */
 316:../Src/main.c ****         	if (status == VL53L0X_ERROR_NONE)
ARM GAS  /tmp/cceAljft.s 			page 7


 317:../Src/main.c ****         		status = VL53L0X_WrByte(pDev, 0x88, 0x00);
 318:../Src/main.c **** 
 319:../Src/main.c ****         	/* Try to read one register using default 0x52 address */
 320:../Src/main.c ****             status = VL53L0X_RdWord(pDev, VL53L0X_REG_IDENTIFICATION_MODEL_ID, &Id);
 321:../Src/main.c ****             if (status) {
 322:../Src/main.c ****                 debug_printf("#%d Read id fail\n", i);
 323:../Src/main.c ****                 break;
 324:../Src/main.c ****             }
 325:../Src/main.c ****             if (Id == 0xEEAA) {
 326:../Src/main.c **** 				/* Sensor is found => Change its I2C address to final one */
 327:../Src/main.c ****                 status = VL53L0X_SetDeviceAddress(pDev,FinalAddress);
 328:../Src/main.c ****                 if (status != 0) {
 329:../Src/main.c ****                     debug_printf("#i VL53L0X_SetDeviceAddress fail\n", i);
 330:../Src/main.c ****                     break;
 331:../Src/main.c ****                 }
 332:../Src/main.c ****                 pDev->I2cDevAddr = FinalAddress;
 333:../Src/main.c ****                 /* Check all is OK with the new I2C address and initialize the sensor */
 334:../Src/main.c ****                 status = VL53L0X_RdWord(pDev, VL53L0X_REG_IDENTIFICATION_MODEL_ID, &Id);
 335:../Src/main.c ****                 if (status != 0) {
 336:../Src/main.c **** 					debug_printf("#i VL53L0X_RdWord fail\n", i);
 337:../Src/main.c **** 					break;
 338:../Src/main.c **** 				}
 339:../Src/main.c **** 
 340:../Src/main.c ****                 status = VL53L0X_DataInit(pDev);
 341:../Src/main.c ****                 if( status == 0 ){
 342:../Src/main.c ****                     pDev->Present = 1;
 343:../Src/main.c ****                 }
 344:../Src/main.c ****                 else{
 345:../Src/main.c ****                     debug_printf("VL53L0X_DataInit %d fail\n", i);
 346:../Src/main.c ****                     break;
 347:../Src/main.c ****                 }
 348:../Src/main.c ****                 trace_printf("VL53L0X %d Present and initiated to final 0x%x\n", pDev->Id, pDev->I2
 349:../Src/main.c ****                 nDevPresent++;
 350:../Src/main.c ****                 nDevMask |= 1 << i;
 351:../Src/main.c ****                 pDev->Present = 1;
 352:../Src/main.c ****             }
 353:../Src/main.c ****             else {
 354:../Src/main.c ****                 debug_printf("#%d unknown ID %x\n", i, Id);
 355:../Src/main.c ****                 status = 1;
 356:../Src/main.c ****             }
 357:../Src/main.c ****         } while (0);
 358:../Src/main.c ****         /* if fail r can't use for any reason then put the  device back to reset */
 359:../Src/main.c ****         if (status) {
 360:../Src/main.c ****             XNUCLEO53L0A1_ResetId(i, 0);
 361:../Src/main.c ****         }
 362:../Src/main.c ****     }
 363:../Src/main.c ****     /* Display detected sensor(s) */
 364:../Src/main.c ****     if( SetDisplay ){
 365:../Src/main.c ****         for(i=0; i<3; i++){
 366:../Src/main.c ****             if( VL53L0XDevs[i].Present ){
 367:../Src/main.c ****                 PresentMsg[i+1]=VL53L0XDevs[i].DevLetter;
 368:../Src/main.c ****             }
 369:../Src/main.c ****         }
 370:../Src/main.c ****         PresentMsg[0]=' ';
 371:../Src/main.c ****         XNUCLEO53L0A1_SetDisplayString(PresentMsg);
 372:../Src/main.c ****         HAL_Delay(1000);
 373:../Src/main.c ****     }
ARM GAS  /tmp/cceAljft.s 			page 8


 374:../Src/main.c **** 
 375:../Src/main.c ****     return nDevPresent;
 376:../Src/main.c **** }
 377:../Src/main.c **** 
 378:../Src/main.c **** /**
 379:../Src/main.c ****  *  Setup all detected sensors for single shot mode and setup ranging configuration
 380:../Src/main.c ****  */
 381:../Src/main.c **** void SetupSingleShot(RangingConfig_e rangingConfig){
 382:../Src/main.c ****     int i;
 383:../Src/main.c ****     int status;
 384:../Src/main.c ****     uint8_t VhvSettings;
 385:../Src/main.c ****     uint8_t PhaseCal;
 386:../Src/main.c ****     uint32_t refSpadCount;
 387:../Src/main.c **** 	uint8_t isApertureSpads;
 388:../Src/main.c **** 	FixPoint1616_t signalLimit = (FixPoint1616_t)(0.25*65536);
 389:../Src/main.c **** 	FixPoint1616_t sigmaLimit = (FixPoint1616_t)(18*65536);
 390:../Src/main.c **** 	uint32_t timingBudget = 33000;
 391:../Src/main.c **** 	uint8_t preRangeVcselPeriod = 14;
 392:../Src/main.c **** 	uint8_t finalRangeVcselPeriod = 10;
 393:../Src/main.c **** 
 394:../Src/main.c ****     for( i=0; i<3; i++){
 395:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 396:../Src/main.c ****             status=VL53L0X_StaticInit(&VL53L0XDevs[i]);
 397:../Src/main.c ****             if( status ){
 398:../Src/main.c ****                 debug_printf("VL53L0X_StaticInit %d failed\n",i);
 399:../Src/main.c ****             }
 400:../Src/main.c **** 
 401:../Src/main.c ****             status = VL53L0X_PerformRefCalibration(&VL53L0XDevs[i], &VhvSettings, &PhaseCal);
 402:../Src/main.c **** 			if( status ){
 403:../Src/main.c **** 			   debug_printf("VL53L0X_PerformRefCalibration failed\n");
 404:../Src/main.c **** 			}
 405:../Src/main.c **** 
 406:../Src/main.c **** 			status = VL53L0X_PerformRefSpadManagement(&VL53L0XDevs[i], &refSpadCount, &isApertureSpads);
 407:../Src/main.c **** 			if( status ){
 408:../Src/main.c **** 			   debug_printf("VL53L0X_PerformRefSpadManagement failed\n");
 409:../Src/main.c **** 			}
 410:../Src/main.c **** 
 411:../Src/main.c ****             status = VL53L0X_SetDeviceMode(&VL53L0XDevs[i], VL53L0X_DEVICEMODE_SINGLE_RANGING); // 
 412:../Src/main.c ****             if( status ){
 413:../Src/main.c ****                debug_printf("VL53L0X_SetDeviceMode failed\n");
 414:../Src/main.c ****             }
 415:../Src/main.c **** 
 416:../Src/main.c ****             status = VL53L0X_SetLimitCheckEnable(&VL53L0XDevs[i], VL53L0X_CHECKENABLE_SIGMA_FINAL_R
 417:../Src/main.c **** 			if( status ){
 418:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckEnable failed\n");
 419:../Src/main.c **** 			}
 420:../Src/main.c **** 
 421:../Src/main.c **** 			status = VL53L0X_SetLimitCheckEnable(&VL53L0XDevs[i], VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANG
 422:../Src/main.c **** 			if( status ){
 423:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckEnable failed\n");
 424:../Src/main.c **** 			}
 425:../Src/main.c **** 			/* Ranging configuration */
 426:../Src/main.c ****             switch(rangingConfig) {
 427:../Src/main.c ****             case LONG_RANGE:
 428:../Src/main.c ****             	signalLimit = (FixPoint1616_t)(0.1*65536);
 429:../Src/main.c ****             	sigmaLimit = (FixPoint1616_t)(60*65536);
 430:../Src/main.c ****             	timingBudget = 33000; //33ms
ARM GAS  /tmp/cceAljft.s 			page 9


 431:../Src/main.c ****             	preRangeVcselPeriod = 18;
 432:../Src/main.c ****             	finalRangeVcselPeriod = 14;
 433:../Src/main.c ****             	break;
 434:../Src/main.c ****             case HIGH_ACCURACY:
 435:../Src/main.c **** 				signalLimit = (FixPoint1616_t)(0.25*65536); //the return signal rate limit in MCPS
 436:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(18*65536);
 437:../Src/main.c **** 				timingBudget = 200000; //200ms
 438:../Src/main.c **** 				preRangeVcselPeriod = 14; //laser pulse periods
 439:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 440:../Src/main.c **** 				break;
 441:../Src/main.c ****             case HIGH_SPEED:
 442:../Src/main.c **** 				signalLimit = (FixPoint1616_t)(0.25*65536);
 443:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(32*65536);
 444:../Src/main.c **** 				timingBudget = 20000; //20ms
 445:../Src/main.c **** 				preRangeVcselPeriod = 14;
 446:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 447:../Src/main.c **** 				break;
 448:../Src/main.c ****             default:
 449:../Src/main.c ****             	debug_printf("Not Supported");
 450:../Src/main.c ****             }
 451:../Src/main.c **** 
 452:../Src/main.c ****             status = VL53L0X_SetLimitCheckValue(&VL53L0XDevs[i],  VL53L0X_CHECKENABLE_SIGNAL_RATE_F
 453:../Src/main.c **** 			if( status ){
 454:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckValue failed\n");
 455:../Src/main.c **** 			}
 456:../Src/main.c **** 
 457:../Src/main.c **** 			status = VL53L0X_SetLimitCheckValue(&VL53L0XDevs[i],  VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE, sig
 458:../Src/main.c **** 			if( status ){
 459:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckValue failed\n");
 460:../Src/main.c **** 			}
 461:../Src/main.c **** 
 462:../Src/main.c ****             status = VL53L0X_SetMeasurementTimingBudgetMicroSeconds(&VL53L0XDevs[i],  timingBudget)
 463:../Src/main.c ****             if( status ){
 464:../Src/main.c ****                debug_printf("VL53L0X_SetMeasurementTimingBudgetMicroSeconds failed\n");
 465:../Src/main.c ****             }
 466:../Src/main.c **** 
 467:../Src/main.c ****             status = VL53L0X_SetVcselPulsePeriod(&VL53L0XDevs[i],  VL53L0X_VCSEL_PERIOD_PRE_RANGE, 
 468:../Src/main.c **** 			if( status ){
 469:../Src/main.c **** 			   debug_printf("VL53L0X_SetVcselPulsePeriod failed\n");
 470:../Src/main.c **** 			}
 471:../Src/main.c **** 
 472:../Src/main.c ****             status = VL53L0X_SetVcselPulsePeriod(&VL53L0XDevs[i],  VL53L0X_VCSEL_PERIOD_FINAL_RANGE
 473:../Src/main.c **** 			if( status ){
 474:../Src/main.c **** 			   debug_printf("VL53L0X_SetVcselPulsePeriod failed\n");
 475:../Src/main.c **** 			}
 476:../Src/main.c **** 
 477:../Src/main.c **** 			status = VL53L0X_PerformRefCalibration(&VL53L0XDevs[i], &VhvSettings, &PhaseCal);
 478:../Src/main.c **** 			if( status ){
 479:../Src/main.c **** 			   debug_printf("VL53L0X_PerformRefCalibration failed\n");
 480:../Src/main.c **** 			}
 481:../Src/main.c **** 
 482:../Src/main.c ****             VL53L0XDevs[i].LeakyFirst=1;
 483:../Src/main.c ****         }
 484:../Src/main.c ****     }
 485:../Src/main.c **** }
 486:../Src/main.c **** 
 487:../Src/main.c **** char RangeToLetter(VL53L0X_Dev_t *pDev, VL53L0X_RangingMeasurementData_t *pRange){
ARM GAS  /tmp/cceAljft.s 			page 10


 488:../Src/main.c ****     char c;
 489:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 490:../Src/main.c ****         if( pDev->LeakyRange < RangeLow ){
 491:../Src/main.c ****             c='_';
 492:../Src/main.c ****         }
 493:../Src/main.c ****         else if( pDev->LeakyRange < RangeMedium ){
 494:../Src/main.c ****                 c='=';
 495:../Src/main.c ****         }
 496:../Src/main.c ****         else {
 497:../Src/main.c ****             c = '~';
 498:../Src/main.c ****         }
 499:../Src/main.c **** 
 500:../Src/main.c ****     }
 501:../Src/main.c ****     else{
 502:../Src/main.c ****         c='-';
 503:../Src/main.c ****     }
 504:../Src/main.c ****     return c;
 505:../Src/main.c **** }
 506:../Src/main.c **** 
 507:../Src/main.c **** /* Store new ranging data into the device structure, apply leaky integrator if needed */
 508:../Src/main.c **** void Sensor_SetNewRange(VL53L0X_Dev_t *pDev, VL53L0X_RangingMeasurementData_t *pRange){
 509:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 510:../Src/main.c ****         if( pDev->LeakyFirst ){
 511:../Src/main.c ****             pDev->LeakyFirst = 0;
 512:../Src/main.c ****             pDev->LeakyRange = pRange->RangeMilliMeter;
 513:../Src/main.c ****         }
 514:../Src/main.c ****         else{
 515:../Src/main.c ****             pDev->LeakyRange = (pDev->LeakyRange*LeakyFactorFix8 + (256-LeakyFactorFix8)*pRange->Ra
 516:../Src/main.c ****         }
 517:../Src/main.c ****     }
 518:../Src/main.c ****     else{
 519:../Src/main.c ****         pDev->LeakyFirst = 1;
 520:../Src/main.c ****     }
 521:../Src/main.c **** }
 522:../Src/main.c **** 
 523:../Src/main.c **** void blink_led(int valeur, int* compteur){     /////modification de la led
 524:../Src/main.c ****     if (*compteur == 6){                       /////modification toutes les 6 mesures correctes du 
 525:../Src/main.c ****         HAL_TIM_Base_Stop_IT(&htim3);
 526:../Src/main.c ****         htim3.Instance->ARR = 2*valeur-1+20;   /////modification de la période du capteur (voir wi
 527:../Src/main.c ****         HAL_TIM_Base_Start_IT(&htim3);  
 528:../Src/main.c ****         htim3.Instance->CNT = 0;               /////remise a zero du timer de la led
 529:../Src/main.c ****         *compteur = 0;                         /////remise a zero du compteur
 530:../Src/main.c ****     }
 531:../Src/main.c **** }
 532:../Src/main.c **** 
 533:../Src/main.c **** 
 534:../Src/main.c **** /**
 535:../Src/main.c ****  * Implement the ranging demo with all modes managed through the blue button (short and long press)
 536:../Src/main.c ****  * This function implements a while loop until the blue button is pressed
 537:../Src/main.c ****  * @param UseSensorsMask Mask of any sensors to use if not only one present
 538:../Src/main.c ****  * @param rangingConfig Ranging configuration to be used (same for all sensors)
 539:../Src/main.c ****  */
 540:../Src/main.c **** int RangeDemo(int UseSensorsMask, RangingConfig_e rangingConfig){
 541:../Src/main.c ****     int over=0;
 542:../Src/main.c ****     int status;
 543:../Src/main.c ****     char StrDisplay[5];
 544:../Src/main.c ****     char c;
ARM GAS  /tmp/cceAljft.s 			page 11


 545:../Src/main.c ****     int i;
 546:../Src/main.c ****     int nSensorToUse;
 547:../Src/main.c ****     int SingleSensorNo=0;
 548:../Src/main.c ****     int valeur;
 549:../Src/main.c ****     int s=0;                ///creation compteur
 550:../Src/main.c ****     int* compteur = NULL;   ///creation pointeur sur compteur
 551:../Src/main.c ****     compteur=&s;
 552:../Src/main.c **** 
 553:../Src/main.c ****     /* Setup all sensors in Single Shot mode */
 554:../Src/main.c ****     SetupSingleShot(rangingConfig);
 555:../Src/main.c **** 
 556:../Src/main.c ****     /* Which sensor to use ? */
 557:../Src/main.c ****     for(i=0, nSensorToUse=0; i<3; i++){
 558:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 559:../Src/main.c ****             nSensorToUse++;
 560:../Src/main.c ****             if( nSensorToUse==1 )
 561:../Src/main.c ****                 SingleSensorNo=i;
 562:../Src/main.c ****         }
 563:../Src/main.c ****     }
 564:../Src/main.c ****     if( nSensorToUse == 0 ){
 565:../Src/main.c ****         return -1;
 566:../Src/main.c ****     }
 567:../Src/main.c **** 
 568:../Src/main.c ****     /* Start ranging until blue button is pressed */
 569:../Src/main.c ****     do{    
 570:../Src/main.c ****         if( nSensorToUse >1 ){
 571:../Src/main.c ****         	/* Multiple devices */
 572:../Src/main.c ****             strcpy(StrDisplay, "    ");
 573:../Src/main.c ****             for( i=0; i<3; i++){
 574:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 575:../Src/main.c ****                     continue;
 576:../Src/main.c ****                 /* Call All-In-One blocking API function */
 577:../Src/main.c ****                 status = VL53L0X_PerformSingleRangingMeasurement(&VL53L0XDevs[i],&RangingMeasuremen
 578:../Src/main.c ****                 if( status ){
 579:../Src/main.c ****                     HandleError(ERR_DEMO_RANGE_MULTI);
 580:../Src/main.c ****                 }
 581:../Src/main.c ****                 /* Push data logging to UART */
 582:../Src/main.c ****                 trace_printf("%d,%u,%d,%d,%d\n", VL53L0XDevs[i].Id, TimeStamp_Get(), RangingMeasure
 583:../Src/main.c ****                 /* Store new ranging distance */
 584:../Src/main.c ****                 Sensor_SetNewRange(&VL53L0XDevs[i],&RangingMeasurementData);
 585:../Src/main.c ****                 /* Translate distance in bar graph (multiple device) */
 586:../Src/main.c ****                 c = RangeToLetter(&VL53L0XDevs[i],&RangingMeasurementData);
 587:../Src/main.c ****                 StrDisplay[i+1]=c;
 588:../Src/main.c ****             }
 589:../Src/main.c ****         }
 590:../Src/main.c ****         else{
 591:../Src/main.c ****             /* only one sensor */
 592:../Src/main.c ****         	/* Call All-In-One blocking API function */
 593:../Src/main.c ****             status = VL53L0X_PerformSingleRangingMeasurement(&VL53L0XDevs[SingleSensorNo],&RangingM
 594:../Src/main.c ****             if( status ==0 ){
 595:../Src/main.c ****             	/* Push data logging to UART */
 596:../Src/main.c ****             	trace_printf("%d,%u,%d,%d,%d\n", VL53L0XDevs[SingleSensorNo].Id, TimeStamp_Get(), Rang
 597:../Src/main.c ****             	Sensor_SetNewRange(&VL53L0XDevs[SingleSensorNo],&RangingMeasurementData);
 598:../Src/main.c ****                 /* Display distance in cm */
 599:../Src/main.c ****             	if( RangingMeasurementData.RangeStatus == 0 ){  /////boucle de mesures correctes
 600:../Src/main.c ****                     *compteur+=1;                               /////incrementation du compteur
 601:../Src/main.c ****                     sprintf(StrDisplay, "%3dc",(int)VL53L0XDevs[SingleSensorNo].LeakyRange/10);  //
ARM GAS  /tmp/cceAljft.s 			page 12


 602:../Src/main.c ****                     valeur=(int)VL53L0XDevs[SingleSensorNo].LeakyRange/10;   /////valeur lue par le
 603:../Src/main.c ****                     blink_led(valeur,compteur);                 /////fonction blink_led
 604:../Src/main.c ****                 }
 605:../Src/main.c ****                 else{                                           /////boucle de mesures incorrectes
 606:../Src/main.c ****                     sprintf(StrDisplay, "----");
 607:../Src/main.c ****                     StrDisplay[0]=VL53L0XDevs[SingleSensorNo].DevLetter;
 608:../Src/main.c ****                     //HAL_TIM_Base_Stop_IT(&htim3);
 609:../Src/main.c ****                     //htim3.Instance->ARR=2000;
 610:../Src/main.c ****                     //HAL_TIM_Base_Start_IT(&htim3);
 611:../Src/main.c ****                 }
 612:../Src/main.c ****             }
 613:../Src/main.c ****             else{
 614:../Src/main.c ****                 HandleError(ERR_DEMO_RANGE_ONE);
 615:../Src/main.c ****             }
 616:../Src/main.c ****         }
 617:../Src/main.c ****         XNUCLEO53L0A1_SetDisplayString(StrDisplay);
 618:../Src/main.c ****         /* Check blue button */
 619:../Src/main.c ****         if( !BSP_GetPushButton() ){
 620:../Src/main.c ****             over=1;
 621:../Src/main.c ****             break;
 622:../Src/main.c ****         }
 623:../Src/main.c ****     }while( !over);
 624:../Src/main.c ****     /* Wait button to be un-pressed to decide if it is a short or long press */
 625:../Src/main.c ****     status=PusbButton_WaitUnPress();
 626:../Src/main.c ****     htim3.Instance->CNT=0;       /////remise a zero du timer de la led
 627:../Src/main.c ****     return status;
 628:../Src/main.c **** }
 629:../Src/main.c **** 
 630:../Src/main.c **** #if HAVE_ALARM_DEMO
 631:../Src/main.c **** struct AlrmMode_t {
 632:../Src/main.c ****     const int VL53L0X_Mode;
 633:../Src/main.c ****     const char *Name;
 634:../Src/main.c ****     uint32_t ThreshLow;
 635:../Src/main.c ****     uint32_t ThreshHigh;
 636:../Src/main.c **** };
 637:../Src/main.c **** 
 638:../Src/main.c **** struct AlrmMode_t AlarmModes[]={
 639:../Src/main.c ****         { .VL53L0X_Mode = VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW , .Name="Lo" , .ThreshLow
 640:../Src/main.c ****         { .VL53L0X_Mode = VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH, .Name= "hi", .ThreshLow
 641:../Src/main.c ****         { .VL53L0X_Mode = VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT , .Name="out", .ThreshLow
 642:../Src/main.c **** };
 643:../Src/main.c **** 
 644:../Src/main.c **** VL53L0X_Error WaitStopCompleted(VL53L0X_DEV Dev) {
 645:../Src/main.c ****     VL53L0X_Error Status = VL53L0X_ERROR_NONE;
 646:../Src/main.c ****     uint32_t StopCompleted=0;
 647:../Src/main.c ****     uint32_t LoopNb;
 648:../Src/main.c **** 
 649:../Src/main.c ****     // Wait until it finished
 650:../Src/main.c ****     // use timeout to avoid deadlock
 651:../Src/main.c ****     if (Status == VL53L0X_ERROR_NONE) {
 652:../Src/main.c ****         LoopNb = 0;
 653:../Src/main.c ****         do {
 654:../Src/main.c ****             Status = VL53L0X_GetStopCompletedStatus(Dev, &StopCompleted);
 655:../Src/main.c ****             if ((StopCompleted == 0x00) || Status != VL53L0X_ERROR_NONE) {
 656:../Src/main.c ****                 break;
 657:../Src/main.c ****             }
 658:../Src/main.c ****             LoopNb = LoopNb + 1;
ARM GAS  /tmp/cceAljft.s 			page 13


 659:../Src/main.c ****             VL53L0X_PollingDelay(Dev);
 660:../Src/main.c ****         } while (LoopNb < VL53L0X_DEFAULT_MAX_LOOP);
 661:../Src/main.c **** 
 662:../Src/main.c ****         if (LoopNb >= VL53L0X_DEFAULT_MAX_LOOP) {
 663:../Src/main.c ****             Status = VL53L0X_ERROR_TIME_OUT;
 664:../Src/main.c ****         }
 665:../Src/main.c **** 
 666:../Src/main.c ****     }
 667:../Src/main.c **** 
 668:../Src/main.c ****     return Status;
 669:../Src/main.c **** }
 670:../Src/main.c **** 
 671:../Src/main.c **** 
 672:../Src/main.c **** void AlarmDemo(void){
 673:../Src/main.c ****     VL53L0X_Dev_t *pDev;
 674:../Src/main.c ****     uint8_t VhvSettings;
 675:../Src/main.c ****     uint8_t PhaseCal;
 676:../Src/main.c ****     uint32_t refSpadCount;
 677:../Src/main.c **** 	uint8_t isApertureSpads;
 678:../Src/main.c **** 	VL53L0X_RangingMeasurementData_t RangingMeasurementData;
 679:../Src/main.c ****     int status;
 680:../Src/main.c ****     int Over=0;
 681:../Src/main.c ****     int Mode=0;
 682:../Src/main.c ****     char StrDisplay[5]="----";
 683:../Src/main.c **** 
 684:../Src/main.c ****     /* Only center device is used */
 685:../Src/main.c ****     pDev=&VL53L0XDevs[1];
 686:../Src/main.c **** 
 687:../Src/main.c **** 
 688:../Src/main.c ****     /* configure BSP/MCU center sensor interrupt */
 689:../Src/main.c ****     VL53L0A1_EXTI_IOConfigure(XNUCLEO53L0A1_DEV_CENTER, 0, 0);
 690:../Src/main.c ****     XNUCLEO53L0A1_SetIntrStateId(1, XNUCLEO53L0A1_DEV_CENTER);
 691:../Src/main.c **** 
 692:../Src/main.c ****     /* Initialize the device in continuous ranging mode */
 693:../Src/main.c **** 	VL53L0X_StaticInit(pDev);
 694:../Src/main.c **** 	VL53L0X_PerformRefCalibration(pDev, &VhvSettings, &PhaseCal);
 695:../Src/main.c **** 	VL53L0X_PerformRefSpadManagement(pDev, &refSpadCount, &isApertureSpads);
 696:../Src/main.c **** 	VL53L0X_SetInterMeasurementPeriodMilliSeconds(pDev, 250);
 697:../Src/main.c **** 	VL53L0X_SetDeviceMode(pDev, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING);
 698:../Src/main.c **** 
 699:../Src/main.c ****     do{
 700:../Src/main.c ****        /* set sensor interrupt mode */
 701:../Src/main.c ****        VL53L0X_StopMeasurement(pDev);           // it is safer to do this while sensor is stopped
 702:../Src/main.c ****        VL53L0X_SetInterruptThresholds(pDev, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING ,  AlarmModes[Mod
 703:../Src/main.c ****        status = VL53L0X_SetGpioConfig(pDev, 0, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING, AlarmModes[Mo
 704:../Src/main.c ****        status = VL53L0X_ClearInterruptMask(pDev, -1); // clear interrupt pending if any
 705:../Src/main.c **** 
 706:../Src/main.c ****        /* Start continuous ranging */
 707:../Src/main.c ****        VL53L0X_StartMeasurement(pDev);
 708:../Src/main.c ****        IntrCounts[1]=0;
 709:../Src/main.c **** 
 710:../Src/main.c ****        /* Check for interrupt */
 711:../Src/main.c ****        do{
 712:../Src/main.c ****            __WFI();
 713:../Src/main.c ****            /* Interrupt received */
 714:../Src/main.c ****            if( IntrCounts[1] !=0 ){
 715:../Src/main.c ****         	   /* Reset interrupt counter */
ARM GAS  /tmp/cceAljft.s 			page 14


 716:../Src/main.c ****                IntrCounts[1]=0;
 717:../Src/main.c ****                /* Get ranging data and display distance*/
 718:../Src/main.c ****                VL53L0X_GetRangingMeasurementData(pDev, &RangingMeasurementData);
 719:../Src/main.c ****                sprintf(StrDisplay, "%3dc",(int)RangingMeasurementData.RangeMilliMeter/10);
 720:../Src/main.c ****                /* Clear interrupt */
 721:../Src/main.c ****                status = VL53L0X_ClearInterruptMask(pDev, -1);
 722:../Src/main.c ****                /* keep display for at least 100ms otherwise user may never see it on display*/
 723:../Src/main.c ****                XNUCLEO53L0A1_SetDisplayString(StrDisplay);
 724:../Src/main.c ****                HAL_Delay(100);
 725:../Src/main.c ****            }
 726:../Src/main.c ****            else{
 727:../Src/main.c ****         	   /* No interrupt received => Display alarm mode */
 728:../Src/main.c ****                XNUCLEO53L0A1_SetDisplayString(AlarmModes[Mode].Name);
 729:../Src/main.c ****            }
 730:../Src/main.c ****            /* Check blue button */
 731:../Src/main.c ****            if( !BSP_GetPushButton() ){
 732:../Src/main.c ****                break;
 733:../Src/main.c ****            }
 734:../Src/main.c ****        }while(1);
 735:../Src/main.c ****        /* Wait button to be released to decide if it is a short or long press */
 736:../Src/main.c ****        status=PusbButton_WaitUnPress();
 737:../Src/main.c ****        /* Long press => stop this demo */
 738:../Src/main.c ****        if( status )
 739:../Src/main.c ****            Over =1;
 740:../Src/main.c ****        /* Short press => change alarm mode */
 741:../Src/main.c ****        Mode=(Mode+1)%ARRAY_SIZE(AlarmModes);
 742:../Src/main.c ****     }while( !Over );
 743:../Src/main.c **** 
 744:../Src/main.c ****     /* Stop continuous ranging */
 745:../Src/main.c ****     VL53L0X_StopMeasurement(pDev);
 746:../Src/main.c **** 
 747:../Src/main.c ****     /* Ensure device is ready for other commands */
 748:../Src/main.c ****     WaitStopCompleted(pDev);
 749:../Src/main.c **** 
 750:../Src/main.c ****     /* Disable configuration of BSP/MCU center sensor interrupt */
 751:../Src/main.c ****     XNUCLEO53L0A1_SetIntrStateId(0, XNUCLEO53L0A1_DEV_CENTER);
 752:../Src/main.c ****     VL53L0A1_EXTI_IOUnconfigure(XNUCLEO53L0A1_DEV_CENTER);
 753:../Src/main.c **** }
 754:../Src/main.c **** #endif
 755:../Src/main.c **** 
 756:../Src/main.c **** void ResetAndDetectSensor(int SetDisplay){
 757:../Src/main.c ****     int nSensor;
 758:../Src/main.c ****     nSensor = DetectSensors(SetDisplay);
 759:../Src/main.c ****     /* at least one sensor and if one it must be the built-in one  */
 760:../Src/main.c ****     if( (nSensor <=0) ||  (nSensor ==1 && VL53L0XDevs[1].Present==0) ){
 761:../Src/main.c ****         HandleError(ERR_DETECT);
 762:../Src/main.c ****     }
 763:../Src/main.c **** }
 764:../Src/main.c **** 
 765:../Src/main.c **** /* USER CODE END 0 */
 766:../Src/main.c **** 
 767:../Src/main.c **** int main(void)
 768:../Src/main.c **** {
 769:../Src/main.c **** 
 770:../Src/main.c ****   /* USER CODE BEGIN 1 */
 771:../Src/main.c ****   int ExitWithLongPress;
 772:../Src/main.c ****   RangingConfig_e RangingConfig = LONG_RANGE;
ARM GAS  /tmp/cceAljft.s 			page 15


 773:../Src/main.c ****   DemoMode_e DemoMode = RANGE_VALUE;
 774:../Src/main.c ****   int UseSensorsMask = 1<<XNUCLEO53L0A1_DEV_CENTER;
 775:../Src/main.c ****   /* USER CODE END 1 */
 776:../Src/main.c **** 
 777:../Src/main.c ****   /* MCU Configuration----------------------------------------------------------*/
 778:../Src/main.c **** 
 779:../Src/main.c ****   /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
 780:../Src/main.c ****   HAL_Init();
 781:../Src/main.c **** 
 782:../Src/main.c ****   /* Configure the system clock */
 783:../Src/main.c ****   SystemClock_Config();
 784:../Src/main.c **** 
 785:../Src/main.c ****   /* Initialize all configured peripherals */
 786:../Src/main.c ****   MX_GPIO_Init();
 787:../Src/main.c ****   SystemClock_Config();
 788:../Src/main.c ****   MX_I2C1_Init();
 789:../Src/main.c ****   MX_TIM3_Init();
 790:../Src/main.c **** 
 791:../Src/main.c ****   /* USER CODE BEGIN 2 */
 792:../Src/main.c ****   XNUCLEO53L0A1_Init();
 793:../Src/main.c ****   uart_printf(WelcomeMsg);
 794:../Src/main.c ****   XNUCLEO53L0A1_SetDisplayString("53L0");
 795:../Src/main.c ****   HAL_Delay(WelcomeTime);
 796:../Src/main.c ****   ResetAndDetectSensor(1);
 797:../Src/main.c ****   HAL_TIM_Base_Start_IT(&htim3); //£
 798:../Src/main.c **** 
 799:../Src/main.c ****   /* Set VL53L0X API trace level */
 800:../Src/main.c ****   VL53L0X_trace_config(NULL, TRACE_MODULE_NONE, TRACE_LEVEL_NONE, TRACE_FUNCTION_NONE); // No Trace
 801:../Src/main.c ****   //VL53L0X_trace_config(NULL,TRACE_MODULE_ALL, TRACE_LEVEL_ALL, TRACE_FUNCTION_ALL); // Full trace
 802:../Src/main.c **** 
 803:../Src/main.c **** 
 804:../Src/main.c ****   /* USER CODE END 2 */
 805:../Src/main.c **** 
 806:../Src/main.c ****   /* USER CODE BEGIN 3 */
 807:../Src/main.c ****   /* Infinite loop */
 808:../Src/main.c ****   /* USER CODE BEGIN WHILE */
 809:../Src/main.c ****   while (1)
 810:../Src/main.c ****   {
 811:../Src/main.c ****   /* USER CODE END WHILE */
 812:../Src/main.c ****       /* Display demo mode */
 813:../Src/main.c ****       XNUCLEO53L0A1_SetDisplayString(DemoModeTxt[DemoMode]);
 814:../Src/main.c ****       HAL_Delay(ModeChangeDispTime);
 815:../Src/main.c **** 
 816:../Src/main.c ****       /* Display Ranging config */
 817:../Src/main.c **** 	  XNUCLEO53L0A1_SetDisplayString(RangingConfigTxt[RangingConfig]);
 818:../Src/main.c **** 	  HAL_Delay(ModeChangeDispTime);
 819:../Src/main.c **** 
 820:../Src/main.c **** 	  /* Reset and Detect all sensors */
 821:../Src/main.c ****       ResetAndDetectSensor(0);
 822:../Src/main.c **** 
 823:../Src/main.c ****       /* Reset Timestamping */
 824:../Src/main.c ****       TimeStamp_Reset();
 825:../Src/main.c **** 
 826:../Src/main.c **** #if HAVE_ALARM_DEMO
 827:../Src/main.c ****       XNUCLEO53L0A1_SetDisplayString(TxtAlarm);
 828:../Src/main.c ****       HAL_Delay(ModeChangeDispTime);
 829:../Src/main.c ****       ResetAndDetectSensor(0);
ARM GAS  /tmp/cceAljft.s 			page 16


 830:../Src/main.c ****       AlarmDemo();
 831:../Src/main.c **** #else
 832:../Src/main.c **** 
 833:../Src/main.c ****       /* Start Ranging demo */
 834:../Src/main.c ****       ExitWithLongPress = RangeDemo(UseSensorsMask, RangingConfig);
 835:../Src/main.c **** 
 836:../Src/main.c ****       /* Blue button has been pressed (long or short press) */
 837:../Src/main.c ****       if(ExitWithLongPress){
 838:../Src/main.c ****     	  /* Long press : change demo mode if multiple sensors present*/
 839:../Src/main.c ****     	  if( nDevPresent >1 ){
 840:../Src/main.c ****     		  /* If more than one sensor is present then toggle demo mode */
 841:../Src/main.c ****     		  DemoMode = (DemoMode == RANGE_VALUE) ? BAR_GRAPH : RANGE_VALUE;
 842:../Src/main.c ****     		  UseSensorsMask = (DemoMode == BAR_GRAPH) ? 0x7 : 1<<XNUCLEO53L0A1_DEV_CENTER;
 843:../Src/main.c ****     	  }
 844:../Src/main.c ****       } else {
 845:../Src/main.c ****     	  /* Short press : change ranging config */
 846:../Src/main.c ****     	  RangingConfig = (RangingConfig == LONG_RANGE) ? HIGH_SPEED : ((RangingConfig == HIGH_SPEED) 
 847:../Src/main.c ****       }
 848:../Src/main.c **** #endif
 849:../Src/main.c ****   }
 850:../Src/main.c ****   /* USER CODE END 3 */
 851:../Src/main.c **** 
 852:../Src/main.c **** }
 853:../Src/main.c **** 
 854:../Src/main.c **** /** System Clock Configuration
 855:../Src/main.c **** */
 856:../Src/main.c **** void SystemClock_Config(void)
 857:../Src/main.c **** {
 858:../Src/main.c **** 
 859:../Src/main.c ****   RCC_OscInitTypeDef RCC_OscInitStruct;
 860:../Src/main.c ****   RCC_ClkInitTypeDef RCC_ClkInitStruct;
 861:../Src/main.c **** 
 862:../Src/main.c ****   __PWR_CLK_ENABLE();
 863:../Src/main.c **** 
 864:../Src/main.c ****   __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 865:../Src/main.c **** 
 866:../Src/main.c ****   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 867:../Src/main.c ****   RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 868:../Src/main.c ****   RCC_OscInitStruct.HSICalibrationValue = 6;
 869:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 870:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 871:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLM = 16;
 872:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLN = 336;
 873:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 874:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLQ = 7;
 875:../Src/main.c ****   HAL_RCC_OscConfig(&RCC_OscInitStruct);
 876:../Src/main.c **** 
 877:../Src/main.c ****   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1;
 878:../Src/main.c ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 879:../Src/main.c ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 880:../Src/main.c ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 881:../Src/main.c ****   RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 882:../Src/main.c ****   HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 883:../Src/main.c **** 
 884:../Src/main.c **** }
 885:../Src/main.c **** 
 886:../Src/main.c **** /* I2C1 init function */
ARM GAS  /tmp/cceAljft.s 			page 17


 887:../Src/main.c **** void MX_I2C1_Init(void)
 888:../Src/main.c **** {
 889:../Src/main.c **** 
 890:../Src/main.c ****   hi2c1.Instance = I2C1;
 891:../Src/main.c ****   hi2c1.Init.ClockSpeed = 400000;
 892:../Src/main.c ****   hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
 893:../Src/main.c ****   hi2c1.Init.OwnAddress1 = 0;
 894:../Src/main.c ****   hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 895:../Src/main.c ****   hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLED;
 896:../Src/main.c ****   hi2c1.Init.OwnAddress2 = 0;
 897:../Src/main.c ****   hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLED;
 898:../Src/main.c ****   hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLED;
 899:../Src/main.c ****   HAL_I2C_Init(&hi2c1);
 900:../Src/main.c **** 
 901:../Src/main.c **** }
 902:../Src/main.c **** 
 903:../Src/main.c **** /* TIM3 init function */
 904:../Src/main.c **** void MX_TIM3_Init(void)
 905:../Src/main.c **** {
 906:../Src/main.c **** 
 907:../Src/main.c ****   TIM_ClockConfigTypeDef sClockSourceConfig;
 908:../Src/main.c ****   TIM_MasterConfigTypeDef sMasterConfig;
 909:../Src/main.c **** 
 910:../Src/main.c ****   htim3.Instance = TIM3;
 911:../Src/main.c ****   htim3.Init.Prescaler = 42000-1;
 912:../Src/main.c ****   htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 913:../Src/main.c ****   htim3.Init.Period = 1000-1;
 914:../Src/main.c ****   htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 915:../Src/main.c ****   HAL_TIM_Base_Init(&htim3);
 916:../Src/main.c **** 
 917:../Src/main.c ****   sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 918:../Src/main.c ****   HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);
 919:../Src/main.c **** 
 920:../Src/main.c ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 921:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 922:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);
 923:../Src/main.c **** 
 924:../Src/main.c **** }
 925:../Src/main.c **** 
 926:../Src/main.c **** /** Configure pins as 
 927:../Src/main.c ****         * Analog 
 928:../Src/main.c ****         * Input 
 929:../Src/main.c ****         * Output
 930:../Src/main.c ****         * EVENT_OUT
 931:../Src/main.c ****         * EXTI
 932:../Src/main.c **** */
 933:../Src/main.c **** void MX_GPIO_Init(void)
 934:../Src/main.c **** {
  28              		.loc 1 934 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 24
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32 0000 10B5     		push	{r4, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 4, -8
  36              		.cfi_offset 14, -4
ARM GAS  /tmp/cceAljft.s 			page 18


  37 0002 86B0     		sub	sp, sp, #24
  38              	.LCFI1:
  39              		.cfi_def_cfa_offset 32
 935:../Src/main.c **** 
 936:../Src/main.c ****   GPIO_InitTypeDef GPIO_InitStruct;
 937:../Src/main.c **** 
 938:../Src/main.c ****   /* GPIO Ports Clock Enable */
 939:../Src/main.c ****   __GPIOC_CLK_ENABLE();
  40              		.loc 1 939 0
  41 0004 134B     		ldr	r3, .L3
  42 0006 1A6B     		ldr	r2, [r3, #48]
  43 0008 42F00402 		orr	r2, r2, #4
  44 000c 1A63     		str	r2, [r3, #48]
 940:../Src/main.c ****   __GPIOH_CLK_ENABLE();
  45              		.loc 1 940 0
  46 000e 1A6B     		ldr	r2, [r3, #48]
  47 0010 42F08002 		orr	r2, r2, #128
  48 0014 1A63     		str	r2, [r3, #48]
 941:../Src/main.c ****   __GPIOA_CLK_ENABLE();
  49              		.loc 1 941 0
  50 0016 1A6B     		ldr	r2, [r3, #48]
  51 0018 42F00102 		orr	r2, r2, #1
  52 001c 1A63     		str	r2, [r3, #48]
 942:../Src/main.c ****   __GPIOB_CLK_ENABLE();
  53              		.loc 1 942 0
  54 001e 1A6B     		ldr	r2, [r3, #48]
  55 0020 42F00202 		orr	r2, r2, #2
  56 0024 1A63     		str	r2, [r3, #48]
 943:../Src/main.c **** 
 944:../Src/main.c ****   /*Configure GPIO pin : PC13 */
 945:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_13;
  57              		.loc 1 945 0
  58 0026 4FF40053 		mov	r3, #8192
  59 002a 0193     		str	r3, [sp, #4]
 946:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  60              		.loc 1 946 0
  61 002c 0024     		movs	r4, #0
  62 002e 0294     		str	r4, [sp, #8]
 947:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
  63              		.loc 1 947 0
  64 0030 0394     		str	r4, [sp, #12]
 948:../Src/main.c ****   HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  65              		.loc 1 948 0
  66 0032 0948     		ldr	r0, .L3+4
  67 0034 01A9     		add	r1, sp, #4
  68 0036 FFF7FEFF 		bl	HAL_GPIO_Init
  69              	.LVL0:
 949:../Src/main.c **** 
 950:../Src/main.c ****   /*Configure GPIO pin : PA5 */
 951:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_5;
  70              		.loc 1 951 0
  71 003a 2023     		movs	r3, #32
  72 003c 0193     		str	r3, [sp, #4]
 952:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  73              		.loc 1 952 0
  74 003e 0123     		movs	r3, #1
  75 0040 0293     		str	r3, [sp, #8]
ARM GAS  /tmp/cceAljft.s 			page 19


 953:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
  76              		.loc 1 953 0
  77 0042 0394     		str	r4, [sp, #12]
 954:../Src/main.c ****   GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  78              		.loc 1 954 0
  79 0044 0494     		str	r4, [sp, #16]
 955:../Src/main.c ****   HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  80              		.loc 1 955 0
  81 0046 0548     		ldr	r0, .L3+8
  82 0048 01A9     		add	r1, sp, #4
  83 004a FFF7FEFF 		bl	HAL_GPIO_Init
  84              	.LVL1:
 956:../Src/main.c **** 
 957:../Src/main.c **** }
  85              		.loc 1 957 0
  86 004e 06B0     		add	sp, sp, #24
  87              	.LCFI2:
  88              		.cfi_def_cfa_offset 8
  89              		@ sp needed
  90 0050 10BD     		pop	{r4, pc}
  91              	.L4:
  92 0052 00BF     		.align	2
  93              	.L3:
  94 0054 00380240 		.word	1073887232
  95 0058 00080240 		.word	1073874944
  96 005c 00000240 		.word	1073872896
  97              		.cfi_endproc
  98              	.LFE130:
 100              		.section	.text.MX_I2C1_Init,"ax",%progbits
 101              		.align	2
 102              		.thumb
 103              		.thumb_func
 105              	MX_I2C1_Init:
 106              	.LFB128:
 888:../Src/main.c **** 
 107              		.loc 1 888 0
 108              		.cfi_startproc
 109              		@ args = 0, pretend = 0, frame = 0
 110              		@ frame_needed = 0, uses_anonymous_args = 0
 111 0000 08B5     		push	{r3, lr}
 112              	.LCFI3:
 113              		.cfi_def_cfa_offset 8
 114              		.cfi_offset 3, -8
 115              		.cfi_offset 14, -4
 890:../Src/main.c ****   hi2c1.Init.ClockSpeed = 400000;
 116              		.loc 1 890 0
 117 0002 0948     		ldr	r0, .L7
 118 0004 094B     		ldr	r3, .L7+4
 119 0006 0360     		str	r3, [r0]
 891:../Src/main.c ****   hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
 120              		.loc 1 891 0
 121 0008 094B     		ldr	r3, .L7+8
 122 000a 4360     		str	r3, [r0, #4]
 892:../Src/main.c ****   hi2c1.Init.OwnAddress1 = 0;
 123              		.loc 1 892 0
 124 000c 0023     		movs	r3, #0
 125 000e 8360     		str	r3, [r0, #8]
ARM GAS  /tmp/cceAljft.s 			page 20


 893:../Src/main.c ****   hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 126              		.loc 1 893 0
 127 0010 C360     		str	r3, [r0, #12]
 894:../Src/main.c ****   hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLED;
 128              		.loc 1 894 0
 129 0012 4FF48042 		mov	r2, #16384
 130 0016 0261     		str	r2, [r0, #16]
 895:../Src/main.c ****   hi2c1.Init.OwnAddress2 = 0;
 131              		.loc 1 895 0
 132 0018 4361     		str	r3, [r0, #20]
 896:../Src/main.c ****   hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLED;
 133              		.loc 1 896 0
 134 001a 8361     		str	r3, [r0, #24]
 897:../Src/main.c ****   hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLED;
 135              		.loc 1 897 0
 136 001c C361     		str	r3, [r0, #28]
 898:../Src/main.c ****   HAL_I2C_Init(&hi2c1);
 137              		.loc 1 898 0
 138 001e 0362     		str	r3, [r0, #32]
 899:../Src/main.c **** 
 139              		.loc 1 899 0
 140 0020 FFF7FEFF 		bl	HAL_I2C_Init
 141              	.LVL2:
 142 0024 08BD     		pop	{r3, pc}
 143              	.L8:
 144 0026 00BF     		.align	2
 145              	.L7:
 146 0028 00000000 		.word	hi2c1
 147 002c 00540040 		.word	1073763328
 148 0030 801A0600 		.word	400000
 149              		.cfi_endproc
 150              	.LFE128:
 152              		.section	.text.MX_TIM3_Init,"ax",%progbits
 153              		.align	2
 154              		.thumb
 155              		.thumb_func
 157              	MX_TIM3_Init:
 158              	.LFB129:
 905:../Src/main.c **** 
 159              		.loc 1 905 0
 160              		.cfi_startproc
 161              		@ args = 0, pretend = 0, frame = 24
 162              		@ frame_needed = 0, uses_anonymous_args = 0
 163 0000 30B5     		push	{r4, r5, lr}
 164              	.LCFI4:
 165              		.cfi_def_cfa_offset 12
 166              		.cfi_offset 4, -12
 167              		.cfi_offset 5, -8
 168              		.cfi_offset 14, -4
 169 0002 87B0     		sub	sp, sp, #28
 170              	.LCFI5:
 171              		.cfi_def_cfa_offset 40
 910:../Src/main.c ****   htim3.Init.Prescaler = 42000-1;
 172              		.loc 1 910 0
 173 0004 0F4C     		ldr	r4, .L11
 174 0006 104B     		ldr	r3, .L11+4
 175 0008 2360     		str	r3, [r4]
ARM GAS  /tmp/cceAljft.s 			page 21


 911:../Src/main.c ****   htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 176              		.loc 1 911 0
 177 000a 4AF20F43 		movw	r3, #41999
 178 000e 6360     		str	r3, [r4, #4]
 912:../Src/main.c ****   htim3.Init.Period = 1000-1;
 179              		.loc 1 912 0
 180 0010 0025     		movs	r5, #0
 181 0012 A560     		str	r5, [r4, #8]
 913:../Src/main.c ****   htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 182              		.loc 1 913 0
 183 0014 40F2E733 		movw	r3, #999
 184 0018 E360     		str	r3, [r4, #12]
 914:../Src/main.c ****   HAL_TIM_Base_Init(&htim3);
 185              		.loc 1 914 0
 186 001a 2561     		str	r5, [r4, #16]
 915:../Src/main.c **** 
 187              		.loc 1 915 0
 188 001c 2046     		mov	r0, r4
 189 001e FFF7FEFF 		bl	HAL_TIM_Base_Init
 190              	.LVL3:
 917:../Src/main.c ****   HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);
 191              		.loc 1 917 0
 192 0022 06A9     		add	r1, sp, #24
 193 0024 4FF48053 		mov	r3, #4096
 194 0028 41F8103D 		str	r3, [r1, #-16]!
 918:../Src/main.c **** 
 195              		.loc 1 918 0
 196 002c 2046     		mov	r0, r4
 197 002e FFF7FEFF 		bl	HAL_TIM_ConfigClockSource
 198              	.LVL4:
 920:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 199              		.loc 1 920 0
 200 0032 0095     		str	r5, [sp]
 921:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);
 201              		.loc 1 921 0
 202 0034 0195     		str	r5, [sp, #4]
 922:../Src/main.c **** 
 203              		.loc 1 922 0
 204 0036 2046     		mov	r0, r4
 205 0038 6946     		mov	r1, sp
 206 003a FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 207              	.LVL5:
 924:../Src/main.c **** 
 208              		.loc 1 924 0
 209 003e 07B0     		add	sp, sp, #28
 210              	.LCFI6:
 211              		.cfi_def_cfa_offset 12
 212              		@ sp needed
 213 0040 30BD     		pop	{r4, r5, pc}
 214              	.L12:
 215 0042 00BF     		.align	2
 216              	.L11:
 217 0044 00000000 		.word	htim3
 218 0048 00040040 		.word	1073742848
 219              		.cfi_endproc
 220              	.LFE129:
 222              		.section	.text.MX_TIM5_Init,"ax",%progbits
ARM GAS  /tmp/cceAljft.s 			page 22


 223              		.align	2
 224              		.global	MX_TIM5_Init
 225              		.thumb
 226              		.thumb_func
 228              	MX_TIM5_Init:
 229              	.LFB112:
 162:../Src/main.c **** 
 230              		.loc 1 162 0
 231              		.cfi_startproc
 232              		@ args = 0, pretend = 0, frame = 40
 233              		@ frame_needed = 0, uses_anonymous_args = 0
 234 0000 30B5     		push	{r4, r5, lr}
 235              	.LCFI7:
 236              		.cfi_def_cfa_offset 12
 237              		.cfi_offset 4, -12
 238              		.cfi_offset 5, -8
 239              		.cfi_offset 14, -4
 240 0002 8BB0     		sub	sp, sp, #44
 241              	.LCFI8:
 242              		.cfi_def_cfa_offset 56
 167:../Src/main.c ****   htim5.Init.Prescaler = 83;
 243              		.loc 1 167 0
 244 0004 0F4D     		ldr	r5, .L15
 245 0006 104B     		ldr	r3, .L15+4
 246 0008 2B60     		str	r3, [r5]
 168:../Src/main.c ****   htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 247              		.loc 1 168 0
 248 000a 5323     		movs	r3, #83
 249 000c 6B60     		str	r3, [r5, #4]
 169:../Src/main.c ****   htim5.Init.Period = 0xFFFFFFFF;
 250              		.loc 1 169 0
 251 000e 0024     		movs	r4, #0
 252 0010 AC60     		str	r4, [r5, #8]
 170:../Src/main.c ****   htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 253              		.loc 1 170 0
 254 0012 4FF0FF33 		mov	r3, #-1
 255 0016 EB60     		str	r3, [r5, #12]
 171:../Src/main.c ****   HAL_TIM_OC_Init(&htim5);
 256              		.loc 1 171 0
 257 0018 2C61     		str	r4, [r5, #16]
 172:../Src/main.c **** 
 258              		.loc 1 172 0
 259 001a 2846     		mov	r0, r5
 260 001c FFF7FEFF 		bl	HAL_TIM_OC_Init
 261              	.LVL6:
 174:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 262              		.loc 1 174 0
 263 0020 0894     		str	r4, [sp, #32]
 175:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig);
 264              		.loc 1 175 0
 265 0022 0994     		str	r4, [sp, #36]
 176:../Src/main.c **** 
 266              		.loc 1 176 0
 267 0024 2846     		mov	r0, r5
 268 0026 08A9     		add	r1, sp, #32
 269 0028 FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 270              	.LVL7:
ARM GAS  /tmp/cceAljft.s 			page 23


 178:../Src/main.c ****   sConfigOC.Pulse = 0;
 271              		.loc 1 178 0
 272 002c 0194     		str	r4, [sp, #4]
 179:../Src/main.c ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 273              		.loc 1 179 0
 274 002e 0294     		str	r4, [sp, #8]
 180:../Src/main.c ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 275              		.loc 1 180 0
 276 0030 0394     		str	r4, [sp, #12]
 181:../Src/main.c ****   HAL_TIM_OC_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1);
 277              		.loc 1 181 0
 278 0032 0594     		str	r4, [sp, #20]
 182:../Src/main.c **** 
 279              		.loc 1 182 0
 280 0034 2846     		mov	r0, r5
 281 0036 01A9     		add	r1, sp, #4
 282 0038 2246     		mov	r2, r4
 283 003a FFF7FEFF 		bl	HAL_TIM_OC_ConfigChannel
 284              	.LVL8:
 184:../Src/main.c **** 
 285              		.loc 1 184 0
 286 003e 0BB0     		add	sp, sp, #44
 287              	.LCFI9:
 288              		.cfi_def_cfa_offset 12
 289              		@ sp needed
 290 0040 30BD     		pop	{r4, r5, pc}
 291              	.L16:
 292 0042 00BF     		.align	2
 293              	.L15:
 294 0044 00000000 		.word	htim5
 295 0048 000C0040 		.word	1073744896
 296              		.cfi_endproc
 297              	.LFE112:
 299              		.section	.text.TimeStamp_Init,"ax",%progbits
 300              		.align	2
 301              		.global	TimeStamp_Init
 302              		.thumb
 303              		.thumb_func
 305              	TimeStamp_Init:
 306              	.LFB113:
 186:../Src/main.c ****     MX_TIM5_Init();
 307              		.loc 1 186 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311 0000 08B5     		push	{r3, lr}
 312              	.LCFI10:
 313              		.cfi_def_cfa_offset 8
 314              		.cfi_offset 3, -8
 315              		.cfi_offset 14, -4
 187:../Src/main.c **** }
 316              		.loc 1 187 0
 317 0002 FFF7FEFF 		bl	MX_TIM5_Init
 318              	.LVL9:
 319 0006 08BD     		pop	{r3, pc}
 320              		.cfi_endproc
 321              	.LFE113:
ARM GAS  /tmp/cceAljft.s 			page 24


 323              		.section	.text.TimeStamp_Reset,"ax",%progbits
 324              		.align	2
 325              		.global	TimeStamp_Reset
 326              		.thumb
 327              		.thumb_func
 329              	TimeStamp_Reset:
 330              	.LFB114:
 190:../Src/main.c ****     HAL_TIM_Base_Start(&htim5);
 331              		.loc 1 190 0
 332              		.cfi_startproc
 333              		@ args = 0, pretend = 0, frame = 0
 334              		@ frame_needed = 0, uses_anonymous_args = 0
 335 0000 10B5     		push	{r4, lr}
 336              	.LCFI11:
 337              		.cfi_def_cfa_offset 8
 338              		.cfi_offset 4, -8
 339              		.cfi_offset 14, -4
 191:../Src/main.c ****     htim5.Instance->CNT=0;
 340              		.loc 1 191 0
 341 0002 044C     		ldr	r4, .L21
 342 0004 2046     		mov	r0, r4
 343 0006 FFF7FEFF 		bl	HAL_TIM_Base_Start
 344              	.LVL10:
 192:../Src/main.c **** }
 345              		.loc 1 192 0
 346 000a 2368     		ldr	r3, [r4]
 347 000c 0022     		movs	r2, #0
 348 000e 5A62     		str	r2, [r3, #36]
 349 0010 10BD     		pop	{r4, pc}
 350              	.L22:
 351 0012 00BF     		.align	2
 352              	.L21:
 353 0014 00000000 		.word	htim5
 354              		.cfi_endproc
 355              	.LFE114:
 357              		.section	.text.TimeStamp_Get,"ax",%progbits
 358              		.align	2
 359              		.global	TimeStamp_Get
 360              		.thumb
 361              		.thumb_func
 363              	TimeStamp_Get:
 364              	.LFB115:
 195:../Src/main.c ****     return htim5.Instance->CNT;
 365              		.loc 1 195 0
 366              		.cfi_startproc
 367              		@ args = 0, pretend = 0, frame = 0
 368              		@ frame_needed = 0, uses_anonymous_args = 0
 369              		@ link register save eliminated.
 196:../Src/main.c **** }
 370              		.loc 1 196 0
 371 0000 014B     		ldr	r3, .L24
 372 0002 1B68     		ldr	r3, [r3]
 373 0004 586A     		ldr	r0, [r3, #36]
 197:../Src/main.c **** 
 374              		.loc 1 197 0
 375 0006 7047     		bx	lr
 376              	.L25:
ARM GAS  /tmp/cceAljft.s 			page 25


 377              		.align	2
 378              	.L24:
 379 0008 00000000 		.word	htim5
 380              		.cfi_endproc
 381              	.LFE115:
 383              		.section	.text.BSP_GetPushButton,"ax",%progbits
 384              		.align	2
 385              		.global	BSP_GetPushButton
 386              		.thumb
 387              		.thumb_func
 389              	BSP_GetPushButton:
 390              	.LFB116:
 228:../Src/main.c ****     GPIO_PinState state ;
 391              		.loc 1 228 0
 392              		.cfi_startproc
 393              		@ args = 0, pretend = 0, frame = 0
 394              		@ frame_needed = 0, uses_anonymous_args = 0
 395 0000 08B5     		push	{r3, lr}
 396              	.LCFI12:
 397              		.cfi_def_cfa_offset 8
 398              		.cfi_offset 3, -8
 399              		.cfi_offset 14, -4
 230:../Src/main.c ****     return state;
 400              		.loc 1 230 0
 401 0002 0348     		ldr	r0, .L28
 402 0004 4FF40051 		mov	r1, #8192
 403 0008 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 404              	.LVL11:
 232:../Src/main.c **** 
 405              		.loc 1 232 0
 406 000c 08BD     		pop	{r3, pc}
 407              	.L29:
 408 000e 00BF     		.align	2
 409              	.L28:
 410 0010 00080240 		.word	1073874944
 411              		.cfi_endproc
 412              	.LFE116:
 414              		.section	.text.PusbButton_WaitUnPress,"ax",%progbits
 415              		.align	2
 416              		.global	PusbButton_WaitUnPress
 417              		.thumb
 418              		.thumb_func
 420              	PusbButton_WaitUnPress:
 421              	.LFB117:
 244:../Src/main.c ****     uint32_t TimeStarted;
 422              		.loc 1 244 0
 423              		.cfi_startproc
 424              		@ args = 0, pretend = 0, frame = 0
 425              		@ frame_needed = 0, uses_anonymous_args = 0
 426 0000 10B5     		push	{r4, lr}
 427              	.LCFI13:
 428              		.cfi_def_cfa_offset 8
 429              		.cfi_offset 4, -8
 430              		.cfi_offset 14, -4
 246:../Src/main.c ****     while( !BSP_GetPushButton() ){ ; /* debounce */
 431              		.loc 1 246 0
 432 0002 FFF7FEFF 		bl	HAL_GetTick
ARM GAS  /tmp/cceAljft.s 			page 26


 433              	.LVL12:
 434 0006 0446     		mov	r4, r0
 435              	.LVL13:
 247:../Src/main.c ****         if(HAL_GetTick()- TimeStarted> PressBPSwicthTime){
 436              		.loc 1 247 0
 437 0008 08E0     		b	.L32
 438              	.LVL14:
 439              	.L33:
 248:../Src/main.c ****             XNUCLEO53L0A1_SetDisplayString (" rb ");
 440              		.loc 1 248 0
 441 000a FFF7FEFF 		bl	HAL_GetTick
 442              	.LVL15:
 443 000e 001B     		subs	r0, r0, r4
 444 0010 B0F57A7F 		cmp	r0, #1000
 445 0014 02D9     		bls	.L32
 249:../Src/main.c ****         }
 446              		.loc 1 249 0
 447 0016 0848     		ldr	r0, .L35
 448 0018 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 449              	.LVL16:
 450              	.L32:
 247:../Src/main.c ****         if(HAL_GetTick()- TimeStarted> PressBPSwicthTime){
 451              		.loc 1 247 0
 452 001c FFF7FEFF 		bl	BSP_GetPushButton
 453              	.LVL17:
 454 0020 0028     		cmp	r0, #0
 455 0022 F2D0     		beq	.L33
 252:../Src/main.c **** 
 456              		.loc 1 252 0
 457 0024 FFF7FEFF 		bl	HAL_GetTick
 458              	.LVL18:
 459 0028 001B     		subs	r0, r0, r4
 254:../Src/main.c **** 
 460              		.loc 1 254 0
 461 002a B0F57A7F 		cmp	r0, #1000
 462 002e 94BF     		ite	ls
 463 0030 0020     		movls	r0, #0
 464 0032 0120     		movhi	r0, #1
 465 0034 10BD     		pop	{r4, pc}
 466              	.LVL19:
 467              	.L36:
 468 0036 00BF     		.align	2
 469              	.L35:
 470 0038 00000000 		.word	.LC0
 471              		.cfi_endproc
 472              	.LFE117:
 474              		.section	.text.HandleError,"ax",%progbits
 475              		.align	2
 476              		.global	HandleError
 477              		.thumb
 478              		.thumb_func
 480              	HandleError:
 481              	.LFB118:
 279:../Src/main.c ****     char msg[16];
 482              		.loc 1 279 0
 483              		.cfi_startproc
 484              		@ args = 0, pretend = 0, frame = 16
ARM GAS  /tmp/cceAljft.s 			page 27


 485              		@ frame_needed = 0, uses_anonymous_args = 0
 486              	.LVL20:
 487 0000 00B5     		push	{lr}
 488              	.LCFI14:
 489              		.cfi_def_cfa_offset 4
 490              		.cfi_offset 14, -4
 491 0002 85B0     		sub	sp, sp, #20
 492              	.LCFI15:
 493              		.cfi_def_cfa_offset 24
 494 0004 0246     		mov	r2, r0
 281:../Src/main.c ****     XNUCLEO53L0A1_SetDisplayString(msg);
 495              		.loc 1 281 0
 496 0006 6846     		mov	r0, sp
 497              	.LVL21:
 498 0008 0349     		ldr	r1, .L40
 499 000a FFF7FEFF 		bl	sprintf
 500              	.LVL22:
 282:../Src/main.c ****     while(1){};
 501              		.loc 1 282 0
 502 000e 6846     		mov	r0, sp
 503 0010 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 504              	.LVL23:
 505              	.L38:
 283:../Src/main.c **** }
 506              		.loc 1 283 0 discriminator 1
 507 0014 FEE7     		b	.L38
 508              	.L41:
 509 0016 00BF     		.align	2
 510              	.L40:
 511 0018 08000000 		.word	.LC1
 512              		.cfi_endproc
 513              	.LFE118:
 515              		.section	.text.DetectSensors,"ax",%progbits
 516              		.align	2
 517              		.global	DetectSensors
 518              		.thumb
 519              		.thumb_func
 521              	DetectSensors:
 522              	.LFB119:
 292:../Src/main.c ****     int i;
 523              		.loc 1 292 0
 524              		.cfi_startproc
 525              		@ args = 0, pretend = 0, frame = 8
 526              		@ frame_needed = 0, uses_anonymous_args = 0
 527              	.LVL24:
 528 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 529              	.LCFI16:
 530              		.cfi_def_cfa_offset 24
 531              		.cfi_offset 4, -24
 532              		.cfi_offset 5, -20
 533              		.cfi_offset 6, -16
 534              		.cfi_offset 7, -12
 535              		.cfi_offset 8, -8
 536              		.cfi_offset 14, -4
 537 0004 82B0     		sub	sp, sp, #8
 538              	.LCFI17:
 539              		.cfi_def_cfa_offset 32
ARM GAS  /tmp/cceAljft.s 			page 28


 540 0006 0746     		mov	r7, r0
 298:../Src/main.c ****     /* Reset all */
 541              		.loc 1 298 0
 542 0008 4E4B     		ldr	r3, .L57
 543 000a 93E80300 		ldmia	r3, {r0, r1}
 544              	.LVL25:
 545 000e 0090     		str	r0, [sp]
 546 0010 8DF80410 		strb	r1, [sp, #4]
 300:../Src/main.c ****     for (i = 0; i < 3; i++)
 547              		.loc 1 300 0
 548 0014 0024     		movs	r4, #0
 549 0016 4C4B     		ldr	r3, .L57+4
 550 0018 1C60     		str	r4, [r3]
 551              	.LVL26:
 301:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 552              		.loc 1 301 0
 553 001a 04E0     		b	.L43
 554              	.LVL27:
 555              	.L44:
 302:../Src/main.c **** 
 556              		.loc 1 302 0 discriminator 3
 557 001c 2046     		mov	r0, r4
 558 001e 0021     		movs	r1, #0
 559 0020 FFF7FEFF 		bl	XNUCLEO53L0A1_ResetId
 560              	.LVL28:
 301:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 561              		.loc 1 301 0 discriminator 3
 562 0024 0134     		adds	r4, r4, #1
 563              	.LVL29:
 564              	.L43:
 301:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 565              		.loc 1 301 0 is_stmt 0 discriminator 1
 566 0026 022C     		cmp	r4, #2
 567 0028 F8DD     		ble	.L44
 568 002a 0025     		movs	r5, #0
 569 002c 60E0     		b	.L45
 570              	.LVL30:
 571              	.L49:
 572              	.LBB2:
 307:../Src/main.c ****         pDev->I2cDevAddr = 0x52;
 573              		.loc 1 307 0 is_stmt 1
 574 002e 4FF4C874 		mov	r4, #400
 575 0032 464B     		ldr	r3, .L57+8
 576 0034 04FB0534 		mla	r4, r4, r5, r3
 577              	.LVL31:
 308:../Src/main.c ****         pDev->Present = 0;
 578              		.loc 1 308 0
 579 0038 5223     		movs	r3, #82
 580 003a 84F86031 		strb	r3, [r4, #352]
 309:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId( pDev->Id, 1);
 581              		.loc 1 309 0
 582 003e 0023     		movs	r3, #0
 583 0040 C4F86831 		str	r3, [r4, #360]
 310:../Src/main.c ****         HAL_Delay(2);
 584              		.loc 1 310 0
 585 0044 D4F86401 		ldr	r0, [r4, #356]
 586 0048 0121     		movs	r1, #1
ARM GAS  /tmp/cceAljft.s 			page 29


 587 004a FFF7FEFF 		bl	XNUCLEO53L0A1_ResetId
 588              	.LVL32:
 589 004e 0646     		mov	r6, r0
 590              	.LVL33:
 311:../Src/main.c ****         FinalAddress=0x52+(i+1)*2;
 591              		.loc 1 311 0
 592 0050 0220     		movs	r0, #2
 593              	.LVL34:
 594 0052 FFF7FEFF 		bl	HAL_Delay
 595              	.LVL35:
 312:../Src/main.c **** 
 596              		.loc 1 312 0
 597 0056 05F12A03 		add	r3, r5, #42
 598 005a 4FEA4308 		lsl	r8, r3, #1
 599              	.LVL36:
 316:../Src/main.c ****         		status = VL53L0X_WrByte(pDev, 0x88, 0x00);
 600              		.loc 1 316 0
 601 005e 26B9     		cbnz	r6, .L46
 317:../Src/main.c **** 
 602              		.loc 1 317 0
 603 0060 2046     		mov	r0, r4
 604 0062 8821     		movs	r1, #136
 605 0064 0022     		movs	r2, #0
 606 0066 FFF7FEFF 		bl	VL53L0X_WrByte
 607              	.LVL37:
 608              	.L46:
 320:../Src/main.c ****             if (status) {
 609              		.loc 1 320 0
 610 006a 2046     		mov	r0, r4
 611 006c C021     		movs	r1, #192
 612 006e 0DF10602 		add	r2, sp, #6
 613 0072 FFF7FEFF 		bl	VL53L0X_RdWord
 614              	.LVL38:
 615 0076 0346     		mov	r3, r0
 616              	.LVL39:
 321:../Src/main.c ****                 debug_printf("#%d Read id fail\n", i);
 617              		.loc 1 321 0
 618 0078 A0BB     		cbnz	r0, .L47
 325:../Src/main.c **** 				/* Sensor is found => Change its I2C address to final one */
 619              		.loc 1 325 0
 620 007a BDF80620 		ldrh	r2, [sp, #6]
 621 007e 4EF6AA63 		movw	r3, #61098
 622 0082 9A42     		cmp	r2, r3
 623 0084 2DD1     		bne	.L54
 327:../Src/main.c ****                 if (status != 0) {
 624              		.loc 1 327 0
 625 0086 5FFA88F8 		uxtb	r8, r8
 626              	.LVL40:
 627 008a 2046     		mov	r0, r4
 628              	.LVL41:
 629 008c 4146     		mov	r1, r8
 630 008e FFF7FEFF 		bl	VL53L0X_SetDeviceAddress
 631              	.LVL42:
 632 0092 0346     		mov	r3, r0
 633              	.LVL43:
 328:../Src/main.c ****                     debug_printf("#i VL53L0X_SetDeviceAddress fail\n", i);
 634              		.loc 1 328 0
ARM GAS  /tmp/cceAljft.s 			page 30


 635 0094 30BB     		cbnz	r0, .L47
 332:../Src/main.c ****                 /* Check all is OK with the new I2C address and initialize the sensor */
 636              		.loc 1 332 0
 637 0096 4FF4C873 		mov	r3, #400
 638 009a 2C4A     		ldr	r2, .L57+8
 639 009c 03FB0523 		mla	r3, r3, r5, r2
 640 00a0 83F86081 		strb	r8, [r3, #352]
 334:../Src/main.c ****                 if (status != 0) {
 641              		.loc 1 334 0
 642 00a4 2046     		mov	r0, r4
 643              	.LVL44:
 644 00a6 C021     		movs	r1, #192
 645 00a8 0DF10602 		add	r2, sp, #6
 646 00ac FFF7FEFF 		bl	VL53L0X_RdWord
 647              	.LVL45:
 648 00b0 0346     		mov	r3, r0
 649              	.LVL46:
 335:../Src/main.c **** 					debug_printf("#i VL53L0X_RdWord fail\n", i);
 650              		.loc 1 335 0
 651 00b2 B8B9     		cbnz	r0, .L47
 340:../Src/main.c ****                 if( status == 0 ){
 652              		.loc 1 340 0
 653 00b4 2046     		mov	r0, r4
 654              	.LVL47:
 655 00b6 FFF7FEFF 		bl	VL53L0X_DataInit
 656              	.LVL48:
 657 00ba 0346     		mov	r3, r0
 658              	.LVL49:
 341:../Src/main.c ****                     pDev->Present = 1;
 659              		.loc 1 341 0
 660 00bc 90B9     		cbnz	r0, .L47
 342:../Src/main.c ****                 }
 661              		.loc 1 342 0
 662 00be 4FF4C872 		mov	r2, #400
 663 00c2 2249     		ldr	r1, .L57+8
 664 00c4 02FB0511 		mla	r1, r2, r5, r1
 665 00c8 0122     		movs	r2, #1
 666 00ca C1F86821 		str	r2, [r1, #360]
 349:../Src/main.c ****                 nDevMask |= 1 << i;
 667              		.loc 1 349 0
 668 00ce 1E48     		ldr	r0, .L57+4
 669              	.LVL50:
 670 00d0 0168     		ldr	r1, [r0]
 671 00d2 1144     		add	r1, r1, r2
 672 00d4 0160     		str	r1, [r0]
 350:../Src/main.c ****                 pDev->Present = 1;
 673              		.loc 1 350 0
 674 00d6 AA40     		lsls	r2, r2, r5
 675 00d8 1D48     		ldr	r0, .L57+12
 676 00da 0168     		ldr	r1, [r0]
 677 00dc 0A43     		orrs	r2, r2, r1
 678 00de 0260     		str	r2, [r0]
 679 00e0 00E0     		b	.L47
 680              	.LVL51:
 681              	.L54:
 355:../Src/main.c ****             }
 682              		.loc 1 355 0
ARM GAS  /tmp/cceAljft.s 			page 31


 683 00e2 0123     		movs	r3, #1
 684              	.LVL52:
 685              	.L47:
 359:../Src/main.c ****             XNUCLEO53L0A1_ResetId(i, 0);
 686              		.loc 1 359 0
 687 00e4 1BB1     		cbz	r3, .L48
 360:../Src/main.c ****         }
 688              		.loc 1 360 0
 689 00e6 2846     		mov	r0, r5
 690 00e8 0021     		movs	r1, #0
 691 00ea FFF7FEFF 		bl	XNUCLEO53L0A1_ResetId
 692              	.LVL53:
 693              	.L48:
 694              	.LBE2:
 305:../Src/main.c ****         VL53L0X_Dev_t *pDev;
 695              		.loc 1 305 0 discriminator 2
 696 00ee 0135     		adds	r5, r5, #1
 697              	.LVL54:
 698              	.L45:
 305:../Src/main.c ****         VL53L0X_Dev_t *pDev;
 699              		.loc 1 305 0 is_stmt 0 discriminator 1
 700 00f0 022D     		cmp	r5, #2
 701 00f2 9CDD     		ble	.L49
 364:../Src/main.c ****         for(i=0; i<3; i++){
 702              		.loc 1 364 0 is_stmt 1
 703 00f4 A7B9     		cbnz	r7, .L55
 704 00f6 20E0     		b	.L51
 705              	.LVL55:
 706              	.L53:
 366:../Src/main.c ****                 PresentMsg[i+1]=VL53L0XDevs[i].DevLetter;
 707              		.loc 1 366 0
 708 00f8 4FF4C872 		mov	r2, #400
 709 00fc 1349     		ldr	r1, .L57+8
 710 00fe 02FB0312 		mla	r2, r2, r3, r1
 711 0102 D2F86821 		ldr	r2, [r2, #360]
 712 0106 4AB1     		cbz	r2, .L52
 367:../Src/main.c ****             }
 713              		.loc 1 367 0
 714 0108 4FF4C872 		mov	r2, #400
 715 010c 02FB0312 		mla	r2, r2, r3, r1
 716 0110 92F86111 		ldrb	r1, [r2, #353]	@ zero_extendqisi2
 717 0114 02AA     		add	r2, sp, #8
 718 0116 1A44     		add	r2, r2, r3
 719 0118 02F8071C 		strb	r1, [r2, #-7]
 720              	.L52:
 365:../Src/main.c ****             if( VL53L0XDevs[i].Present ){
 721              		.loc 1 365 0 discriminator 2
 722 011c 0133     		adds	r3, r3, #1
 723              	.LVL56:
 724 011e 00E0     		b	.L50
 725              	.LVL57:
 726              	.L55:
 727 0120 0023     		movs	r3, #0
 728              	.LVL58:
 729              	.L50:
 365:../Src/main.c ****             if( VL53L0XDevs[i].Present ){
 730              		.loc 1 365 0 is_stmt 0 discriminator 1
ARM GAS  /tmp/cceAljft.s 			page 32


 731 0122 022B     		cmp	r3, #2
 732 0124 E8DD     		ble	.L53
 370:../Src/main.c ****         XNUCLEO53L0A1_SetDisplayString(PresentMsg);
 733              		.loc 1 370 0 is_stmt 1
 734 0126 02A8     		add	r0, sp, #8
 735 0128 2023     		movs	r3, #32
 736              	.LVL59:
 737 012a 00F8083D 		strb	r3, [r0, #-8]!
 371:../Src/main.c ****         HAL_Delay(1000);
 738              		.loc 1 371 0
 739 012e FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 740              	.LVL60:
 372:../Src/main.c ****     }
 741              		.loc 1 372 0
 742 0132 4FF47A70 		mov	r0, #1000
 743 0136 FFF7FEFF 		bl	HAL_Delay
 744              	.LVL61:
 745              	.L51:
 376:../Src/main.c **** 
 746              		.loc 1 376 0
 747 013a 034B     		ldr	r3, .L57+4
 748 013c 1868     		ldr	r0, [r3]
 749 013e 02B0     		add	sp, sp, #8
 750              	.LCFI18:
 751              		.cfi_def_cfa_offset 24
 752              		@ sp needed
 753 0140 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 754              	.LVL62:
 755              	.L58:
 756              		.align	2
 757              	.L57:
 758 0144 10000000 		.word	.LC2
 759 0148 00000000 		.word	.LANCHOR0
 760 014c 00000000 		.word	.LANCHOR1
 761 0150 00000000 		.word	nDevMask
 762              		.cfi_endproc
 763              	.LFE119:
 765              		.section	.text.SetupSingleShot,"ax",%progbits
 766              		.align	2
 767              		.global	SetupSingleShot
 768              		.thumb
 769              		.thumb_func
 771              	SetupSingleShot:
 772              	.LFB120:
 381:../Src/main.c ****     int i;
 773              		.loc 1 381 0
 774              		.cfi_startproc
 775              		@ args = 0, pretend = 0, frame = 16
 776              		@ frame_needed = 0, uses_anonymous_args = 0
 777              	.LVL63:
 778 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 779              	.LCFI19:
 780              		.cfi_def_cfa_offset 36
 781              		.cfi_offset 4, -36
 782              		.cfi_offset 5, -32
 783              		.cfi_offset 6, -28
 784              		.cfi_offset 7, -24
ARM GAS  /tmp/cceAljft.s 			page 33


 785              		.cfi_offset 8, -20
 786              		.cfi_offset 9, -16
 787              		.cfi_offset 10, -12
 788              		.cfi_offset 11, -8
 789              		.cfi_offset 14, -4
 790 0004 85B0     		sub	sp, sp, #20
 791              	.LCFI20:
 792              		.cfi_def_cfa_offset 56
 793 0006 0646     		mov	r6, r0
 794              	.LVL64:
 392:../Src/main.c **** 
 795              		.loc 1 392 0
 796 0008 4FF00A0B 		mov	fp, #10
 391:../Src/main.c **** 	uint8_t finalRangeVcselPeriod = 10;
 797              		.loc 1 391 0
 798 000c 4FF00E0A 		mov	r10, #14
 390:../Src/main.c **** 	uint8_t preRangeVcselPeriod = 14;
 799              		.loc 1 390 0
 800 0010 48F2E809 		movw	r9, #33000
 389:../Src/main.c **** 	uint32_t timingBudget = 33000;
 801              		.loc 1 389 0
 802 0014 4FF49018 		mov	r8, #1179648
 388:../Src/main.c **** 	FixPoint1616_t sigmaLimit = (FixPoint1616_t)(18*65536);
 803              		.loc 1 388 0
 804 0018 4FF48047 		mov	r7, #16384
 394:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 805              		.loc 1 394 0
 806 001c 0024     		movs	r4, #0
 807 001e 77E0     		b	.L60
 808              	.LVL65:
 809              	.L66:
 395:../Src/main.c ****             status=VL53L0X_StaticInit(&VL53L0XDevs[i]);
 810              		.loc 1 395 0
 811 0020 4FF4C873 		mov	r3, #400
 812 0024 3D4A     		ldr	r2, .L69
 813 0026 03FB0423 		mla	r3, r3, r4, r2
 814 002a D3F86831 		ldr	r3, [r3, #360]
 815 002e 002B     		cmp	r3, #0
 816 0030 6DD0     		beq	.L61
 396:../Src/main.c ****             if( status ){
 817              		.loc 1 396 0
 818 0032 4FF4C873 		mov	r3, #400
 819 0036 03FB0425 		mla	r5, r3, r4, r2
 820 003a 2846     		mov	r0, r5
 821 003c FFF7FEFF 		bl	VL53L0X_StaticInit
 822              	.LVL66:
 401:../Src/main.c **** 			if( status ){
 823              		.loc 1 401 0
 824 0040 2846     		mov	r0, r5
 825 0042 0DF10F01 		add	r1, sp, #15
 826 0046 0DF10E02 		add	r2, sp, #14
 827 004a FFF7FEFF 		bl	VL53L0X_PerformRefCalibration
 828              	.LVL67:
 406:../Src/main.c **** 			if( status ){
 829              		.loc 1 406 0
 830 004e 2846     		mov	r0, r5
 831 0050 02A9     		add	r1, sp, #8
ARM GAS  /tmp/cceAljft.s 			page 34


 832 0052 0DF10702 		add	r2, sp, #7
 833 0056 FFF7FEFF 		bl	VL53L0X_PerformRefSpadManagement
 834              	.LVL68:
 411:../Src/main.c ****             if( status ){
 835              		.loc 1 411 0
 836 005a 2846     		mov	r0, r5
 837 005c 0021     		movs	r1, #0
 838 005e FFF7FEFF 		bl	VL53L0X_SetDeviceMode
 839              	.LVL69:
 416:../Src/main.c **** 			if( status ){
 840              		.loc 1 416 0
 841 0062 2846     		mov	r0, r5
 842 0064 0021     		movs	r1, #0
 843 0066 0122     		movs	r2, #1
 844 0068 FFF7FEFF 		bl	VL53L0X_SetLimitCheckEnable
 845              	.LVL70:
 421:../Src/main.c **** 			if( status ){
 846              		.loc 1 421 0
 847 006c 2846     		mov	r0, r5
 848 006e 0121     		movs	r1, #1
 849 0070 0A46     		mov	r2, r1
 850 0072 FFF7FEFF 		bl	VL53L0X_SetLimitCheckEnable
 851              	.LVL71:
 426:../Src/main.c ****             case LONG_RANGE:
 852              		.loc 1 426 0
 853 0076 012E     		cmp	r6, #1
 854 0078 0DD0     		beq	.L63
 855 007a BEB1     		cbz	r6, .L67
 856 007c 022E     		cmp	r6, #2
 857 007e 1FD1     		bne	.L64
 858              	.LVL72:
 439:../Src/main.c **** 				break;
 859              		.loc 1 439 0
 860 0080 4FF00A0B 		mov	fp, #10
 438:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 861              		.loc 1 438 0
 862 0084 4FF00E0A 		mov	r10, #14
 437:../Src/main.c **** 				preRangeVcselPeriod = 14; //laser pulse periods
 863              		.loc 1 437 0
 864 0088 DFF89490 		ldr	r9, .L69+4
 436:../Src/main.c **** 				timingBudget = 200000; //200ms
 865              		.loc 1 436 0
 866 008c 4FF49018 		mov	r8, #1179648
 435:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(18*65536);
 867              		.loc 1 435 0
 868 0090 4FF48047 		mov	r7, #16384
 440:../Src/main.c ****             case HIGH_SPEED:
 869              		.loc 1 440 0
 870 0094 14E0     		b	.L64
 871              	.LVL73:
 872              	.L63:
 446:../Src/main.c **** 				break;
 873              		.loc 1 446 0
 874 0096 4FF00A0B 		mov	fp, #10
 445:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 875              		.loc 1 445 0
 876 009a 4FF00E0A 		mov	r10, #14
ARM GAS  /tmp/cceAljft.s 			page 35


 444:../Src/main.c **** 				preRangeVcselPeriod = 14;
 877              		.loc 1 444 0
 878 009e 44F62069 		movw	r9, #20000
 443:../Src/main.c **** 				timingBudget = 20000; //20ms
 879              		.loc 1 443 0
 880 00a2 4FF40018 		mov	r8, #2097152
 442:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(32*65536);
 881              		.loc 1 442 0
 882 00a6 4FF48047 		mov	r7, #16384
 447:../Src/main.c ****             default:
 883              		.loc 1 447 0
 884 00aa 09E0     		b	.L64
 885              	.LVL74:
 886              	.L67:
 432:../Src/main.c ****             	break;
 887              		.loc 1 432 0
 888 00ac 4FF00E0B 		mov	fp, #14
 889              	.LVL75:
 431:../Src/main.c ****             	finalRangeVcselPeriod = 14;
 890              		.loc 1 431 0
 891 00b0 4FF0120A 		mov	r10, #18
 892              	.LVL76:
 430:../Src/main.c ****             	preRangeVcselPeriod = 18;
 893              		.loc 1 430 0
 894 00b4 48F2E809 		movw	r9, #33000
 895              	.LVL77:
 429:../Src/main.c ****             	timingBudget = 33000; //33ms
 896              		.loc 1 429 0
 897 00b8 4FF47018 		mov	r8, #3932160
 898              	.LVL78:
 428:../Src/main.c ****             	sigmaLimit = (FixPoint1616_t)(60*65536);
 899              		.loc 1 428 0
 900 00bc 41F69917 		movw	r7, #6553
 901              	.LVL79:
 902              	.L64:
 452:../Src/main.c **** 			if( status ){
 903              		.loc 1 452 0
 904 00c0 2846     		mov	r0, r5
 905 00c2 0121     		movs	r1, #1
 906 00c4 3A46     		mov	r2, r7
 907 00c6 FFF7FEFF 		bl	VL53L0X_SetLimitCheckValue
 908              	.LVL80:
 457:../Src/main.c **** 			if( status ){
 909              		.loc 1 457 0
 910 00ca 2846     		mov	r0, r5
 911 00cc 0021     		movs	r1, #0
 912 00ce 4246     		mov	r2, r8
 913 00d0 FFF7FEFF 		bl	VL53L0X_SetLimitCheckValue
 914              	.LVL81:
 462:../Src/main.c ****             if( status ){
 915              		.loc 1 462 0
 916 00d4 2846     		mov	r0, r5
 917 00d6 4946     		mov	r1, r9
 918 00d8 FFF7FEFF 		bl	VL53L0X_SetMeasurementTimingBudgetMicroSeconds
 919              	.LVL82:
 467:../Src/main.c **** 			if( status ){
 920              		.loc 1 467 0
ARM GAS  /tmp/cceAljft.s 			page 36


 921 00dc 2846     		mov	r0, r5
 922 00de 0021     		movs	r1, #0
 923 00e0 5246     		mov	r2, r10
 924 00e2 FFF7FEFF 		bl	VL53L0X_SetVcselPulsePeriod
 925              	.LVL83:
 472:../Src/main.c **** 			if( status ){
 926              		.loc 1 472 0
 927 00e6 2846     		mov	r0, r5
 928 00e8 0121     		movs	r1, #1
 929 00ea 5A46     		mov	r2, fp
 930 00ec FFF7FEFF 		bl	VL53L0X_SetVcselPulsePeriod
 931              	.LVL84:
 477:../Src/main.c **** 			if( status ){
 932              		.loc 1 477 0
 933 00f0 2846     		mov	r0, r5
 934 00f2 0DF10F01 		add	r1, sp, #15
 935 00f6 0DF10E02 		add	r2, sp, #14
 936 00fa FFF7FEFF 		bl	VL53L0X_PerformRefCalibration
 937              	.LVL85:
 482:../Src/main.c ****         }
 938              		.loc 1 482 0
 939 00fe 4FF4C873 		mov	r3, #400
 940 0102 064A     		ldr	r2, .L69
 941 0104 03FB0423 		mla	r3, r3, r4, r2
 942 0108 0122     		movs	r2, #1
 943 010a C3F87C21 		str	r2, [r3, #380]
 944              	.L61:
 394:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 945              		.loc 1 394 0 discriminator 2
 946 010e 0134     		adds	r4, r4, #1
 947              	.LVL86:
 948              	.L60:
 394:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 949              		.loc 1 394 0 is_stmt 0 discriminator 1
 950 0110 022C     		cmp	r4, #2
 951 0112 85DD     		ble	.L66
 485:../Src/main.c **** 
 952              		.loc 1 485 0 is_stmt 1
 953 0114 05B0     		add	sp, sp, #20
 954              	.LCFI21:
 955              		.cfi_def_cfa_offset 36
 956              		@ sp needed
 957 0116 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 958              	.LVL87:
 959              	.L70:
 960 011a 00BF     		.align	2
 961              	.L69:
 962 011c 00000000 		.word	.LANCHOR1
 963 0120 400D0300 		.word	200000
 964              		.cfi_endproc
 965              	.LFE120:
 967              		.section	.text.RangeToLetter,"ax",%progbits
 968              		.align	2
 969              		.global	RangeToLetter
 970              		.thumb
 971              		.thumb_func
 973              	RangeToLetter:
ARM GAS  /tmp/cceAljft.s 			page 37


 974              	.LFB121:
 487:../Src/main.c ****     char c;
 975              		.loc 1 487 0
 976              		.cfi_startproc
 977              		@ args = 0, pretend = 0, frame = 0
 978              		@ frame_needed = 0, uses_anonymous_args = 0
 979              		@ link register save eliminated.
 980              	.LVL88:
 489:../Src/main.c ****         if( pDev->LeakyRange < RangeLow ){
 981              		.loc 1 489 0
 982 0000 0B7E     		ldrb	r3, [r1, #24]	@ zero_extendqisi2
 983 0002 5BB9     		cbnz	r3, .L73
 490:../Src/main.c ****             c='_';
 984              		.loc 1 490 0
 985 0004 D0F87831 		ldr	r3, [r0, #376]
 986 0008 074A     		ldr	r2, .L76
 987 000a 1268     		ldr	r2, [r2]
 988 000c 9342     		cmp	r3, r2
 989 000e 07DB     		blt	.L74
 493:../Src/main.c ****                 c='=';
 990              		.loc 1 493 0
 991 0010 064A     		ldr	r2, .L76+4
 992 0012 1268     		ldr	r2, [r2]
 993 0014 9342     		cmp	r3, r2
 994 0016 05DA     		bge	.L75
 494:../Src/main.c ****         }
 995              		.loc 1 494 0
 996 0018 3D20     		movs	r0, #61
 997              	.LVL89:
 998 001a 7047     		bx	lr
 999              	.LVL90:
 1000              	.L73:
 502:../Src/main.c ****     }
 1001              		.loc 1 502 0
 1002 001c 2D20     		movs	r0, #45
 1003              	.LVL91:
 1004 001e 7047     		bx	lr
 1005              	.LVL92:
 1006              	.L74:
 491:../Src/main.c ****         }
 1007              		.loc 1 491 0
 1008 0020 5F20     		movs	r0, #95
 1009              	.LVL93:
 1010 0022 7047     		bx	lr
 1011              	.LVL94:
 1012              	.L75:
 497:../Src/main.c ****         }
 1013              		.loc 1 497 0
 1014 0024 7E20     		movs	r0, #126
 1015              	.LVL95:
 505:../Src/main.c **** 
 1016              		.loc 1 505 0
 1017 0026 7047     		bx	lr
 1018              	.L77:
 1019              		.align	2
 1020              	.L76:
 1021 0028 00000000 		.word	.LANCHOR2
ARM GAS  /tmp/cceAljft.s 			page 38


 1022 002c 00000000 		.word	.LANCHOR3
 1023              		.cfi_endproc
 1024              	.LFE121:
 1026              		.section	.text.Sensor_SetNewRange,"ax",%progbits
 1027              		.align	2
 1028              		.global	Sensor_SetNewRange
 1029              		.thumb
 1030              		.thumb_func
 1032              	Sensor_SetNewRange:
 1033              	.LFB122:
 508:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 1034              		.loc 1 508 0
 1035              		.cfi_startproc
 1036              		@ args = 0, pretend = 0, frame = 0
 1037              		@ frame_needed = 0, uses_anonymous_args = 0
 1038              		@ link register save eliminated.
 1039              	.LVL96:
 509:../Src/main.c ****         if( pDev->LeakyFirst ){
 1040              		.loc 1 509 0
 1041 0000 0B7E     		ldrb	r3, [r1, #24]	@ zero_extendqisi2
 1042 0002 CBB9     		cbnz	r3, .L79
 510:../Src/main.c ****             pDev->LeakyFirst = 0;
 1043              		.loc 1 510 0
 1044 0004 D0F87C31 		ldr	r3, [r0, #380]
 1045 0008 33B1     		cbz	r3, .L80
 511:../Src/main.c ****             pDev->LeakyRange = pRange->RangeMilliMeter;
 1046              		.loc 1 511 0
 1047 000a 0023     		movs	r3, #0
 1048 000c C0F87C31 		str	r3, [r0, #380]
 512:../Src/main.c ****         }
 1049              		.loc 1 512 0
 1050 0010 0B89     		ldrh	r3, [r1, #8]
 1051 0012 C0F87831 		str	r3, [r0, #376]
 1052 0016 7047     		bx	lr
 1053              	.L80:
 508:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 1054              		.loc 1 508 0
 1055 0018 30B4     		push	{r4, r5}
 1056              	.LCFI22:
 1057              		.cfi_def_cfa_offset 8
 1058              		.cfi_offset 4, -8
 1059              		.cfi_offset 5, -4
 515:../Src/main.c ****         }
 1060              		.loc 1 515 0
 1061 001a D0F87831 		ldr	r3, [r0, #376]
 1062 001e 094A     		ldr	r2, .L84
 1063 0020 1468     		ldr	r4, [r2]
 1064 0022 C4F58075 		rsb	r5, r4, #256
 1065 0026 0A89     		ldrh	r2, [r1, #8]
 1066 0028 02FB05F2 		mul	r2, r2, r5
 1067 002c 04FB0323 		mla	r3, r4, r3, r2
 1068 0030 1B12     		asrs	r3, r3, #8
 1069 0032 C0F87831 		str	r3, [r0, #376]
 1070 0036 03E0     		b	.L78
 1071              	.L79:
 1072              	.LCFI23:
 1073              		.cfi_def_cfa_offset 0
ARM GAS  /tmp/cceAljft.s 			page 39


 1074              		.cfi_restore 4
 1075              		.cfi_restore 5
 519:../Src/main.c ****     }
 1076              		.loc 1 519 0
 1077 0038 0123     		movs	r3, #1
 1078 003a C0F87C31 		str	r3, [r0, #380]
 1079 003e 7047     		bx	lr
 1080              	.L78:
 1081              	.LCFI24:
 1082              		.cfi_def_cfa_offset 8
 1083              		.cfi_offset 4, -8
 1084              		.cfi_offset 5, -4
 521:../Src/main.c **** 
 1085              		.loc 1 521 0
 1086 0040 30BC     		pop	{r4, r5}
 1087              	.LCFI25:
 1088              		.cfi_restore 5
 1089              		.cfi_restore 4
 1090              		.cfi_def_cfa_offset 0
 1091 0042 7047     		bx	lr
 1092              	.L85:
 1093              		.align	2
 1094              	.L84:
 1095 0044 00000000 		.word	.LANCHOR4
 1096              		.cfi_endproc
 1097              	.LFE122:
 1099              		.section	.text.blink_led,"ax",%progbits
 1100              		.align	2
 1101              		.global	blink_led
 1102              		.thumb
 1103              		.thumb_func
 1105              	blink_led:
 1106              	.LFB123:
 523:../Src/main.c ****     if (*compteur == 6){                       /////modification toutes les 6 mesures correctes du 
 1107              		.loc 1 523 0
 1108              		.cfi_startproc
 1109              		@ args = 0, pretend = 0, frame = 0
 1110              		@ frame_needed = 0, uses_anonymous_args = 0
 1111              	.LVL97:
 524:../Src/main.c ****         HAL_TIM_Base_Stop_IT(&htim3);
 1112              		.loc 1 524 0
 1113 0000 0B68     		ldr	r3, [r1]
 1114 0002 062B     		cmp	r3, #6
 1115 0004 12D1     		bne	.L89
 523:../Src/main.c ****     if (*compteur == 6){                       /////modification toutes les 6 mesures correctes du 
 1116              		.loc 1 523 0
 1117 0006 70B5     		push	{r4, r5, r6, lr}
 1118              	.LCFI26:
 1119              		.cfi_def_cfa_offset 16
 1120              		.cfi_offset 4, -16
 1121              		.cfi_offset 5, -12
 1122              		.cfi_offset 6, -8
 1123              		.cfi_offset 14, -4
 1124 0008 0D46     		mov	r5, r1
 1125 000a 0446     		mov	r4, r0
 525:../Src/main.c ****         htim3.Instance->ARR = 2*valeur-1+20;   /////modification de la période du capteur (voir wi
 1126              		.loc 1 525 0
ARM GAS  /tmp/cceAljft.s 			page 40


 1127 000c 084E     		ldr	r6, .L90
 1128 000e 3046     		mov	r0, r6
 1129              	.LVL98:
 1130 0010 FFF7FEFF 		bl	HAL_TIM_Base_Stop_IT
 1131              	.LVL99:
 526:../Src/main.c ****         HAL_TIM_Base_Start_IT(&htim3);  
 1132              		.loc 1 526 0
 1133 0014 3368     		ldr	r3, [r6]
 1134 0016 6000     		lsls	r0, r4, #1
 1135 0018 1330     		adds	r0, r0, #19
 1136 001a D862     		str	r0, [r3, #44]
 527:../Src/main.c ****         htim3.Instance->CNT = 0;               /////remise a zero du timer de la led
 1137              		.loc 1 527 0
 1138 001c 3046     		mov	r0, r6
 1139 001e FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1140              	.LVL100:
 528:../Src/main.c ****         *compteur = 0;                         /////remise a zero du compteur
 1141              		.loc 1 528 0
 1142 0022 3268     		ldr	r2, [r6]
 1143 0024 0023     		movs	r3, #0
 1144 0026 5362     		str	r3, [r2, #36]
 529:../Src/main.c ****     }
 1145              		.loc 1 529 0
 1146 0028 2B60     		str	r3, [r5]
 1147 002a 70BD     		pop	{r4, r5, r6, pc}
 1148              	.LVL101:
 1149              	.L89:
 1150              	.LCFI27:
 1151              		.cfi_def_cfa_offset 0
 1152              		.cfi_restore 4
 1153              		.cfi_restore 5
 1154              		.cfi_restore 6
 1155              		.cfi_restore 14
 1156 002c 7047     		bx	lr
 1157              	.L91:
 1158 002e 00BF     		.align	2
 1159              	.L90:
 1160 0030 00000000 		.word	htim3
 1161              		.cfi_endproc
 1162              	.LFE123:
 1164              		.section	.text.RangeDemo,"ax",%progbits
 1165              		.align	2
 1166              		.global	RangeDemo
 1167              		.thumb
 1168              		.thumb_func
 1170              	RangeDemo:
 1171              	.LFB124:
 540:../Src/main.c ****     int over=0;
 1172              		.loc 1 540 0
 1173              		.cfi_startproc
 1174              		@ args = 0, pretend = 0, frame = 16
 1175              		@ frame_needed = 0, uses_anonymous_args = 0
 1176              	.LVL102:
 1177 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 1178              	.LCFI28:
 1179              		.cfi_def_cfa_offset 28
 1180              		.cfi_offset 4, -28
ARM GAS  /tmp/cceAljft.s 			page 41


 1181              		.cfi_offset 5, -24
 1182              		.cfi_offset 6, -20
 1183              		.cfi_offset 7, -16
 1184              		.cfi_offset 8, -12
 1185              		.cfi_offset 9, -8
 1186              		.cfi_offset 14, -4
 1187 0004 85B0     		sub	sp, sp, #20
 1188              	.LCFI29:
 1189              		.cfi_def_cfa_offset 48
 1190 0006 0546     		mov	r5, r0
 1191              	.LVL103:
 549:../Src/main.c ****     int* compteur = NULL;   ///creation pointeur sur compteur
 1192              		.loc 1 549 0
 1193 0008 0024     		movs	r4, #0
 1194 000a 0194     		str	r4, [sp, #4]
 1195              	.LVL104:
 554:../Src/main.c **** 
 1196              		.loc 1 554 0
 1197 000c 0846     		mov	r0, r1
 1198              	.LVL105:
 1199 000e FFF7FEFF 		bl	SetupSingleShot
 1200              	.LVL106:
 547:../Src/main.c ****     int valeur;
 1201              		.loc 1 547 0
 1202 0012 2746     		mov	r7, r4
 557:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 1203              		.loc 1 557 0
 1204 0014 2646     		mov	r6, r4
 1205 0016 2346     		mov	r3, r4
 1206 0018 11E0     		b	.L93
 1207              	.LVL107:
 1208              	.L95:
 558:../Src/main.c ****             nSensorToUse++;
 1209              		.loc 1 558 0
 1210 001a 45FA03F2 		asr	r2, r5, r3
 1211 001e 12F0010F 		tst	r2, #1
 1212 0022 0BD0     		beq	.L94
 558:../Src/main.c ****             nSensorToUse++;
 1213              		.loc 1 558 0 is_stmt 0 discriminator 1
 1214 0024 4FF4C872 		mov	r2, #400
 1215 0028 4C49     		ldr	r1, .L109
 1216 002a 02FB0312 		mla	r2, r2, r3, r1
 1217 002e D2F86821 		ldr	r2, [r2, #360]
 1218 0032 1AB1     		cbz	r2, .L94
 559:../Src/main.c ****             if( nSensorToUse==1 )
 1219              		.loc 1 559 0 is_stmt 1
 1220 0034 0136     		adds	r6, r6, #1
 1221              	.LVL108:
 560:../Src/main.c ****                 SingleSensorNo=i;
 1222              		.loc 1 560 0
 1223 0036 012E     		cmp	r6, #1
 1224 0038 00D1     		bne	.L94
 561:../Src/main.c ****         }
 1225              		.loc 1 561 0
 1226 003a 1F46     		mov	r7, r3
 1227              	.LVL109:
 1228              	.L94:
ARM GAS  /tmp/cceAljft.s 			page 42


 557:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 1229              		.loc 1 557 0 discriminator 2
 1230 003c 0133     		adds	r3, r3, #1
 1231              	.LVL110:
 1232              	.L93:
 557:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 1233              		.loc 1 557 0 is_stmt 0 discriminator 1
 1234 003e 022B     		cmp	r3, #2
 1235 0040 EBDD     		ble	.L95
 564:../Src/main.c ****         return -1;
 1236              		.loc 1 564 0 is_stmt 1
 1237 0042 002E     		cmp	r6, #0
 1238 0044 00F08480 		beq	.L107
 1239              	.LVL111:
 1240              	.L105:
 570:../Src/main.c ****         	/* Multiple devices */
 1241              		.loc 1 570 0
 1242 0048 012E     		cmp	r6, #1
 1243 004a 32DD     		ble	.L97
 572:../Src/main.c ****             for( i=0; i<3; i++){
 1244              		.loc 1 572 0
 1245 004c 444B     		ldr	r3, .L109+4
 1246 004e 93E80300 		ldmia	r3, {r0, r1}
 1247 0052 0290     		str	r0, [sp, #8]
 1248 0054 8DF80C10 		strb	r1, [sp, #12]
 1249              	.LVL112:
 573:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 1250              		.loc 1 573 0
 1251 0058 0024     		movs	r4, #0
 1252 005a 27E0     		b	.L98
 1253              	.LVL113:
 1254              	.L101:
 574:../Src/main.c ****                     continue;
 1255              		.loc 1 574 0
 1256 005c 4FF4C873 		mov	r3, #400
 1257 0060 3E4A     		ldr	r2, .L109
 1258 0062 03FB0423 		mla	r3, r3, r4, r2
 1259 0066 D3F86831 		ldr	r3, [r3, #360]
 1260 006a F3B1     		cbz	r3, .L99
 574:../Src/main.c ****                     continue;
 1261              		.loc 1 574 0 is_stmt 0 discriminator 1
 1262 006c 45FA04F3 		asr	r3, r5, r4
 1263 0070 13F0010F 		tst	r3, #1
 1264 0074 19D0     		beq	.L99
 577:../Src/main.c ****                 if( status ){
 1265              		.loc 1 577 0 is_stmt 1
 1266 0076 4FF4C873 		mov	r3, #400
 1267 007a 03FB0428 		mla	r8, r3, r4, r2
 1268 007e 4046     		mov	r0, r8
 1269 0080 3849     		ldr	r1, .L109+8
 1270 0082 FFF7FEFF 		bl	VL53L0X_PerformSingleRangingMeasurement
 1271              	.LVL114:
 578:../Src/main.c ****                     HandleError(ERR_DEMO_RANGE_MULTI);
 1272              		.loc 1 578 0
 1273 0086 10B1     		cbz	r0, .L100
 579:../Src/main.c ****                 }
 1274              		.loc 1 579 0
ARM GAS  /tmp/cceAljft.s 			page 43


 1275 0088 0220     		movs	r0, #2
 1276              	.LVL115:
 1277 008a FFF7FEFF 		bl	HandleError
 1278              	.LVL116:
 1279              	.L100:
 584:../Src/main.c ****                 /* Translate distance in bar graph (multiple device) */
 1280              		.loc 1 584 0
 1281 008e DFF8D490 		ldr	r9, .L109+8
 1282 0092 4046     		mov	r0, r8
 1283              	.LVL117:
 1284 0094 4946     		mov	r1, r9
 1285 0096 FFF7FEFF 		bl	Sensor_SetNewRange
 1286              	.LVL118:
 586:../Src/main.c ****                 StrDisplay[i+1]=c;
 1287              		.loc 1 586 0
 1288 009a 4046     		mov	r0, r8
 1289 009c 4946     		mov	r1, r9
 1290 009e FFF7FEFF 		bl	RangeToLetter
 1291              	.LVL119:
 587:../Src/main.c ****             }
 1292              		.loc 1 587 0
 1293 00a2 04AB     		add	r3, sp, #16
 1294 00a4 2344     		add	r3, r3, r4
 1295 00a6 03F8070C 		strb	r0, [r3, #-7]
 1296              	.LVL120:
 1297              	.L99:
 573:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 1298              		.loc 1 573 0 discriminator 2
 1299 00aa 0134     		adds	r4, r4, #1
 1300              	.LVL121:
 1301              	.L98:
 573:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 1302              		.loc 1 573 0 is_stmt 0 discriminator 1
 1303 00ac 022C     		cmp	r4, #2
 1304 00ae D5DD     		ble	.L101
 1305 00b0 40E0     		b	.L102
 1306              	.LVL122:
 1307              	.L97:
 593:../Src/main.c ****             if( status ==0 ){
 1308              		.loc 1 593 0 is_stmt 1
 1309 00b2 4FF4C873 		mov	r3, #400
 1310 00b6 294C     		ldr	r4, .L109
 1311 00b8 03FB0744 		mla	r4, r3, r7, r4
 1312 00bc 2046     		mov	r0, r4
 1313 00be 2949     		ldr	r1, .L109+8
 1314 00c0 FFF7FEFF 		bl	VL53L0X_PerformSingleRangingMeasurement
 1315              	.LVL123:
 594:../Src/main.c ****             	/* Push data logging to UART */
 1316              		.loc 1 594 0
 1317 00c4 98BB     		cbnz	r0, .L103
 597:../Src/main.c ****                 /* Display distance in cm */
 1318              		.loc 1 597 0
 1319 00c6 DFF89C80 		ldr	r8, .L109+8
 1320 00ca 2046     		mov	r0, r4
 1321              	.LVL124:
 1322 00cc 4146     		mov	r1, r8
 1323 00ce FFF7FEFF 		bl	Sensor_SetNewRange
ARM GAS  /tmp/cceAljft.s 			page 44


 1324              	.LVL125:
 599:../Src/main.c ****                     *compteur+=1;                               /////incrementation du compteur
 1325              		.loc 1 599 0
 1326 00d2 98F81830 		ldrb	r3, [r8, #24]	@ zero_extendqisi2
 1327 00d6 D3B9     		cbnz	r3, .L104
 600:../Src/main.c ****                     sprintf(StrDisplay, "%3dc",(int)VL53L0XDevs[SingleSensorNo].LeakyRange/10);  //
 1328              		.loc 1 600 0
 1329 00d8 019B     		ldr	r3, [sp, #4]
 1330 00da 0133     		adds	r3, r3, #1
 1331 00dc 0193     		str	r3, [sp, #4]
 601:../Src/main.c ****                     valeur=(int)VL53L0XDevs[SingleSensorNo].LeakyRange/10;   /////valeur lue par le
 1332              		.loc 1 601 0
 1333 00de A046     		mov	r8, r4
 1334 00e0 D4F87831 		ldr	r3, [r4, #376]
 1335 00e4 204C     		ldr	r4, .L109+12
 1336 00e6 84FB0312 		smull	r1, r2, r4, r3
 1337 00ea DB17     		asrs	r3, r3, #31
 1338 00ec 02A8     		add	r0, sp, #8
 1339 00ee 1F49     		ldr	r1, .L109+16
 1340 00f0 C3EBA202 		rsb	r2, r3, r2, asr #2
 1341 00f4 FFF7FEFF 		bl	sprintf
 1342              	.LVL126:
 602:../Src/main.c ****                     blink_led(valeur,compteur);                 /////fonction blink_led
 1343              		.loc 1 602 0
 1344 00f8 D8F87831 		ldr	r3, [r8, #376]
 1345 00fc 84FB0320 		smull	r2, r0, r4, r3
 1346 0100 DB17     		asrs	r3, r3, #31
 1347              	.LVL127:
 603:../Src/main.c ****                 }
 1348              		.loc 1 603 0
 1349 0102 C3EBA000 		rsb	r0, r3, r0, asr #2
 1350              	.LVL128:
 1351 0106 01A9     		add	r1, sp, #4
 1352              	.LVL129:
 1353 0108 FFF7FEFF 		bl	blink_led
 1354              	.LVL130:
 1355 010c 12E0     		b	.L102
 1356              	.L104:
 606:../Src/main.c ****                     StrDisplay[0]=VL53L0XDevs[SingleSensorNo].DevLetter;
 1357              		.loc 1 606 0
 1358 010e 184B     		ldr	r3, .L109+20
 1359 0110 93E80300 		ldmia	r3, {r0, r1}
 1360 0114 0290     		str	r0, [sp, #8]
 1361 0116 8DF80C10 		strb	r1, [sp, #12]
 607:../Src/main.c ****                     //HAL_TIM_Base_Stop_IT(&htim3);
 1362              		.loc 1 607 0
 1363 011a 4FF4C873 		mov	r3, #400
 1364 011e 0F4A     		ldr	r2, .L109
 1365 0120 03FB0723 		mla	r3, r3, r7, r2
 1366 0124 93F86131 		ldrb	r3, [r3, #353]	@ zero_extendqisi2
 1367 0128 8DF80830 		strb	r3, [sp, #8]
 1368 012c 02E0     		b	.L102
 1369              	.LVL131:
 1370              	.L103:
 614:../Src/main.c ****             }
 1371              		.loc 1 614 0
 1372 012e 0120     		movs	r0, #1
ARM GAS  /tmp/cceAljft.s 			page 45


 1373              	.LVL132:
 1374 0130 FFF7FEFF 		bl	HandleError
 1375              	.LVL133:
 1376              	.L102:
 617:../Src/main.c ****         /* Check blue button */
 1377              		.loc 1 617 0
 1378 0134 02A8     		add	r0, sp, #8
 1379 0136 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 1380              	.LVL134:
 619:../Src/main.c ****             over=1;
 1381              		.loc 1 619 0
 1382 013a FFF7FEFF 		bl	BSP_GetPushButton
 1383              	.LVL135:
 1384 013e 0028     		cmp	r0, #0
 1385 0140 82D1     		bne	.L105
 625:../Src/main.c ****     htim3.Instance->CNT=0;       /////remise a zero du timer de la led
 1386              		.loc 1 625 0
 1387 0142 FFF7FEFF 		bl	PusbButton_WaitUnPress
 1388              	.LVL136:
 626:../Src/main.c ****     return status;
 1389              		.loc 1 626 0
 1390 0146 0B4B     		ldr	r3, .L109+24
 1391 0148 1B68     		ldr	r3, [r3]
 1392 014a 0022     		movs	r2, #0
 1393 014c 5A62     		str	r2, [r3, #36]
 627:../Src/main.c **** }
 1394              		.loc 1 627 0
 1395 014e 01E0     		b	.L96
 1396              	.LVL137:
 1397              	.L107:
 565:../Src/main.c ****     }
 1398              		.loc 1 565 0
 1399 0150 4FF0FF30 		mov	r0, #-1
 1400              	.LVL138:
 1401              	.L96:
 628:../Src/main.c **** 
 1402              		.loc 1 628 0
 1403 0154 05B0     		add	sp, sp, #20
 1404              	.LCFI30:
 1405              		.cfi_def_cfa_offset 28
 1406              		@ sp needed
 1407 0156 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 1408              	.LVL139:
 1409              	.L110:
 1410 015a 00BF     		.align	2
 1411              	.L109:
 1412 015c 00000000 		.word	.LANCHOR1
 1413 0160 10000000 		.word	.LC2
 1414 0164 00000000 		.word	RangingMeasurementData
 1415 0168 67666666 		.word	1717986919
 1416 016c 18000000 		.word	.LC3
 1417 0170 20000000 		.word	.LC4
 1418 0174 00000000 		.word	htim3
 1419              		.cfi_endproc
 1420              	.LFE124:
 1422              		.section	.text.ResetAndDetectSensor,"ax",%progbits
 1423              		.align	2
ARM GAS  /tmp/cceAljft.s 			page 46


 1424              		.global	ResetAndDetectSensor
 1425              		.thumb
 1426              		.thumb_func
 1428              	ResetAndDetectSensor:
 1429              	.LFB125:
 756:../Src/main.c ****     int nSensor;
 1430              		.loc 1 756 0
 1431              		.cfi_startproc
 1432              		@ args = 0, pretend = 0, frame = 0
 1433              		@ frame_needed = 0, uses_anonymous_args = 0
 1434              	.LVL140:
 1435 0000 08B5     		push	{r3, lr}
 1436              	.LCFI31:
 1437              		.cfi_def_cfa_offset 8
 1438              		.cfi_offset 3, -8
 1439              		.cfi_offset 14, -4
 758:../Src/main.c ****     /* at least one sensor and if one it must be the built-in one  */
 1440              		.loc 1 758 0
 1441 0002 FFF7FEFF 		bl	DetectSensors
 1442              	.LVL141:
 760:../Src/main.c ****         HandleError(ERR_DETECT);
 1443              		.loc 1 760 0
 1444 0006 0028     		cmp	r0, #0
 1445 0008 05DD     		ble	.L112
 760:../Src/main.c ****         HandleError(ERR_DETECT);
 1446              		.loc 1 760 0 is_stmt 0 discriminator 1
 1447 000a 0128     		cmp	r0, #1
 1448 000c 07D1     		bne	.L111
 760:../Src/main.c ****         HandleError(ERR_DETECT);
 1449              		.loc 1 760 0 discriminator 2
 1450 000e 044B     		ldr	r3, .L115
 1451 0010 D3F8F832 		ldr	r3, [r3, #760]
 1452 0014 1BB9     		cbnz	r3, .L111
 1453              	.L112:
 761:../Src/main.c ****     }
 1454              		.loc 1 761 0 is_stmt 1
 1455 0016 4FF0FF30 		mov	r0, #-1
 1456              	.LVL142:
 1457 001a FFF7FEFF 		bl	HandleError
 1458              	.LVL143:
 1459              	.L111:
 1460 001e 08BD     		pop	{r3, pc}
 1461              	.L116:
 1462              		.align	2
 1463              	.L115:
 1464 0020 00000000 		.word	.LANCHOR1
 1465              		.cfi_endproc
 1466              	.LFE125:
 1468              		.section	.text.SystemClock_Config,"ax",%progbits
 1469              		.align	2
 1470              		.global	SystemClock_Config
 1471              		.thumb
 1472              		.thumb_func
 1474              	SystemClock_Config:
 1475              	.LFB127:
 857:../Src/main.c **** 
 1476              		.loc 1 857 0
ARM GAS  /tmp/cceAljft.s 			page 47


 1477              		.cfi_startproc
 1478              		@ args = 0, pretend = 0, frame = 72
 1479              		@ frame_needed = 0, uses_anonymous_args = 0
 1480 0000 30B5     		push	{r4, r5, lr}
 1481              	.LCFI32:
 1482              		.cfi_def_cfa_offset 12
 1483              		.cfi_offset 4, -12
 1484              		.cfi_offset 5, -8
 1485              		.cfi_offset 14, -4
 1486 0002 93B0     		sub	sp, sp, #76
 1487              	.LCFI33:
 1488              		.cfi_def_cfa_offset 88
 862:../Src/main.c **** 
 1489              		.loc 1 862 0
 1490 0004 174A     		ldr	r2, .L119
 1491 0006 136C     		ldr	r3, [r2, #64]
 1492 0008 43F08053 		orr	r3, r3, #268435456
 1493 000c 1364     		str	r3, [r2, #64]
 864:../Src/main.c **** 
 1494              		.loc 1 864 0
 1495 000e A2F5E432 		sub	r2, r2, #116736
 1496 0012 1368     		ldr	r3, [r2]
 1497 0014 23F44043 		bic	r3, r3, #49152
 1498 0018 43F40043 		orr	r3, r3, #32768
 1499 001c 1360     		str	r3, [r2]
 866:../Src/main.c ****   RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 1500              		.loc 1 866 0
 1501 001e 0224     		movs	r4, #2
 1502 0020 0694     		str	r4, [sp, #24]
 867:../Src/main.c ****   RCC_OscInitStruct.HSICalibrationValue = 6;
 1503              		.loc 1 867 0
 1504 0022 0123     		movs	r3, #1
 1505 0024 0993     		str	r3, [sp, #36]
 868:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 1506              		.loc 1 868 0
 1507 0026 0623     		movs	r3, #6
 1508 0028 0A93     		str	r3, [sp, #40]
 869:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 1509              		.loc 1 869 0
 1510 002a 0C94     		str	r4, [sp, #48]
 870:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLM = 16;
 1511              		.loc 1 870 0
 1512 002c 0025     		movs	r5, #0
 1513 002e 0D95     		str	r5, [sp, #52]
 871:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLN = 336;
 1514              		.loc 1 871 0
 1515 0030 1023     		movs	r3, #16
 1516 0032 0E93     		str	r3, [sp, #56]
 872:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 1517              		.loc 1 872 0
 1518 0034 4FF4A873 		mov	r3, #336
 1519 0038 0F93     		str	r3, [sp, #60]
 873:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLQ = 7;
 1520              		.loc 1 873 0
 1521 003a 0423     		movs	r3, #4
 1522 003c 1093     		str	r3, [sp, #64]
 874:../Src/main.c ****   HAL_RCC_OscConfig(&RCC_OscInitStruct);
ARM GAS  /tmp/cceAljft.s 			page 48


 1523              		.loc 1 874 0
 1524 003e 0723     		movs	r3, #7
 1525 0040 1193     		str	r3, [sp, #68]
 875:../Src/main.c **** 
 1526              		.loc 1 875 0
 1527 0042 06A8     		add	r0, sp, #24
 1528 0044 FFF7FEFF 		bl	HAL_RCC_OscConfig
 1529              	.LVL144:
 877:../Src/main.c ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 1530              		.loc 1 877 0
 1531 0048 0523     		movs	r3, #5
 1532 004a 0193     		str	r3, [sp, #4]
 878:../Src/main.c ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 1533              		.loc 1 878 0
 1534 004c 0294     		str	r4, [sp, #8]
 879:../Src/main.c ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 1535              		.loc 1 879 0
 1536 004e 0395     		str	r5, [sp, #12]
 880:../Src/main.c ****   RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 1537              		.loc 1 880 0
 1538 0050 4FF48053 		mov	r3, #4096
 1539 0054 0493     		str	r3, [sp, #16]
 881:../Src/main.c ****   HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 1540              		.loc 1 881 0
 1541 0056 0595     		str	r5, [sp, #20]
 882:../Src/main.c **** 
 1542              		.loc 1 882 0
 1543 0058 01A8     		add	r0, sp, #4
 1544 005a 2146     		mov	r1, r4
 1545 005c FFF7FEFF 		bl	HAL_RCC_ClockConfig
 1546              	.LVL145:
 884:../Src/main.c **** 
 1547              		.loc 1 884 0
 1548 0060 13B0     		add	sp, sp, #76
 1549              	.LCFI34:
 1550              		.cfi_def_cfa_offset 12
 1551              		@ sp needed
 1552 0062 30BD     		pop	{r4, r5, pc}
 1553              	.L120:
 1554              		.align	2
 1555              	.L119:
 1556 0064 00380240 		.word	1073887232
 1557              		.cfi_endproc
 1558              	.LFE127:
 1560              		.section	.text.main,"ax",%progbits
 1561              		.align	2
 1562              		.global	main
 1563              		.thumb
 1564              		.thumb_func
 1566              	main:
 1567              	.LFB126:
 768:../Src/main.c **** 
 1568              		.loc 1 768 0
 1569              		.cfi_startproc
 1570              		@ args = 0, pretend = 0, frame = 0
 1571              		@ frame_needed = 0, uses_anonymous_args = 0
 1572 0000 70B5     		push	{r4, r5, r6, lr}
ARM GAS  /tmp/cceAljft.s 			page 49


 1573              	.LCFI35:
 1574              		.cfi_def_cfa_offset 16
 1575              		.cfi_offset 4, -16
 1576              		.cfi_offset 5, -12
 1577              		.cfi_offset 6, -8
 1578              		.cfi_offset 14, -4
 1579              	.LVL146:
 780:../Src/main.c **** 
 1580              		.loc 1 780 0
 1581 0002 FFF7FEFF 		bl	HAL_Init
 1582              	.LVL147:
 783:../Src/main.c **** 
 1583              		.loc 1 783 0
 1584 0006 FFF7FEFF 		bl	SystemClock_Config
 1585              	.LVL148:
 786:../Src/main.c ****   SystemClock_Config();
 1586              		.loc 1 786 0
 1587 000a FFF7FEFF 		bl	MX_GPIO_Init
 1588              	.LVL149:
 787:../Src/main.c ****   MX_I2C1_Init();
 1589              		.loc 1 787 0
 1590 000e FFF7FEFF 		bl	SystemClock_Config
 1591              	.LVL150:
 788:../Src/main.c ****   MX_TIM3_Init();
 1592              		.loc 1 788 0
 1593 0012 FFF7FEFF 		bl	MX_I2C1_Init
 1594              	.LVL151:
 789:../Src/main.c **** 
 1595              		.loc 1 789 0
 1596 0016 FFF7FEFF 		bl	MX_TIM3_Init
 1597              	.LVL152:
 792:../Src/main.c ****   uart_printf(WelcomeMsg);
 1598              		.loc 1 792 0
 1599 001a FFF7FEFF 		bl	XNUCLEO53L0A1_Init
 1600              	.LVL153:
 794:../Src/main.c ****   HAL_Delay(WelcomeTime);
 1601              		.loc 1 794 0
 1602 001e 2048     		ldr	r0, .L130
 1603 0020 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 1604              	.LVL154:
 795:../Src/main.c ****   ResetAndDetectSensor(1);
 1605              		.loc 1 795 0
 1606 0024 4FF42570 		mov	r0, #660
 1607 0028 FFF7FEFF 		bl	HAL_Delay
 1608              	.LVL155:
 796:../Src/main.c ****   HAL_TIM_Base_Start_IT(&htim3); //£
 1609              		.loc 1 796 0
 1610 002c 0120     		movs	r0, #1
 1611 002e FFF7FEFF 		bl	ResetAndDetectSensor
 1612              	.LVL156:
 797:../Src/main.c **** 
 1613              		.loc 1 797 0
 1614 0032 1C48     		ldr	r0, .L130+4
 1615 0034 FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1616              	.LVL157:
 774:../Src/main.c ****   /* USER CODE END 1 */
 1617              		.loc 1 774 0
ARM GAS  /tmp/cceAljft.s 			page 50


 1618 0038 0226     		movs	r6, #2
 773:../Src/main.c ****   int UseSensorsMask = 1<<XNUCLEO53L0A1_DEV_CENTER;
 1619              		.loc 1 773 0
 1620 003a 0025     		movs	r5, #0
 772:../Src/main.c ****   DemoMode_e DemoMode = RANGE_VALUE;
 1621              		.loc 1 772 0
 1622 003c 2C46     		mov	r4, r5
 1623 003e 02E0     		b	.L122
 1624              	.LVL158:
 1625              	.L126:
 842:../Src/main.c ****     	  }
 1626              		.loc 1 842 0
 1627 0040 0226     		movs	r6, #2
 1628              	.LVL159:
 1629 0042 00E0     		b	.L122
 1630              	.LVL160:
 1631              	.L127:
 846:../Src/main.c ****       }
 1632              		.loc 1 846 0
 1633 0044 0124     		movs	r4, #1
 1634              	.LVL161:
 1635              	.L122:
 813:../Src/main.c ****       HAL_Delay(ModeChangeDispTime);
 1636              		.loc 1 813 0
 1637 0046 184B     		ldr	r3, .L130+8
 1638 0048 53F82500 		ldr	r0, [r3, r5, lsl #2]
 1639 004c FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 1640              	.LVL162:
 814:../Src/main.c **** 
 1641              		.loc 1 814 0
 1642 0050 4FF4FA70 		mov	r0, #500
 1643 0054 FFF7FEFF 		bl	HAL_Delay
 1644              	.LVL163:
 817:../Src/main.c **** 	  HAL_Delay(ModeChangeDispTime);
 1645              		.loc 1 817 0
 1646 0058 144B     		ldr	r3, .L130+12
 1647 005a 53F82400 		ldr	r0, [r3, r4, lsl #2]
 1648 005e FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 1649              	.LVL164:
 818:../Src/main.c **** 
 1650              		.loc 1 818 0
 1651 0062 4FF4FA70 		mov	r0, #500
 1652 0066 FFF7FEFF 		bl	HAL_Delay
 1653              	.LVL165:
 821:../Src/main.c **** 
 1654              		.loc 1 821 0
 1655 006a 0020     		movs	r0, #0
 1656 006c FFF7FEFF 		bl	ResetAndDetectSensor
 1657              	.LVL166:
 824:../Src/main.c **** 
 1658              		.loc 1 824 0
 1659 0070 FFF7FEFF 		bl	TimeStamp_Reset
 1660              	.LVL167:
 834:../Src/main.c **** 
 1661              		.loc 1 834 0
 1662 0074 3046     		mov	r0, r6
 1663 0076 2146     		mov	r1, r4
ARM GAS  /tmp/cceAljft.s 			page 51


 1664 0078 FFF7FEFF 		bl	RangeDemo
 1665              	.LVL168:
 837:../Src/main.c ****     	  /* Long press : change demo mode if multiple sensors present*/
 1666              		.loc 1 837 0
 1667 007c 40B1     		cbz	r0, .L123
 839:../Src/main.c ****     		  /* If more than one sensor is present then toggle demo mode */
 1668              		.loc 1 839 0
 1669 007e 0C4B     		ldr	r3, .L130+16
 1670 0080 1B68     		ldr	r3, [r3]
 1671 0082 012B     		cmp	r3, #1
 1672 0084 DFDD     		ble	.L122
 1673              	.LVL169:
 842:../Src/main.c ****     	  }
 1674              		.loc 1 842 0
 1675 0086 95F00105 		eors	r5, r5, #1
 1676              	.LVL170:
 1677 008a D9D0     		beq	.L126
 1678 008c 0726     		movs	r6, #7
 1679              	.LVL171:
 1680 008e DAE7     		b	.L122
 1681              	.LVL172:
 1682              	.L123:
 846:../Src/main.c ****       }
 1683              		.loc 1 846 0
 1684 0090 002C     		cmp	r4, #0
 1685 0092 D7D0     		beq	.L127
 846:../Src/main.c ****       }
 1686              		.loc 1 846 0 is_stmt 0 discriminator 1
 1687 0094 012C     		cmp	r4, #1
 1688 0096 01D1     		bne	.L128
 846:../Src/main.c ****       }
 1689              		.loc 1 846 0
 1690 0098 0224     		movs	r4, #2
 1691              	.LVL173:
 1692 009a D4E7     		b	.L122
 1693              	.LVL174:
 1694              	.L128:
 1695 009c 0024     		movs	r4, #0
 1696              	.LVL175:
 1697 009e D2E7     		b	.L122
 1698              	.L131:
 1699              		.align	2
 1700              	.L130:
 1701 00a0 28000000 		.word	.LC5
 1702 00a4 00000000 		.word	htim3
 1703 00a8 00000000 		.word	.LANCHOR5
 1704 00ac 00000000 		.word	.LANCHOR6
 1705 00b0 00000000 		.word	.LANCHOR0
 1706              		.cfi_endproc
 1707              	.LFE126:
 1709              		.section	.text.HAL_TIM_PeriodElapsedCallback,"ax",%progbits
 1710              		.align	2
 1711              		.global	HAL_TIM_PeriodElapsedCallback
 1712              		.thumb
 1713              		.thumb_func
 1715              	HAL_TIM_PeriodElapsedCallback:
 1716              	.LFB131:
ARM GAS  /tmp/cceAljft.s 			page 52


 958:../Src/main.c **** 
 959:../Src/main.c **** /* USER CODE BEGIN 4 */
 960:../Src/main.c **** 
 961:../Src/main.c **** void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim){ //£
 1717              		.loc 1 961 0 is_stmt 1
 1718              		.cfi_startproc
 1719              		@ args = 0, pretend = 0, frame = 0
 1720              		@ frame_needed = 0, uses_anonymous_args = 0
 1721              	.LVL176:
 1722 0000 08B5     		push	{r3, lr}
 1723              	.LCFI36:
 1724              		.cfi_def_cfa_offset 8
 1725              		.cfi_offset 3, -8
 1726              		.cfi_offset 14, -4
 962:../Src/main.c ****   if(htim->Instance == htim3.Instance){
 1727              		.loc 1 962 0
 1728 0002 0268     		ldr	r2, [r0]
 1729 0004 044B     		ldr	r3, .L135
 1730 0006 1B68     		ldr	r3, [r3]
 1731 0008 9A42     		cmp	r2, r3
 1732 000a 03D1     		bne	.L132
 963:../Src/main.c ****     HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);              /////changement d'etat de la led
 1733              		.loc 1 963 0
 1734 000c 0348     		ldr	r0, .L135+4
 1735              	.LVL177:
 1736 000e 2021     		movs	r1, #32
 1737 0010 FFF7FEFF 		bl	HAL_GPIO_TogglePin
 1738              	.LVL178:
 1739              	.L132:
 1740 0014 08BD     		pop	{r3, pc}
 1741              	.L136:
 1742 0016 00BF     		.align	2
 1743              	.L135:
 1744 0018 00000000 		.word	htim3
 1745 001c 00000240 		.word	1073872896
 1746              		.cfi_endproc
 1747              	.LFE131:
 1749              		.global	WelcomeMsg
 1750              		.comm	htim5,60,4
 1751              		.global	RangeMedium
 1752              		.global	RangeLow
 1753              		.global	VL53L0XDevs
 1754              		.comm	nDevMask,4,4
 1755              		.global	nDevPresent
 1756              		.global	LeakyFactorFix8
 1757              		.comm	RangingMeasurementData,28,4
 1758              		.global	DemoModeTxt
 1759              		.global	RangingConfigTxt
 1760              		.global	TxtBarGraph
 1761              		.global	TxtRangeValue
 1762              		.comm	htim3,60,4
 1763              		.comm	hi2c1,56,4
 1764              		.section	.bss.nDevPresent,"aw",%nobits
 1765              		.align	2
 1766              		.set	.LANCHOR0,. + 0
 1769              	nDevPresent:
 1770 0000 00000000 		.space	4
ARM GAS  /tmp/cceAljft.s 			page 53


 1771              		.section	.rodata.TxtRangeValue,"a",%progbits
 1772              		.align	2
 1775              	TxtRangeValue:
 1776 0000 726E6700 		.ascii	"rng\000"
 1777              		.section	.data.VL53L0XDevs,"aw",%progbits
 1778              		.align	2
 1779              		.set	.LANCHOR1,. + 0
 1782              	VL53L0XDevs:
 1783 0000 00000000 		.space	348
 1783      00000000 
 1783      00000000 
 1783      00000000 
 1783      00000000 
 1784 015c 00000000 		.word	XNUCLEO53L0A1_hi2c
 1785 0160 52       		.byte	82
 1786 0161 6C       		.byte	108
 1787 0162 0000     		.space	2
 1788 0164 00000000 		.word	0
 1789 0168 00000000 		.space	40
 1789      00000000 
 1789      00000000 
 1789      00000000 
 1789      00000000 
 1790 0190 00000000 		.space	348
 1790      00000000 
 1790      00000000 
 1790      00000000 
 1790      00000000 
 1791 02ec 00000000 		.word	XNUCLEO53L0A1_hi2c
 1792 02f0 52       		.byte	82
 1793 02f1 63       		.byte	99
 1794 02f2 0000     		.space	2
 1795 02f4 01000000 		.word	1
 1796 02f8 00000000 		.space	40
 1796      00000000 
 1796      00000000 
 1796      00000000 
 1796      00000000 
 1797 0320 00000000 		.space	348
 1797      00000000 
 1797      00000000 
 1797      00000000 
 1797      00000000 
 1798 047c 00000000 		.word	XNUCLEO53L0A1_hi2c
 1799 0480 52       		.byte	82
 1800 0481 72       		.byte	114
 1801 0482 0000     		.space	2
 1802 0484 02000000 		.word	2
 1803 0488 00000000 		.space	40
 1803      00000000 
 1803      00000000 
 1803      00000000 
 1803      00000000 
 1804              		.section	.data.LeakyFactorFix8,"aw",%progbits
 1805              		.align	2
 1806              		.set	.LANCHOR4,. + 0
 1809              	LeakyFactorFix8:
ARM GAS  /tmp/cceAljft.s 			page 54


 1810 0000 99000000 		.word	153
 1811              		.section	.data.WelcomeMsg,"aw",%progbits
 1812              		.align	2
 1815              	WelcomeMsg:
 1816 0000 48692049 		.ascii	"Hi I am Ranging VL53L0X mcu STM32F401xE\012\000"
 1816      20616D20 
 1816      52616E67 
 1816      696E6720 
 1816      564C3533 
 1817              		.section	.rodata.str1.4,"aMS",%progbits,1
 1818              		.align	2
 1819              	.LC0:
 1820 0000 20726220 		.ascii	" rb \000"
 1820      00
 1821 0005 000000   		.space	3
 1822              	.LC1:
 1823 0008 45722564 		.ascii	"Er%d\000"
 1823      00
 1824 000d 000000   		.space	3
 1825              	.LC2:
 1826 0010 20202020 		.ascii	"    \000"
 1826      00
 1827 0015 000000   		.space	3
 1828              	.LC3:
 1829 0018 25336463 		.ascii	"%3dc\000"
 1829      00
 1830 001d 000000   		.space	3
 1831              	.LC4:
 1832 0020 2D2D2D2D 		.ascii	"----\000"
 1832      00
 1833 0025 000000   		.space	3
 1834              	.LC5:
 1835 0028 35334C30 		.ascii	"53L0\000"
 1835      00
 1836 002d 000000   		.space	3
 1837              	.LC6:
 1838 0030 726E6700 		.ascii	"rng\000"
 1839              	.LC7:
 1840 0034 62617200 		.ascii	"bar\000"
 1841              	.LC8:
 1842 0038 4C5200   		.ascii	"LR\000"
 1843 003b 00       		.space	1
 1844              	.LC9:
 1845 003c 485300   		.ascii	"HS\000"
 1846 003f 00       		.space	1
 1847              	.LC10:
 1848 0040 484100   		.ascii	"HA\000"
 1849              		.section	.data.RangingConfigTxt,"aw",%progbits
 1850              		.align	2
 1851              		.set	.LANCHOR6,. + 0
 1854              	RangingConfigTxt:
 1855 0000 38000000 		.word	.LC8
 1856 0004 3C000000 		.word	.LC9
 1857 0008 40000000 		.word	.LC10
 1858              		.section	.rodata.TxtBarGraph,"a",%progbits
 1859              		.align	2
 1862              	TxtBarGraph:
ARM GAS  /tmp/cceAljft.s 			page 55


 1863 0000 62617200 		.ascii	"bar\000"
 1864              		.section	.data.RangeLow,"aw",%progbits
 1865              		.align	2
 1866              		.set	.LANCHOR2,. + 0
 1869              	RangeLow:
 1870 0000 64000000 		.word	100
 1871              		.section	.data.RangeMedium,"aw",%progbits
 1872              		.align	2
 1873              		.set	.LANCHOR3,. + 0
 1876              	RangeMedium:
 1877 0000 2C010000 		.word	300
 1878              		.section	.data.DemoModeTxt,"aw",%progbits
 1879              		.align	2
 1880              		.set	.LANCHOR5,. + 0
 1883              	DemoModeTxt:
 1884 0000 30000000 		.word	.LC6
 1885 0004 34000000 		.word	.LC7
 1886              		.text
 1887              	.Letext0:
 1888              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1889              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 1890              		.file 4 "../Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f401xe.h"
 1891              		.file 5 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 1892              		.file 6 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_rcc.h"
 1893              		.file 7 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_gpio.h"
 1894              		.file 8 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 1895              		.file 9 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_i2c.h"
 1896              		.file 10 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_tim.h"
 1897              		.file 11 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_tim_ex.h"
 1898              		.file 12 "../Drivers/BSP/Components/vl53l0x/vl53l0x_types.h"
 1899              		.file 13 "../Drivers/BSP/Components/vl53l0x/vl53l0x_device.h"
 1900              		.file 14 "../Drivers/BSP/Components/vl53l0x/vl53l0x_def.h"
 1901              		.file 15 "../Drivers/BSP/X-NUCLEO-53L0A1/vl53l0x_platform.h"
 1902              		.file 16 "../Drivers/CMSIS/Include/core_cm4.h"
 1903              		.file 17 "../Drivers/BSP/X-NUCLEO-53L0A1/X-NUCLEO-53L0A1.h"
 1904              		.file 18 "/usr/include/newlib/stdio.h"
 1905              		.file 19 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal.h"
 1906              		.file 20 "../Drivers/BSP/Components/vl53l0x/vl53l0x_api.h"
ARM GAS  /tmp/cceAljft.s 			page 56


DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cceAljft.s:21     .text.MX_GPIO_Init:0000000000000000 $t
     /tmp/cceAljft.s:25     .text.MX_GPIO_Init:0000000000000000 MX_GPIO_Init
     /tmp/cceAljft.s:94     .text.MX_GPIO_Init:0000000000000054 $d
     /tmp/cceAljft.s:101    .text.MX_I2C1_Init:0000000000000000 $t
     /tmp/cceAljft.s:105    .text.MX_I2C1_Init:0000000000000000 MX_I2C1_Init
     /tmp/cceAljft.s:146    .text.MX_I2C1_Init:0000000000000028 $d
                            *COM*:0000000000000038 hi2c1
     /tmp/cceAljft.s:153    .text.MX_TIM3_Init:0000000000000000 $t
     /tmp/cceAljft.s:157    .text.MX_TIM3_Init:0000000000000000 MX_TIM3_Init
     /tmp/cceAljft.s:217    .text.MX_TIM3_Init:0000000000000044 $d
                            *COM*:000000000000003c htim3
     /tmp/cceAljft.s:223    .text.MX_TIM5_Init:0000000000000000 $t
     /tmp/cceAljft.s:228    .text.MX_TIM5_Init:0000000000000000 MX_TIM5_Init
     /tmp/cceAljft.s:294    .text.MX_TIM5_Init:0000000000000044 $d
                            *COM*:000000000000003c htim5
     /tmp/cceAljft.s:300    .text.TimeStamp_Init:0000000000000000 $t
     /tmp/cceAljft.s:305    .text.TimeStamp_Init:0000000000000000 TimeStamp_Init
     /tmp/cceAljft.s:324    .text.TimeStamp_Reset:0000000000000000 $t
     /tmp/cceAljft.s:329    .text.TimeStamp_Reset:0000000000000000 TimeStamp_Reset
     /tmp/cceAljft.s:353    .text.TimeStamp_Reset:0000000000000014 $d
     /tmp/cceAljft.s:358    .text.TimeStamp_Get:0000000000000000 $t
     /tmp/cceAljft.s:363    .text.TimeStamp_Get:0000000000000000 TimeStamp_Get
     /tmp/cceAljft.s:379    .text.TimeStamp_Get:0000000000000008 $d
     /tmp/cceAljft.s:384    .text.BSP_GetPushButton:0000000000000000 $t
     /tmp/cceAljft.s:389    .text.BSP_GetPushButton:0000000000000000 BSP_GetPushButton
     /tmp/cceAljft.s:410    .text.BSP_GetPushButton:0000000000000010 $d
     /tmp/cceAljft.s:415    .text.PusbButton_WaitUnPress:0000000000000000 $t
     /tmp/cceAljft.s:420    .text.PusbButton_WaitUnPress:0000000000000000 PusbButton_WaitUnPress
     /tmp/cceAljft.s:470    .text.PusbButton_WaitUnPress:0000000000000038 $d
     /tmp/cceAljft.s:475    .text.HandleError:0000000000000000 $t
     /tmp/cceAljft.s:480    .text.HandleError:0000000000000000 HandleError
     /tmp/cceAljft.s:511    .text.HandleError:0000000000000018 $d
     /tmp/cceAljft.s:516    .text.DetectSensors:0000000000000000 $t
     /tmp/cceAljft.s:521    .text.DetectSensors:0000000000000000 DetectSensors
     /tmp/cceAljft.s:758    .text.DetectSensors:0000000000000144 $d
                            *COM*:0000000000000004 nDevMask
     /tmp/cceAljft.s:766    .text.SetupSingleShot:0000000000000000 $t
     /tmp/cceAljft.s:771    .text.SetupSingleShot:0000000000000000 SetupSingleShot
     /tmp/cceAljft.s:962    .text.SetupSingleShot:000000000000011c $d
     /tmp/cceAljft.s:968    .text.RangeToLetter:0000000000000000 $t
     /tmp/cceAljft.s:973    .text.RangeToLetter:0000000000000000 RangeToLetter
     /tmp/cceAljft.s:1021   .text.RangeToLetter:0000000000000028 $d
     /tmp/cceAljft.s:1027   .text.Sensor_SetNewRange:0000000000000000 $t
     /tmp/cceAljft.s:1032   .text.Sensor_SetNewRange:0000000000000000 Sensor_SetNewRange
     /tmp/cceAljft.s:1095   .text.Sensor_SetNewRange:0000000000000044 $d
     /tmp/cceAljft.s:1100   .text.blink_led:0000000000000000 $t
     /tmp/cceAljft.s:1105   .text.blink_led:0000000000000000 blink_led
     /tmp/cceAljft.s:1160   .text.blink_led:0000000000000030 $d
     /tmp/cceAljft.s:1165   .text.RangeDemo:0000000000000000 $t
     /tmp/cceAljft.s:1170   .text.RangeDemo:0000000000000000 RangeDemo
     /tmp/cceAljft.s:1412   .text.RangeDemo:000000000000015c $d
                            *COM*:000000000000001c RangingMeasurementData
     /tmp/cceAljft.s:1423   .text.ResetAndDetectSensor:0000000000000000 $t
     /tmp/cceAljft.s:1428   .text.ResetAndDetectSensor:0000000000000000 ResetAndDetectSensor
     /tmp/cceAljft.s:1464   .text.ResetAndDetectSensor:0000000000000020 $d
ARM GAS  /tmp/cceAljft.s 			page 57


     /tmp/cceAljft.s:1469   .text.SystemClock_Config:0000000000000000 $t
     /tmp/cceAljft.s:1474   .text.SystemClock_Config:0000000000000000 SystemClock_Config
     /tmp/cceAljft.s:1556   .text.SystemClock_Config:0000000000000064 $d
     /tmp/cceAljft.s:1561   .text.main:0000000000000000 $t
     /tmp/cceAljft.s:1566   .text.main:0000000000000000 main
     /tmp/cceAljft.s:1701   .text.main:00000000000000a0 $d
     /tmp/cceAljft.s:1710   .text.HAL_TIM_PeriodElapsedCallback:0000000000000000 $t
     /tmp/cceAljft.s:1715   .text.HAL_TIM_PeriodElapsedCallback:0000000000000000 HAL_TIM_PeriodElapsedCallback
     /tmp/cceAljft.s:1744   .text.HAL_TIM_PeriodElapsedCallback:0000000000000018 $d
     /tmp/cceAljft.s:1815   .data.WelcomeMsg:0000000000000000 WelcomeMsg
     /tmp/cceAljft.s:1876   .data.RangeMedium:0000000000000000 RangeMedium
     /tmp/cceAljft.s:1869   .data.RangeLow:0000000000000000 RangeLow
     /tmp/cceAljft.s:1782   .data.VL53L0XDevs:0000000000000000 VL53L0XDevs
     /tmp/cceAljft.s:1769   .bss.nDevPresent:0000000000000000 nDevPresent
     /tmp/cceAljft.s:1809   .data.LeakyFactorFix8:0000000000000000 LeakyFactorFix8
     /tmp/cceAljft.s:1883   .data.DemoModeTxt:0000000000000000 DemoModeTxt
     /tmp/cceAljft.s:1854   .data.RangingConfigTxt:0000000000000000 RangingConfigTxt
     /tmp/cceAljft.s:1862   .rodata.TxtBarGraph:0000000000000000 TxtBarGraph
     /tmp/cceAljft.s:1775   .rodata.TxtRangeValue:0000000000000000 TxtRangeValue
     /tmp/cceAljft.s:1765   .bss.nDevPresent:0000000000000000 $d
     /tmp/cceAljft.s:1772   .rodata.TxtRangeValue:0000000000000000 $d
     /tmp/cceAljft.s:1778   .data.VL53L0XDevs:0000000000000000 $d
     /tmp/cceAljft.s:1805   .data.LeakyFactorFix8:0000000000000000 $d
     /tmp/cceAljft.s:1812   .data.WelcomeMsg:0000000000000000 $d
     /tmp/cceAljft.s:1818   .rodata.str1.4:0000000000000000 $d
     /tmp/cceAljft.s:1850   .data.RangingConfigTxt:0000000000000000 $d
     /tmp/cceAljft.s:1859   .rodata.TxtBarGraph:0000000000000000 $d
     /tmp/cceAljft.s:1865   .data.RangeLow:0000000000000000 $d
     /tmp/cceAljft.s:1872   .data.RangeMedium:0000000000000000 $d
     /tmp/cceAljft.s:1879   .data.DemoModeTxt:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
HAL_GPIO_Init
HAL_I2C_Init
HAL_TIM_Base_Init
HAL_TIM_ConfigClockSource
HAL_TIMEx_MasterConfigSynchronization
HAL_TIM_OC_Init
HAL_TIM_OC_ConfigChannel
HAL_TIM_Base_Start
HAL_GPIO_ReadPin
HAL_GetTick
XNUCLEO53L0A1_SetDisplayString
sprintf
XNUCLEO53L0A1_ResetId
HAL_Delay
VL53L0X_WrByte
VL53L0X_RdWord
VL53L0X_SetDeviceAddress
VL53L0X_DataInit
VL53L0X_StaticInit
VL53L0X_PerformRefCalibration
VL53L0X_PerformRefSpadManagement
VL53L0X_SetDeviceMode
VL53L0X_SetLimitCheckEnable
VL53L0X_SetLimitCheckValue
ARM GAS  /tmp/cceAljft.s 			page 58


VL53L0X_SetMeasurementTimingBudgetMicroSeconds
VL53L0X_SetVcselPulsePeriod
HAL_TIM_Base_Stop_IT
HAL_TIM_Base_Start_IT
VL53L0X_PerformSingleRangingMeasurement
HAL_RCC_OscConfig
HAL_RCC_ClockConfig
HAL_Init
XNUCLEO53L0A1_Init
HAL_GPIO_TogglePin
XNUCLEO53L0A1_hi2c
