ARM GAS  /tmp/ccNelj9t.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.syntax unified
  17              		.file	"main.c"
  18              		.text
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.section	.text.XL_320_Delay_HAL,"ax",%progbits
  22              		.align	2
  23              		.global	XL_320_Delay_HAL
  24              		.thumb
  25              		.thumb_func
  27              	XL_320_Delay_HAL:
  28              	.LFB131:
  29              		.file 1 "../Src/main.c"
   1:../Src/main.c **** /**
   2:../Src/main.c ****   ******************************************************************************
   3:../Src/main.c ****   * File Name          : main.c
   4:../Src/main.c ****   * Date               : 01/03/2018 16:55:48
   5:../Src/main.c ****   * Description        : Main program body
   6:../Src/main.c ****   ******************************************************************************
   7:../Src/main.c ****   *
   8:../Src/main.c ****   * COPYRIGHT(c) 2018 STMicroelectronics
   9:../Src/main.c ****   *
  10:../Src/main.c ****   * Redistribution and use in source and binary forms, with or without modification,
  11:../Src/main.c ****   * are permitted provided that the following conditions are met:
  12:../Src/main.c ****   *   1. Redistributions of source code must retain the above copyright notice,
  13:../Src/main.c ****   *      this list of conditions and the following disclaimer.
  14:../Src/main.c ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
  15:../Src/main.c ****   *      this list of conditions and the following disclaimer in the documentation
  16:../Src/main.c ****   *      and/or other materials provided with the distribution.
  17:../Src/main.c ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
  18:../Src/main.c ****   *      may be used to endorse or promote products derived from this software
  19:../Src/main.c ****   *      without specific prior written permission.
  20:../Src/main.c ****   *
  21:../Src/main.c ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:../Src/main.c ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:../Src/main.c ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  24:../Src/main.c ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  25:../Src/main.c ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  26:../Src/main.c ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  27:../Src/main.c ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  28:../Src/main.c ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  29:../Src/main.c ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
ARM GAS  /tmp/ccNelj9t.s 			page 2


  30:../Src/main.c ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31:../Src/main.c ****   *
  32:../Src/main.c ****   ******************************************************************************
  33:../Src/main.c ****   */
  34:../Src/main.c **** 
  35:../Src/main.c **** /* Includes ------------------------------------------------------------------*/
  36:../Src/main.c **** #include "stm32f4xx_hal.h"
  37:../Src/main.c **** 
  38:../Src/main.c **** /* USER CODE BEGIN Includes */
  39:../Src/main.c **** #include <string.h>
  40:../Src/main.c **** #include "X-NUCLEO-53L0A1.h"
  41:../Src/main.c **** #include "vl53l0x_api.h"
  42:../Src/main.c **** #include <limits.h>
  43:../Src/main.c **** #include <stdio.h>
  44:../Src/main.c **** #include <stdlib.h>
  45:../Src/main.c **** #include "xl_320.h"
  46:../Src/main.c **** 
  47:../Src/main.c **** /**
  48:../Src/main.c ****  * @defgroup Configuration Static configuration
  49:../Src/main.c ****  * @{
  50:../Src/main.c ****  */
  51:../Src/main.c **** #define HAVE_ALARM_DEMO 0
  52:../Src/main.c **** 
  53:../Src/main.c **** /** Time the initial 53L0 message is shown at power up */
  54:../Src/main.c **** #define WelcomeTime 660
  55:../Src/main.c **** 
  56:../Src/main.c **** /** Time the initial 53L0 message is shown at power up */
  57:../Src/main.c **** #define ModeChangeDispTime  500
  58:../Src/main.c **** 
  59:../Src/main.c **** /**
  60:../Src/main.c ****  * Time considered as  a "long push" on push button
  61:../Src/main.c ****  */
  62:../Src/main.c **** #define PressBPSwicthTime   1000
  63:../Src/main.c **** 
  64:../Src/main.c **** /** @}  */ /* config group */
  65:../Src/main.c **** 
  66:../Src/main.c **** #ifndef MIN
  67:../Src/main.c **** #   define MIN(a,b) ((a) < (b) ? (a) : (b))
  68:../Src/main.c **** #endif
  69:../Src/main.c **** 
  70:../Src/main.c **** #define B1_Pin GPIO_PIN_13
  71:../Src/main.c **** #define B1_GPIO_Port GPIOC
  72:../Src/main.c **** #define LD2_Pin GPIO_PIN_5
  73:../Src/main.c **** #define LD2_GPIO_Port GPIOA
  74:../Src/main.c **** #define USART1_DIR_Pin GPIO_PIN_9
  75:../Src/main.c **** #define USART1_DIR_GPIO_Port GPIOC
  76:../Src/main.c **** 
  77:../Src/main.c ****  
  78:../Src/main.c **** #ifndef ARRAY_SIZE
  79:../Src/main.c **** #   define ARRAY_SIZE(x) (sizeof((x))/sizeof((x)[0]))
  80:../Src/main.c **** #endif
  81:../Src/main.c **** 
  82:../Src/main.c **** /**
  83:../Src/main.c ****  * @defgroup ErrCode Errors code shown on display
  84:../Src/main.c ****  * @{
  85:../Src/main.c ****  */
  86:../Src/main.c **** #define ERR_DETECT             -1
ARM GAS  /tmp/ccNelj9t.s 			page 3


  87:../Src/main.c **** #define ERR_DEMO_RANGE_ONE     1
  88:../Src/main.c **** #define ERR_DEMO_RANGE_MULTI   2
  89:../Src/main.c **** 
  90:../Src/main.c **** 
  91:../Src/main.c **** /** }@} */ /* defgroup ErrCode */
  92:../Src/main.c **** 
  93:../Src/main.c **** 
  94:../Src/main.c **** /* USER CODE END Includes */
  95:../Src/main.c **** 
  96:../Src/main.c **** /* Private variables ---------------------------------------------------------*/
  97:../Src/main.c **** I2C_HandleTypeDef hi2c1;
  98:../Src/main.c **** 
  99:../Src/main.c **** TIM_HandleTypeDef htim3;
 100:../Src/main.c **** 
 101:../Src/main.c **** UART_HandleTypeDef huart1;
 102:../Src/main.c **** UART_HandleTypeDef huart2;
 103:../Src/main.c **** 
 104:../Src/main.c **** /* USER CODE BEGIN PV */
 105:../Src/main.c **** /* Private variables ---------------------------------------------------------*/
 106:../Src/main.c **** 
 107:../Src/main.c **** const char TxtRangeValue[]  = "rng";
 108:../Src/main.c **** const char TxtBarGraph[]    = "bar";
 109:../Src/main.c **** #if HAVE_ALARM_DEMO
 110:../Src/main.c **** const char TxtAlarm[]       = "Alr";
 111:../Src/main.c **** #endif
 112:../Src/main.c **** 
 113:../Src/main.c **** 
 114:../Src/main.c **** typedef enum {
 115:../Src/main.c **** 	LONG_RANGE 		= 0, /*!< Long range mode */
 116:../Src/main.c **** 	HIGH_SPEED 		= 1, /*!< High speed mode */
 117:../Src/main.c **** 	HIGH_ACCURACY	= 2, /*!< High accuracy mode */
 118:../Src/main.c **** } RangingConfig_e;
 119:../Src/main.c **** char *RangingConfigTxt[3] = {"LR", "HS", "HA"};
 120:../Src/main.c **** 
 121:../Src/main.c **** typedef enum {
 122:../Src/main.c **** 	RANGE_VALUE 	= 0, /*!< Range displayed in cm */
 123:../Src/main.c **** 	BAR_GRAPH 		= 1, /*!< Range displayed as a bar graph : one bar per sensor */
 124:../Src/main.c **** } DemoMode_e;
 125:../Src/main.c **** char *DemoModeTxt[2] = {"rng", "bar"};
 126:../Src/main.c **** 
 127:../Src/main.c **** /**
 128:../Src/main.c ****  * Global ranging struct
 129:../Src/main.c ****  */
 130:../Src/main.c **** VL53L0X_RangingMeasurementData_t RangingMeasurementData;
 131:../Src/main.c **** 
 132:../Src/main.c **** 
 133:../Src/main.c **** /** leaky factor for filtered range
 134:../Src/main.c ****  *
 135:../Src/main.c ****  * r(n) = averaged_r(n-1)*leaky +r(n)(1-leaky)
 136:../Src/main.c ****  *
 137:../Src/main.c ****  * */
 138:../Src/main.c **** int LeakyFactorFix8 = (int)( 0.6 *256);
 139:../Src/main.c **** /** How many device detect set by @a DetectSensors()*/
 140:../Src/main.c **** int nDevPresent=0;
 141:../Src/main.c **** /** bit is index in VL53L0XDevs that is not necessary the dev id of the BSP */
 142:../Src/main.c **** int nDevMask;
 143:../Src/main.c **** 
ARM GAS  /tmp/ccNelj9t.s 			page 4


 144:../Src/main.c **** 
 145:../Src/main.c **** VL53L0X_Dev_t VL53L0XDevs[]={
 146:../Src/main.c ****         {.Id=XNUCLEO53L0A1_DEV_LEFT, .DevLetter='l', .I2cHandle=&XNUCLEO53L0A1_hi2c, .I2cDevAddr=0x
 147:../Src/main.c ****         {.Id=XNUCLEO53L0A1_DEV_CENTER, .DevLetter='c', .I2cHandle=&XNUCLEO53L0A1_hi2c, .I2cDevAddr=
 148:../Src/main.c ****         {.Id=XNUCLEO53L0A1_DEV_RIGHT, .DevLetter='r', .I2cHandle=&XNUCLEO53L0A1_hi2c, .I2cDevAddr=0
 149:../Src/main.c **** };
 150:../Src/main.c **** 
 151:../Src/main.c **** /** range low (and high) in @a RangeToLetter()
 152:../Src/main.c ****  *
 153:../Src/main.c ****  * used for displaying  multiple sensor as bar graph
 154:../Src/main.c ****  */
 155:../Src/main.c **** int RangeLow=100;
 156:../Src/main.c **** 
 157:../Src/main.c **** /** range medium in @a RangeToLetter()
 158:../Src/main.c ****  *
 159:../Src/main.c ****  * used for displaying  multiple sensor as bar graph
 160:../Src/main.c ****  */
 161:../Src/main.c **** int RangeMedium=300;
 162:../Src/main.c **** 
 163:../Src/main.c **** /** Timer
 164:../Src/main.c ****  *
 165:../Src/main.c ****  * Used to get time stamp for UART logging
 166:../Src/main.c ****  */
 167:../Src/main.c **** TIM_HandleTypeDef htim5;
 168:../Src/main.c **** 
 169:../Src/main.c **** /* TIM5 init function */
 170:../Src/main.c **** void MX_TIM5_Init(void)
 171:../Src/main.c **** {
 172:../Src/main.c **** 
 173:../Src/main.c ****   TIM_MasterConfigTypeDef sMasterConfig;
 174:../Src/main.c ****   TIM_OC_InitTypeDef sConfigOC;
 175:../Src/main.c **** 
 176:../Src/main.c ****   htim5.Instance = TIM5;
 177:../Src/main.c ****   htim5.Init.Prescaler = 83;
 178:../Src/main.c ****   htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 179:../Src/main.c ****   htim5.Init.Period = 0xFFFFFFFF;
 180:../Src/main.c ****   htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 181:../Src/main.c ****   HAL_TIM_OC_Init(&htim5);
 182:../Src/main.c **** 
 183:../Src/main.c ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 184:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 185:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig);
 186:../Src/main.c **** 
 187:../Src/main.c ****   sConfigOC.OCMode = TIM_OCMODE_TIMING;
 188:../Src/main.c ****   sConfigOC.Pulse = 0;
 189:../Src/main.c ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 190:../Src/main.c ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 191:../Src/main.c ****   HAL_TIM_OC_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1);
 192:../Src/main.c **** 
 193:../Src/main.c **** }
 194:../Src/main.c **** 
 195:../Src/main.c **** void TimeStamp_Init(){
 196:../Src/main.c ****     MX_TIM5_Init();
 197:../Src/main.c **** }
 198:../Src/main.c **** 
 199:../Src/main.c **** void TimeStamp_Reset(){
 200:../Src/main.c ****     HAL_TIM_Base_Start(&htim5);
ARM GAS  /tmp/ccNelj9t.s 			page 5


 201:../Src/main.c ****     htim5.Instance->CNT=0;
 202:../Src/main.c **** }
 203:../Src/main.c **** 
 204:../Src/main.c **** uint32_t TimeStamp_Get(){
 205:../Src/main.c ****     return htim5.Instance->CNT;
 206:../Src/main.c **** }
 207:../Src/main.c **** 
 208:../Src/main.c **** /* USER CODE END PV */
 209:../Src/main.c **** 
 210:../Src/main.c **** /* Private function prototypes -----------------------------------------------*/
 211:../Src/main.c **** static void MX_GPIO_Init(void);
 212:../Src/main.c **** static void SystemClock_Config(void);
 213:../Src/main.c **** static void MX_I2C1_Init(void);
 214:../Src/main.c **** static void MX_TIM3_Init(void);
 215:../Src/main.c **** static void MX_USART2_UART_Init(void);
 216:../Src/main.c **** static void MX_USART1_UART_Init(void);
 217:../Src/main.c **** 
 218:../Src/main.c **** /* USER CODE BEGIN PFP */
 219:../Src/main.c **** /* Private function prototypes -----------------------------------------------*/
 220:../Src/main.c **** void ResetAndDetectSensor(int SetDisplay);
 221:../Src/main.c **** 
 222:../Src/main.c **** /* USER CODE END PFP */
 223:../Src/main.c **** 
 224:../Src/main.c **** /* USER CODE BEGIN 0 */
 225:../Src/main.c **** 
 226:../Src/main.c **** #define debug_printf    trace_printf
 227:../Src/main.c **** char WelcomeMsg[]="Hi I am Ranging VL53L0X mcu " MCU_NAME "\n";
 228:../Src/main.c **** 
 229:../Src/main.c **** #if HAVE_ALARM_DEMO
 230:../Src/main.c **** volatile int IntrCount;
 231:../Src/main.c **** volatile int LastIntrPin;
 232:../Src/main.c **** volatile int LastIntrId;
 233:../Src/main.c **** volatile int IntrCounts[3];
 234:../Src/main.c **** #endif
 235:../Src/main.c **** 
 236:../Src/main.c **** #define BSP_BP_PORT GPIOC
 237:../Src/main.c **** #define BSP_BP_PIN  GPIO_PIN_13
 238:../Src/main.c **** 
 239:../Src/main.c **** int BSP_GetPushButton(void){
 240:../Src/main.c ****     GPIO_PinState state ;
 241:../Src/main.c ****     state = HAL_GPIO_ReadPin(BSP_BP_PORT, BSP_BP_PIN);
 242:../Src/main.c ****     return state;
 243:../Src/main.c **** }
 244:../Src/main.c **** 
 245:../Src/main.c **** /**
 246:../Src/main.c ****  * When button is already pressed it waits for user to release it.
 247:../Src/main.c ****  * if button remains pressed for a given time it returns true.
 248:../Src/main.c ****  * This is used to detect mode switch by long press on blue Push Button
 249:../Src/main.c ****  *
 250:../Src/main.c ****  * As soon as time is elapsed -rb- is displayed to let user know the mode
 251:../Src/main.c ****  * switch is taken into account
 252:../Src/main.c ****  *
 253:../Src/main.c ****  * @return True if button remains pressed more than specified time
 254:../Src/main.c ****  */
 255:../Src/main.c **** int PusbButton_WaitUnPress(void){
 256:../Src/main.c ****     uint32_t TimeStarted;
 257:../Src/main.c ****     TimeStarted = HAL_GetTick();
ARM GAS  /tmp/ccNelj9t.s 			page 6


 258:../Src/main.c ****     while( !BSP_GetPushButton() ){ ; /* debounce */
 259:../Src/main.c ****         if(HAL_GetTick()- TimeStarted> PressBPSwicthTime){
 260:../Src/main.c ****             XNUCLEO53L0A1_SetDisplayString (" rb ");
 261:../Src/main.c ****         }
 262:../Src/main.c ****     }
 263:../Src/main.c ****     return  HAL_GetTick() - TimeStarted>PressBPSwicthTime;
 264:../Src/main.c **** 
 265:../Src/main.c **** }
 266:../Src/main.c **** 
 267:../Src/main.c **** #if HAVE_ALARM_DEMO
 268:../Src/main.c **** /**
 269:../Src/main.c ****  * Interrupt handler called each time an interrupt is produced by the ranging sensor (in ALARM mode
 270:../Src/main.c ****  * @param err
 271:../Src/main.c ****  */
 272:../Src/main.c **** void VL53L0A1_EXTI_Callback(int DevNo, int GPIO_Pin){
 273:../Src/main.c ****     IntrCount++;
 274:../Src/main.c ****     LastIntrPin=GPIO_Pin;
 275:../Src/main.c ****     LastIntrId=DevNo;
 276:../Src/main.c **** 
 277:../Src/main.c ****     if( DevNo< ARRAY_SIZE(IntrCounts)  ){
 278:../Src/main.c ****         IntrCounts[DevNo]++;
 279:../Src/main.c ****     }
 280:../Src/main.c **** }
 281:../Src/main.c **** #endif
 282:../Src/main.c **** 
 283:../Src/main.c **** 
 284:../Src/main.c **** /**
 285:../Src/main.c ****  * Handle Error
 286:../Src/main.c ****  *
 287:../Src/main.c ****  * Set err on display and loop forever
 288:../Src/main.c ****  * @param err Error case code
 289:../Src/main.c ****  */
 290:../Src/main.c **** void HandleError(int err){
 291:../Src/main.c ****     char msg[16];
 292:../Src/main.c ****     sprintf(msg,"Er%d", err);
 293:../Src/main.c ****     XNUCLEO53L0A1_SetDisplayString(msg);
 294:../Src/main.c ****     while(1){};
 295:../Src/main.c **** }
 296:../Src/main.c **** 
 297:../Src/main.c **** /**
 298:../Src/main.c ****  * Reset all sensor then do presence detection
 299:../Src/main.c ****  *
 300:../Src/main.c ****  * All present devices are data initiated and assigned to their final I2C address
 301:../Src/main.c ****  * @return
 302:../Src/main.c ****  */
 303:../Src/main.c **** int DetectSensors(int SetDisplay) {
 304:../Src/main.c ****     int i;
 305:../Src/main.c ****     uint16_t Id;
 306:../Src/main.c ****     int status;
 307:../Src/main.c ****     int FinalAddress;
 308:../Src/main.c **** 
 309:../Src/main.c ****     char PresentMsg[5]="    ";
 310:../Src/main.c ****     /* Reset all */
 311:../Src/main.c ****     nDevPresent = 0;
 312:../Src/main.c ****     for (i = 0; i < 3; i++)
 313:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 314:../Src/main.c **** 
ARM GAS  /tmp/ccNelj9t.s 			page 7


 315:../Src/main.c ****     /* detect all sensors (even on-board)*/
 316:../Src/main.c ****     for (i = 0; i < 3; i++) {
 317:../Src/main.c ****         VL53L0X_Dev_t *pDev;
 318:../Src/main.c ****         pDev = &VL53L0XDevs[i];
 319:../Src/main.c ****         pDev->I2cDevAddr = 0x52;
 320:../Src/main.c ****         pDev->Present = 0;
 321:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId( pDev->Id, 1);
 322:../Src/main.c ****         HAL_Delay(2);
 323:../Src/main.c ****         FinalAddress=0x52+(i+1)*2;
 324:../Src/main.c **** 
 325:../Src/main.c ****         do {
 326:../Src/main.c ****         	/* Set I2C standard mode (400 KHz) before doing the first register access */
 327:../Src/main.c ****         	if (status == VL53L0X_ERROR_NONE)
 328:../Src/main.c ****         		status = VL53L0X_WrByte(pDev, 0x88, 0x00);
 329:../Src/main.c **** 
 330:../Src/main.c ****         	/* Try to read one register using default 0x52 address */
 331:../Src/main.c ****             status = VL53L0X_RdWord(pDev, VL53L0X_REG_IDENTIFICATION_MODEL_ID, &Id);
 332:../Src/main.c ****             if (status) {
 333:../Src/main.c ****                 debug_printf("#%d Read id fail\n", i);
 334:../Src/main.c ****                 break;
 335:../Src/main.c ****             }
 336:../Src/main.c ****             if (Id == 0xEEAA) {
 337:../Src/main.c **** 				/* Sensor is found => Change its I2C address to final one */
 338:../Src/main.c ****                 status = VL53L0X_SetDeviceAddress(pDev,FinalAddress);
 339:../Src/main.c ****                 if (status != 0) {
 340:../Src/main.c ****                     debug_printf("#i VL53L0X_SetDeviceAddress fail\n", i);
 341:../Src/main.c ****                     break;
 342:../Src/main.c ****                 }
 343:../Src/main.c ****                 pDev->I2cDevAddr = FinalAddress;
 344:../Src/main.c ****                 /* Check all is OK with the new I2C address and initialize the sensor */
 345:../Src/main.c ****                 status = VL53L0X_RdWord(pDev, VL53L0X_REG_IDENTIFICATION_MODEL_ID, &Id);
 346:../Src/main.c ****                 if (status != 0) {
 347:../Src/main.c **** 					debug_printf("#i VL53L0X_RdWord fail\n", i);
 348:../Src/main.c **** 					break;
 349:../Src/main.c **** 				}
 350:../Src/main.c **** 
 351:../Src/main.c ****                 status = VL53L0X_DataInit(pDev);
 352:../Src/main.c ****                 if( status == 0 ){
 353:../Src/main.c ****                     pDev->Present = 1;
 354:../Src/main.c ****                 }
 355:../Src/main.c ****                 else{
 356:../Src/main.c ****                     debug_printf("VL53L0X_DataInit %d fail\n", i);
 357:../Src/main.c ****                     break;
 358:../Src/main.c ****                 }
 359:../Src/main.c ****                 trace_printf("VL53L0X %d Present and initiated to final 0x%x\n", pDev->Id, pDev->I2
 360:../Src/main.c ****                 nDevPresent++;
 361:../Src/main.c ****                 nDevMask |= 1 << i;
 362:../Src/main.c ****                 pDev->Present = 1;
 363:../Src/main.c ****             }
 364:../Src/main.c ****             else {
 365:../Src/main.c ****                 debug_printf("#%d unknown ID %x\n", i, Id);
 366:../Src/main.c ****                 status = 1;
 367:../Src/main.c ****             }
 368:../Src/main.c ****         } while (0);
 369:../Src/main.c ****         /* if fail r can't use for any reason then put the  device back to reset */
 370:../Src/main.c ****         if (status) {
 371:../Src/main.c ****             XNUCLEO53L0A1_ResetId(i, 0);
ARM GAS  /tmp/ccNelj9t.s 			page 8


 372:../Src/main.c ****         }
 373:../Src/main.c ****     }
 374:../Src/main.c ****     /* Display detected sensor(s) */
 375:../Src/main.c ****     if( SetDisplay ){
 376:../Src/main.c ****         for(i=0; i<3; i++){
 377:../Src/main.c ****             if( VL53L0XDevs[i].Present ){
 378:../Src/main.c ****                 PresentMsg[i+1]=VL53L0XDevs[i].DevLetter;
 379:../Src/main.c ****             }
 380:../Src/main.c ****         }
 381:../Src/main.c ****         PresentMsg[0]=' ';
 382:../Src/main.c ****         XNUCLEO53L0A1_SetDisplayString(PresentMsg);
 383:../Src/main.c ****         HAL_Delay(1000);
 384:../Src/main.c ****     }
 385:../Src/main.c **** 
 386:../Src/main.c ****     return nDevPresent;
 387:../Src/main.c **** }
 388:../Src/main.c **** 
 389:../Src/main.c **** /**
 390:../Src/main.c ****  *  Setup all detected sensors for single shot mode and setup ranging configuration
 391:../Src/main.c ****  */
 392:../Src/main.c **** void SetupSingleShot(RangingConfig_e rangingConfig){
 393:../Src/main.c ****     int i;
 394:../Src/main.c ****     int status;
 395:../Src/main.c ****     uint8_t VhvSettings;
 396:../Src/main.c ****     uint8_t PhaseCal;
 397:../Src/main.c ****     uint32_t refSpadCount;
 398:../Src/main.c **** 	uint8_t isApertureSpads;
 399:../Src/main.c **** 	FixPoint1616_t signalLimit = (FixPoint1616_t)(0.25*65536);
 400:../Src/main.c **** 	FixPoint1616_t sigmaLimit = (FixPoint1616_t)(18*65536);
 401:../Src/main.c **** 	uint32_t timingBudget = 33000;
 402:../Src/main.c **** 	uint8_t preRangeVcselPeriod = 14;
 403:../Src/main.c **** 	uint8_t finalRangeVcselPeriod = 10;
 404:../Src/main.c **** 
 405:../Src/main.c ****     for( i=0; i<3; i++){
 406:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 407:../Src/main.c ****             status=VL53L0X_StaticInit(&VL53L0XDevs[i]);
 408:../Src/main.c ****             if( status ){
 409:../Src/main.c ****                 debug_printf("VL53L0X_StaticInit %d failed\n",i);
 410:../Src/main.c ****             }
 411:../Src/main.c **** 
 412:../Src/main.c ****             status = VL53L0X_PerformRefCalibration(&VL53L0XDevs[i], &VhvSettings, &PhaseCal);
 413:../Src/main.c **** 			if( status ){
 414:../Src/main.c **** 			   debug_printf("VL53L0X_PerformRefCalibration failed\n");
 415:../Src/main.c **** 			}
 416:../Src/main.c **** 
 417:../Src/main.c **** 			status = VL53L0X_PerformRefSpadManagement(&VL53L0XDevs[i], &refSpadCount, &isApertureSpads);
 418:../Src/main.c **** 			if( status ){
 419:../Src/main.c **** 			   debug_printf("VL53L0X_PerformRefSpadManagement failed\n");
 420:../Src/main.c **** 			}
 421:../Src/main.c **** 
 422:../Src/main.c ****             status = VL53L0X_SetDeviceMode(&VL53L0XDevs[i], VL53L0X_DEVICEMODE_SINGLE_RANGING); // 
 423:../Src/main.c ****             if( status ){
 424:../Src/main.c ****                debug_printf("VL53L0X_SetDeviceMode failed\n");
 425:../Src/main.c ****             }
 426:../Src/main.c **** 
 427:../Src/main.c ****             status = VL53L0X_SetLimitCheckEnable(&VL53L0XDevs[i], VL53L0X_CHECKENABLE_SIGMA_FINAL_R
 428:../Src/main.c **** 			if( status ){
ARM GAS  /tmp/ccNelj9t.s 			page 9


 429:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckEnable failed\n");
 430:../Src/main.c **** 			}
 431:../Src/main.c **** 
 432:../Src/main.c **** 			status = VL53L0X_SetLimitCheckEnable(&VL53L0XDevs[i], VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANG
 433:../Src/main.c **** 			if( status ){
 434:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckEnable failed\n");
 435:../Src/main.c **** 			}
 436:../Src/main.c **** 			/* Ranging configuration */
 437:../Src/main.c ****             switch(rangingConfig) {
 438:../Src/main.c ****             case LONG_RANGE:
 439:../Src/main.c ****             	signalLimit = (FixPoint1616_t)(0.1*65536);
 440:../Src/main.c ****             	sigmaLimit = (FixPoint1616_t)(60*65536);
 441:../Src/main.c ****             	timingBudget = 33000; //33ms
 442:../Src/main.c ****             	preRangeVcselPeriod = 18;
 443:../Src/main.c ****             	finalRangeVcselPeriod = 14;
 444:../Src/main.c ****             	break;
 445:../Src/main.c ****             case HIGH_ACCURACY:
 446:../Src/main.c **** 				signalLimit = (FixPoint1616_t)(0.25*65536); //the return signal rate limit in MCPS
 447:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(18*65536);
 448:../Src/main.c **** 				timingBudget = 200000; //200ms
 449:../Src/main.c **** 				preRangeVcselPeriod = 14; //laser pulse periods
 450:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 451:../Src/main.c **** 				break;
 452:../Src/main.c ****             case HIGH_SPEED:
 453:../Src/main.c **** 				signalLimit = (FixPoint1616_t)(0.25*65536);
 454:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(32*65536);
 455:../Src/main.c **** 				timingBudget = 20000; //20ms
 456:../Src/main.c **** 				preRangeVcselPeriod = 14;
 457:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 458:../Src/main.c **** 				break;
 459:../Src/main.c ****             default:
 460:../Src/main.c ****             	debug_printf("Not Supported");
 461:../Src/main.c ****             }
 462:../Src/main.c **** 
 463:../Src/main.c ****             status = VL53L0X_SetLimitCheckValue(&VL53L0XDevs[i],  VL53L0X_CHECKENABLE_SIGNAL_RATE_F
 464:../Src/main.c **** 			if( status ){
 465:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckValue failed\n");
 466:../Src/main.c **** 			}
 467:../Src/main.c **** 
 468:../Src/main.c **** 			status = VL53L0X_SetLimitCheckValue(&VL53L0XDevs[i],  VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE, sig
 469:../Src/main.c **** 			if( status ){
 470:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckValue failed\n");
 471:../Src/main.c **** 			}
 472:../Src/main.c **** 
 473:../Src/main.c ****             status = VL53L0X_SetMeasurementTimingBudgetMicroSeconds(&VL53L0XDevs[i],  timingBudget)
 474:../Src/main.c ****             if( status ){
 475:../Src/main.c ****                debug_printf("VL53L0X_SetMeasurementTimingBudgetMicroSeconds failed\n");
 476:../Src/main.c ****             }
 477:../Src/main.c **** 
 478:../Src/main.c ****             status = VL53L0X_SetVcselPulsePeriod(&VL53L0XDevs[i],  VL53L0X_VCSEL_PERIOD_PRE_RANGE, 
 479:../Src/main.c **** 			if( status ){
 480:../Src/main.c **** 			   debug_printf("VL53L0X_SetVcselPulsePeriod failed\n");
 481:../Src/main.c **** 			}
 482:../Src/main.c **** 
 483:../Src/main.c ****             status = VL53L0X_SetVcselPulsePeriod(&VL53L0XDevs[i],  VL53L0X_VCSEL_PERIOD_FINAL_RANGE
 484:../Src/main.c **** 			if( status ){
 485:../Src/main.c **** 			   debug_printf("VL53L0X_SetVcselPulsePeriod failed\n");
ARM GAS  /tmp/ccNelj9t.s 			page 10


 486:../Src/main.c **** 			}
 487:../Src/main.c **** 
 488:../Src/main.c **** 			status = VL53L0X_PerformRefCalibration(&VL53L0XDevs[i], &VhvSettings, &PhaseCal);
 489:../Src/main.c **** 			if( status ){
 490:../Src/main.c **** 			   debug_printf("VL53L0X_PerformRefCalibration failed\n");
 491:../Src/main.c **** 			}
 492:../Src/main.c **** 
 493:../Src/main.c ****             VL53L0XDevs[i].LeakyFirst=1;
 494:../Src/main.c ****         }
 495:../Src/main.c ****     }
 496:../Src/main.c **** }
 497:../Src/main.c **** 
 498:../Src/main.c **** char RangeToLetter(VL53L0X_Dev_t *pDev, VL53L0X_RangingMeasurementData_t *pRange){
 499:../Src/main.c ****     char c;
 500:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 501:../Src/main.c ****         if( pDev->LeakyRange < RangeLow ){
 502:../Src/main.c ****             c='_';
 503:../Src/main.c ****         }
 504:../Src/main.c ****         else if( pDev->LeakyRange < RangeMedium ){
 505:../Src/main.c ****                 c='=';
 506:../Src/main.c ****         }
 507:../Src/main.c ****         else {
 508:../Src/main.c ****             c = '~';
 509:../Src/main.c ****         }
 510:../Src/main.c **** 
 511:../Src/main.c ****     }
 512:../Src/main.c ****     else{
 513:../Src/main.c ****         c='-';
 514:../Src/main.c ****     }
 515:../Src/main.c ****     return c;
 516:../Src/main.c **** }
 517:../Src/main.c **** 
 518:../Src/main.c **** /* Store new ranging data into the device structure, apply leaky integrator if needed */
 519:../Src/main.c **** void Sensor_SetNewRange(VL53L0X_Dev_t *pDev, VL53L0X_RangingMeasurementData_t *pRange){
 520:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 521:../Src/main.c ****         if( pDev->LeakyFirst ){
 522:../Src/main.c ****             pDev->LeakyFirst = 0;
 523:../Src/main.c ****             pDev->LeakyRange = pRange->RangeMilliMeter;
 524:../Src/main.c ****         }
 525:../Src/main.c ****         else{
 526:../Src/main.c ****             pDev->LeakyRange = (pDev->LeakyRange*LeakyFactorFix8 + (256-LeakyFactorFix8)*pRange->Ra
 527:../Src/main.c ****         }
 528:../Src/main.c ****     }
 529:../Src/main.c ****     else{
 530:../Src/main.c ****         pDev->LeakyFirst = 1;
 531:../Src/main.c ****     }
 532:../Src/main.c **** }
 533:../Src/main.c **** 
 534:../Src/main.c **** void blink_led(int valeur, int* compteur){     /////modification de la led
 535:../Src/main.c ****     if (*compteur == 6){                       /////modification toutes les 6 mesures correctes du 
 536:../Src/main.c ****         HAL_TIM_Base_Stop_IT(&htim3);
 537:../Src/main.c ****         htim3.Instance->ARR = 2*valeur-1+20;   /////modification de la periode du capteur (voir wik
 538:../Src/main.c ****         HAL_TIM_Base_Start_IT(&htim3);  
 539:../Src/main.c ****         htim3.Instance->CNT = 0;               /////remise a zero du timer de la led
 540:../Src/main.c ****         *compteur = 0;                         /////remise a zero du compteur
 541:../Src/main.c ****     }
 542:../Src/main.c **** }
ARM GAS  /tmp/ccNelj9t.s 			page 11


 543:../Src/main.c **** 
 544:../Src/main.c **** #define Maxi_char_transmit 40  /////////          
 545:../Src/main.c **** #define Delay 1000  /////////
 546:../Src/main.c **** void transmit(int* i, char* buffer, int valeur){  /////transmission vers pc
 547:../Src/main.c ****     char data[10];                                /////variable stockage de la valeur du capteur
 548:../Src/main.c ****     char ligne[2];                                /////variable stockage du separateur \n
 549:../Src/main.c ****     int len;                                      /////variable longueur du buffer
 550:../Src/main.c ****     if (*i<Maxi_char_transmit-1){                 /////ajout valeur, dans data
 551:../Src/main.c ****         sprintf(data, "%d,",valeur);
 552:../Src/main.c ****     }
 553:../Src/main.c ****     else if (*i==Maxi_char_transmit-1){           /////ajout valeur dans data -> pour cloturer la s
 554:../Src/main.c ****         sprintf(data, "%d",valeur);
 555:../Src/main.c ****     }
 556:../Src/main.c ****     strcat(buffer,data);                          /////ajout valeur au buffer
 557:../Src/main.c ****     if (*i==Maxi_char_transmit-1){
 558:../Src/main.c ****         len=strlen(buffer);                       /////longueur du buffer
 559:../Src/main.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)(buffer), len, 1000); /////transmission du buffer
 560:../Src/main.c ****         sprintf(ligne, "\n");                                     /////ajout \n a ligne
 561:../Src/main.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)ligne, 1, 1000);     /////transmission pour cloturer l
 562:../Src/main.c ****         (*i)=-1;                                                  /////remise a zero du compteur
 563:../Src/main.c ****         sprintf(buffer, "");                                      /////remise a zero du buffer
 564:../Src/main.c ****         HAL_Delay(Delay);         //////necessaire pour le graphique
 565:../Src/main.c ****     }
 566:../Src/main.c **** }
 567:../Src/main.c **** 
 568:../Src/main.c **** 
 569:../Src/main.c **** /**
 570:../Src/main.c ****  * Implement the ranging demo with all modes managed through the blue button (short and long press)
 571:../Src/main.c ****  * This function implements a while loop until the blue button is pressed
 572:../Src/main.c ****  * @param UseSensorsMask Mask of any sensors to use if not only one present
 573:../Src/main.c ****  * @param rangingConfig Ranging configuration to be used (same for all sensors)
 574:../Src/main.c ****  */
 575:../Src/main.c **** int RangeDemo(int UseSensorsMask, RangingConfig_e rangingConfig){
 576:../Src/main.c ****     int over=0;
 577:../Src/main.c ****     int status;
 578:../Src/main.c ****     char StrDisplay[5];
 579:../Src/main.c ****     char c;
 580:../Src/main.c ****     int i;
 581:../Src/main.c ****     int nSensorToUse;
 582:../Src/main.c ****     int SingleSensorNo=0;
 583:../Src/main.c ****     int valeur;             ///creation variable valeur
 584:../Src/main.c ****     int s=0;                ///creation compteur
 585:../Src/main.c ****     int* compteur = NULL;   ///creation pointeur sur compteur
 586:../Src/main.c ****     compteur=&s;
 587:../Src/main.c ****     int d=0;                 ///creation compteur2
 588:../Src/main.c ****     int* compteur2 = NULL;   ///creation pointeur sur compteur2
 589:../Src/main.c ****     compteur2=&d;
 590:../Src/main.c ****     char buffer[Maxi_char_transmit*4]; /////creation du buffer
 591:../Src/main.c ****     sprintf(buffer, "");               /////mise a zero du buffer
 592:../Src/main.c **** 
 593:../Src/main.c ****     /* Setup all sensors in Single Shot mode */
 594:../Src/main.c ****     SetupSingleShot(rangingConfig);
 595:../Src/main.c **** 
 596:../Src/main.c ****     /* Which sensor to use ? */
 597:../Src/main.c ****     for(i=0, nSensorToUse=0; i<3; i++){
 598:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 599:../Src/main.c ****             nSensorToUse++;
ARM GAS  /tmp/ccNelj9t.s 			page 12


 600:../Src/main.c ****             if( nSensorToUse==1 )
 601:../Src/main.c ****                 SingleSensorNo=i;
 602:../Src/main.c ****         }
 603:../Src/main.c ****     }
 604:../Src/main.c ****     if( nSensorToUse == 0 ){
 605:../Src/main.c ****         return -1;
 606:../Src/main.c ****     }
 607:../Src/main.c **** 
 608:../Src/main.c ****     /* Start ranging until blue button is pressed */
 609:../Src/main.c ****     do{    
 610:../Src/main.c ****         if( nSensorToUse >1 ){
 611:../Src/main.c ****         	/* Multiple devices */
 612:../Src/main.c ****             strcpy(StrDisplay, "    ");
 613:../Src/main.c ****             for( i=0; i<3; i++){
 614:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 615:../Src/main.c ****                     continue;
 616:../Src/main.c ****                 /* Call All-In-One blocking API function */
 617:../Src/main.c ****                 status = VL53L0X_PerformSingleRangingMeasurement(&VL53L0XDevs[i],&RangingMeasuremen
 618:../Src/main.c ****                 if( status ){
 619:../Src/main.c ****                     HandleError(ERR_DEMO_RANGE_MULTI);
 620:../Src/main.c ****                 }
 621:../Src/main.c ****                 /* Push data logging to UART */
 622:../Src/main.c ****                 trace_printf("%d,%u,%d,%d,%d\n", VL53L0XDevs[i].Id, TimeStamp_Get(), RangingMeasure
 623:../Src/main.c ****                 /* Store new ranging distance */
 624:../Src/main.c ****                 Sensor_SetNewRange(&VL53L0XDevs[i],&RangingMeasurementData);
 625:../Src/main.c ****                 /* Translate distance in bar graph (multiple device) */
 626:../Src/main.c ****                 c = RangeToLetter(&VL53L0XDevs[i],&RangingMeasurementData);
 627:../Src/main.c ****                 StrDisplay[i+1]=c;
 628:../Src/main.c ****             }
 629:../Src/main.c ****         }
 630:../Src/main.c ****         else{
 631:../Src/main.c ****             /* only one sensor */
 632:../Src/main.c ****         	/* Call All-In-One blocking API function */
 633:../Src/main.c ****             status = VL53L0X_PerformSingleRangingMeasurement(&VL53L0XDevs[SingleSensorNo],&RangingM
 634:../Src/main.c ****             if( status ==0 ){
 635:../Src/main.c ****             	/* Push data logging to UART */
 636:../Src/main.c ****             	trace_printf("%d,%u,%d,%d,%d\n", VL53L0XDevs[SingleSensorNo].Id, TimeStamp_Get(), Rang
 637:../Src/main.c ****             	Sensor_SetNewRange(&VL53L0XDevs[SingleSensorNo],&RangingMeasurementData);
 638:../Src/main.c ****                 /* Display distance in cm */
 639:../Src/main.c ****             	if( RangingMeasurementData.RangeStatus == 0 ){  /////boucle de mesures correctes
 640:../Src/main.c ****                     *compteur+=1;                               /////incrementation du compteur
 641:../Src/main.c ****                     sprintf(StrDisplay, "%3dc",(int)VL53L0XDevs[SingleSensorNo].LeakyRange/10);  //
 642:../Src/main.c ****                     valeur=(int)VL53L0XDevs[SingleSensorNo].LeakyRange/10;   /////valeur lue par le
 643:../Src/main.c ****                     blink_led(valeur, compteur);                 /////fonction blink_led
 644:../Src/main.c ****                     transmit(compteur2, buffer, valeur);        /////fonction transmit vers pc
 645:../Src/main.c ****                     *compteur2+=1;                              /////incrementation du compteur2
 646:../Src/main.c ****                 }
 647:../Src/main.c ****                 else{                                           /////boucle de mesures incorrectes
 648:../Src/main.c ****                     sprintf(StrDisplay, "----");
 649:../Src/main.c ****                     StrDisplay[0]=VL53L0XDevs[SingleSensorNo].DevLetter;
 650:../Src/main.c ****                     //HAL_TIM_Base_Stop_IT(&htim3);             /////version courante : memoire de 
 651:../Src/main.c ****                     //htim3.Instance->ARR=2000;
 652:../Src/main.c ****                     //HAL_TIM_Base_Start_IT(&htim3);
 653:../Src/main.c ****                 }
 654:../Src/main.c ****             }
 655:../Src/main.c ****             else{
 656:../Src/main.c ****                 HandleError(ERR_DEMO_RANGE_ONE);
ARM GAS  /tmp/ccNelj9t.s 			page 13


 657:../Src/main.c ****             }
 658:../Src/main.c ****         }
 659:../Src/main.c ****         XNUCLEO53L0A1_SetDisplayString(StrDisplay);
 660:../Src/main.c ****         /* Check blue button */
 661:../Src/main.c ****         if( !BSP_GetPushButton() ){
 662:../Src/main.c ****             over=1;
 663:../Src/main.c ****             break;
 664:../Src/main.c ****         }
 665:../Src/main.c ****     }while( !over);
 666:../Src/main.c ****     /* Wait button to be un-pressed to decide if it is a short or long press */
 667:../Src/main.c ****     status=PusbButton_WaitUnPress();
 668:../Src/main.c ****     htim3.Instance->CNT=0;       /////remise a zero du timer de la led
 669:../Src/main.c ****     return status;
 670:../Src/main.c **** }
 671:../Src/main.c **** 
 672:../Src/main.c **** #if HAVE_ALARM_DEMO
 673:../Src/main.c **** struct AlrmMode_t {
 674:../Src/main.c ****     const int VL53L0X_Mode;
 675:../Src/main.c ****     const char *Name;
 676:../Src/main.c ****     uint32_t ThreshLow;
 677:../Src/main.c ****     uint32_t ThreshHigh;
 678:../Src/main.c **** };
 679:../Src/main.c **** 
 680:../Src/main.c **** struct AlrmMode_t AlarmModes[]={
 681:../Src/main.c ****         { .VL53L0X_Mode = VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW , .Name="Lo" , .ThreshLow
 682:../Src/main.c ****         { .VL53L0X_Mode = VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH, .Name= "hi", .ThreshLow
 683:../Src/main.c ****         { .VL53L0X_Mode = VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT , .Name="out", .ThreshLow
 684:../Src/main.c **** };
 685:../Src/main.c **** 
 686:../Src/main.c **** VL53L0X_Error WaitStopCompleted(VL53L0X_DEV Dev) {
 687:../Src/main.c ****     VL53L0X_Error Status = VL53L0X_ERROR_NONE;
 688:../Src/main.c ****     uint32_t StopCompleted=0;
 689:../Src/main.c ****     uint32_t LoopNb;
 690:../Src/main.c **** 
 691:../Src/main.c ****     // Wait until it finished
 692:../Src/main.c ****     // use timeout to avoid deadlock
 693:../Src/main.c ****     if (Status == VL53L0X_ERROR_NONE) {
 694:../Src/main.c ****         LoopNb = 0;
 695:../Src/main.c ****         do {
 696:../Src/main.c ****             Status = VL53L0X_GetStopCompletedStatus(Dev, &StopCompleted);
 697:../Src/main.c ****             if ((StopCompleted == 0x00) || Status != VL53L0X_ERROR_NONE) {
 698:../Src/main.c ****                 break;
 699:../Src/main.c ****             }
 700:../Src/main.c ****             LoopNb = LoopNb + 1;
 701:../Src/main.c ****             VL53L0X_PollingDelay(Dev);
 702:../Src/main.c ****         } while (LoopNb < VL53L0X_DEFAULT_MAX_LOOP);
 703:../Src/main.c **** 
 704:../Src/main.c ****         if (LoopNb >= VL53L0X_DEFAULT_MAX_LOOP) {
 705:../Src/main.c ****             Status = VL53L0X_ERROR_TIME_OUT;
 706:../Src/main.c ****         }
 707:../Src/main.c **** 
 708:../Src/main.c ****     }
 709:../Src/main.c **** 
 710:../Src/main.c ****     return Status;
 711:../Src/main.c **** }
 712:../Src/main.c **** 
 713:../Src/main.c **** 
ARM GAS  /tmp/ccNelj9t.s 			page 14


 714:../Src/main.c **** void AlarmDemo(void){
 715:../Src/main.c ****     VL53L0X_Dev_t *pDev;
 716:../Src/main.c ****     uint8_t VhvSettings;
 717:../Src/main.c ****     uint8_t PhaseCal;
 718:../Src/main.c ****     uint32_t refSpadCount;
 719:../Src/main.c **** 	uint8_t isApertureSpads;
 720:../Src/main.c **** 	VL53L0X_RangingMeasurementData_t RangingMeasurementData;
 721:../Src/main.c ****     int status;
 722:../Src/main.c ****     int Over=0;
 723:../Src/main.c ****     int Mode=0;
 724:../Src/main.c ****     char StrDisplay[5]="----";
 725:../Src/main.c **** 
 726:../Src/main.c ****     /* Only center device is used */
 727:../Src/main.c ****     pDev=&VL53L0XDevs[1];
 728:../Src/main.c **** 
 729:../Src/main.c **** 
 730:../Src/main.c ****     /* configure BSP/MCU center sensor interrupt */
 731:../Src/main.c ****     VL53L0A1_EXTI_IOConfigure(XNUCLEO53L0A1_DEV_CENTER, 0, 0);
 732:../Src/main.c ****     XNUCLEO53L0A1_SetIntrStateId(1, XNUCLEO53L0A1_DEV_CENTER);
 733:../Src/main.c **** 
 734:../Src/main.c ****     /* Initialize the device in continuous ranging mode */
 735:../Src/main.c **** 	VL53L0X_StaticInit(pDev);
 736:../Src/main.c **** 	VL53L0X_PerformRefCalibration(pDev, &VhvSettings, &PhaseCal);
 737:../Src/main.c **** 	VL53L0X_PerformRefSpadManagement(pDev, &refSpadCount, &isApertureSpads);
 738:../Src/main.c **** 	VL53L0X_SetInterMeasurementPeriodMilliSeconds(pDev, 250);
 739:../Src/main.c **** 	VL53L0X_SetDeviceMode(pDev, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING);
 740:../Src/main.c **** 
 741:../Src/main.c ****     do{
 742:../Src/main.c ****        /* set sensor interrupt mode */
 743:../Src/main.c ****        VL53L0X_StopMeasurement(pDev);           // it is safer to do this while sensor is stopped
 744:../Src/main.c ****        VL53L0X_SetInterruptThresholds(pDev, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING ,  AlarmModes[Mod
 745:../Src/main.c ****        status = VL53L0X_SetGpioConfig(pDev, 0, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING, AlarmModes[Mo
 746:../Src/main.c ****        status = VL53L0X_ClearInterruptMask(pDev, -1); // clear interrupt pending if any
 747:../Src/main.c **** 
 748:../Src/main.c ****        /* Start continuous ranging */
 749:../Src/main.c ****        VL53L0X_StartMeasurement(pDev);
 750:../Src/main.c ****        IntrCounts[1]=0;
 751:../Src/main.c **** 
 752:../Src/main.c ****        /* Check for interrupt */
 753:../Src/main.c ****        do{
 754:../Src/main.c ****            __WFI();
 755:../Src/main.c ****            /* Interrupt received */
 756:../Src/main.c ****            if( IntrCounts[1] !=0 ){
 757:../Src/main.c ****         	   /* Reset interrupt counter */
 758:../Src/main.c ****                IntrCounts[1]=0;
 759:../Src/main.c ****                /* Get ranging data and display distance*/
 760:../Src/main.c ****                VL53L0X_GetRangingMeasurementData(pDev, &RangingMeasurementData);
 761:../Src/main.c ****                sprintf(StrDisplay, "%3dc",(int)RangingMeasurementData.RangeMilliMeter/10);
 762:../Src/main.c ****                /* Clear interrupt */
 763:../Src/main.c ****                status = VL53L0X_ClearInterruptMask(pDev, -1);
 764:../Src/main.c ****                /* keep display for at least 100ms otherwise user may never see it on display*/
 765:../Src/main.c ****                XNUCLEO53L0A1_SetDisplayString(StrDisplay);
 766:../Src/main.c ****                HAL_Delay(100);
 767:../Src/main.c ****            }
 768:../Src/main.c ****            else{
 769:../Src/main.c ****         	   /* No interrupt received => Display alarm mode */
 770:../Src/main.c ****                XNUCLEO53L0A1_SetDisplayString(AlarmModes[Mode].Name);
ARM GAS  /tmp/ccNelj9t.s 			page 15


 771:../Src/main.c ****            }
 772:../Src/main.c ****            /* Check blue button */
 773:../Src/main.c ****            if( !BSP_GetPushButton() ){
 774:../Src/main.c ****                break;
 775:../Src/main.c ****            }
 776:../Src/main.c ****        }while(1);
 777:../Src/main.c ****        /* Wait button to be released to decide if it is a short or long press */
 778:../Src/main.c ****        status=PusbButton_WaitUnPress();
 779:../Src/main.c ****        /* Long press => stop this demo */
 780:../Src/main.c ****        if( status )
 781:../Src/main.c ****            Over =1;
 782:../Src/main.c ****        /* Short press => change alarm mode */
 783:../Src/main.c ****        Mode=(Mode+1)%ARRAY_SIZE(AlarmModes);
 784:../Src/main.c ****     }while( !Over );
 785:../Src/main.c **** 
 786:../Src/main.c ****     /* Stop continuous ranging */
 787:../Src/main.c ****     VL53L0X_StopMeasurement(pDev);
 788:../Src/main.c **** 
 789:../Src/main.c ****     /* Ensure device is ready for other commands */
 790:../Src/main.c ****     WaitStopCompleted(pDev);
 791:../Src/main.c **** 
 792:../Src/main.c ****     /* Disable configuration of BSP/MCU center sensor interrupt */
 793:../Src/main.c ****     XNUCLEO53L0A1_SetIntrStateId(0, XNUCLEO53L0A1_DEV_CENTER);
 794:../Src/main.c ****     VL53L0A1_EXTI_IOUnconfigure(XNUCLEO53L0A1_DEV_CENTER);
 795:../Src/main.c **** }
 796:../Src/main.c **** #endif
 797:../Src/main.c **** 
 798:../Src/main.c **** void ResetAndDetectSensor(int SetDisplay){
 799:../Src/main.c ****     int nSensor;
 800:../Src/main.c ****     nSensor = DetectSensors(SetDisplay);
 801:../Src/main.c ****     /* at least one sensor and if one it must be the built-in one  */
 802:../Src/main.c ****     if( (nSensor <=0) ||  (nSensor ==1 && VL53L0XDevs[1].Present==0) ){
 803:../Src/main.c ****         HandleError(ERR_DETECT);
 804:../Src/main.c ****     }
 805:../Src/main.c **** }
 806:../Src/main.c **** 
 807:../Src/main.c **** //XL maintenance
 808:../Src/main.c **** XL_Interface interface;
 809:../Src/main.c **** 
 810:../Src/main.c **** uint8_t XL_320_Send_HAL(uint8_t *data, uint16_t size, uint32_t timeout){
 811:../Src/main.c ****   HAL_StatusTypeDef status = HAL_UART_Transmit(&huart1, data, size, timeout);
 812:../Src/main.c ****   return (status==HAL_OK)?0:1;
 813:../Src/main.c **** }
 814:../Src/main.c **** 
 815:../Src/main.c **** void XL_320_Set_Direction_HAL(XL_Direction dir){
 816:../Src/main.c ****   HAL_GPIO_WritePin(USART1_DIR_GPIO_Port, USART1_DIR_Pin, (dir==XL_SEND)?GPIO_PIN_SET:GPIO_PIN_RESE
 817:../Src/main.c **** }
 818:../Src/main.c **** 
 819:../Src/main.c **** uint8_t XL_320_Receive_HAL(uint8_t *buffer, uint16_t size, uint32_t timeout){
 820:../Src/main.c ****   HAL_StatusTypeDef status = HAL_UART_Receive(&huart1, buffer, size, timeout);
 821:../Src/main.c ****   return (status==HAL_OK)?0:1;
 822:../Src/main.c **** }
 823:../Src/main.c **** 
 824:../Src/main.c **** void XL_320_Delay_HAL(uint32_t t){
  30              		.loc 1 824 0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccNelj9t.s 			page 16


  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              	.LVL0:
  35 0000 08B5     		push	{r3, lr}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 8
  38              		.cfi_offset 3, -8
  39              		.cfi_offset 14, -4
 825:../Src/main.c ****   HAL_Delay(t);
  40              		.loc 1 825 0
  41 0002 FFF7FEFF 		bl	HAL_Delay
  42              	.LVL1:
  43 0006 08BD     		pop	{r3, pc}
  44              		.cfi_endproc
  45              	.LFE131:
  47              		.section	.text.XL_320_Send_HAL,"ax",%progbits
  48              		.align	2
  49              		.global	XL_320_Send_HAL
  50              		.thumb
  51              		.thumb_func
  53              	XL_320_Send_HAL:
  54              	.LFB128:
 810:../Src/main.c ****   HAL_StatusTypeDef status = HAL_UART_Transmit(&huart1, data, size, timeout);
  55              		.loc 1 810 0
  56              		.cfi_startproc
  57              		@ args = 0, pretend = 0, frame = 0
  58              		@ frame_needed = 0, uses_anonymous_args = 0
  59              	.LVL2:
  60 0000 08B5     		push	{r3, lr}
  61              	.LCFI1:
  62              		.cfi_def_cfa_offset 8
  63              		.cfi_offset 3, -8
  64              		.cfi_offset 14, -4
 811:../Src/main.c ****   return (status==HAL_OK)?0:1;
  65              		.loc 1 811 0
  66 0002 1346     		mov	r3, r2
  67 0004 0A46     		mov	r2, r1
  68              	.LVL3:
  69 0006 0146     		mov	r1, r0
  70              	.LVL4:
  71 0008 0348     		ldr	r0, .L5
  72              	.LVL5:
  73 000a FFF7FEFF 		bl	HAL_UART_Transmit
  74              	.LVL6:
 813:../Src/main.c **** 
  75              		.loc 1 813 0
  76 000e 0030     		adds	r0, r0, #0
  77              	.LVL7:
  78 0010 18BF     		it	ne
  79 0012 0120     		movne	r0, #1
  80 0014 08BD     		pop	{r3, pc}
  81              	.L6:
  82 0016 00BF     		.align	2
  83              	.L5:
  84 0018 00000000 		.word	huart1
  85              		.cfi_endproc
  86              	.LFE128:
  88              		.section	.text.XL_320_Set_Direction_HAL,"ax",%progbits
ARM GAS  /tmp/ccNelj9t.s 			page 17


  89              		.align	2
  90              		.global	XL_320_Set_Direction_HAL
  91              		.thumb
  92              		.thumb_func
  94              	XL_320_Set_Direction_HAL:
  95              	.LFB129:
 815:../Src/main.c ****   HAL_GPIO_WritePin(USART1_DIR_GPIO_Port, USART1_DIR_Pin, (dir==XL_SEND)?GPIO_PIN_SET:GPIO_PIN_RESE
  96              		.loc 1 815 0
  97              		.cfi_startproc
  98              		@ args = 0, pretend = 0, frame = 0
  99              		@ frame_needed = 0, uses_anonymous_args = 0
 100              	.LVL8:
 101 0000 08B5     		push	{r3, lr}
 102              	.LCFI2:
 103              		.cfi_def_cfa_offset 8
 104              		.cfi_offset 3, -8
 105              		.cfi_offset 14, -4
 816:../Src/main.c **** }
 106              		.loc 1 816 0
 107 0002 B0FA80F2 		clz	r2, r0
 108 0006 5209     		lsrs	r2, r2, #5
 109 0008 4FF40071 		mov	r1, #512
 110 000c 0148     		ldr	r0, .L9
 111              	.LVL9:
 112 000e FFF7FEFF 		bl	HAL_GPIO_WritePin
 113              	.LVL10:
 114 0012 08BD     		pop	{r3, pc}
 115              	.L10:
 116              		.align	2
 117              	.L9:
 118 0014 00080240 		.word	1073874944
 119              		.cfi_endproc
 120              	.LFE129:
 122              		.section	.text.XL_320_Receive_HAL,"ax",%progbits
 123              		.align	2
 124              		.global	XL_320_Receive_HAL
 125              		.thumb
 126              		.thumb_func
 128              	XL_320_Receive_HAL:
 129              	.LFB130:
 819:../Src/main.c ****   HAL_StatusTypeDef status = HAL_UART_Receive(&huart1, buffer, size, timeout);
 130              		.loc 1 819 0
 131              		.cfi_startproc
 132              		@ args = 0, pretend = 0, frame = 0
 133              		@ frame_needed = 0, uses_anonymous_args = 0
 134              	.LVL11:
 135 0000 08B5     		push	{r3, lr}
 136              	.LCFI3:
 137              		.cfi_def_cfa_offset 8
 138              		.cfi_offset 3, -8
 139              		.cfi_offset 14, -4
 820:../Src/main.c ****   return (status==HAL_OK)?0:1;
 140              		.loc 1 820 0
 141 0002 1346     		mov	r3, r2
 142 0004 0A46     		mov	r2, r1
 143              	.LVL12:
 144 0006 0146     		mov	r1, r0
ARM GAS  /tmp/ccNelj9t.s 			page 18


 145              	.LVL13:
 146 0008 0348     		ldr	r0, .L13
 147              	.LVL14:
 148 000a FFF7FEFF 		bl	HAL_UART_Receive
 149              	.LVL15:
 822:../Src/main.c **** 
 150              		.loc 1 822 0
 151 000e 0030     		adds	r0, r0, #0
 152              	.LVL16:
 153 0010 18BF     		it	ne
 154 0012 0120     		movne	r0, #1
 155 0014 08BD     		pop	{r3, pc}
 156              	.L14:
 157 0016 00BF     		.align	2
 158              	.L13:
 159 0018 00000000 		.word	huart1
 160              		.cfi_endproc
 161              	.LFE130:
 163              		.section	.text.MX_GPIO_Init,"ax",%progbits
 164              		.align	2
 165              		.thumb
 166              		.thumb_func
 168              	MX_GPIO_Init:
 169              	.LFB138:
 826:../Src/main.c **** }
 827:../Src/main.c **** /* USER CODE END 0 */
 828:../Src/main.c **** 
 829:../Src/main.c **** int main(void)
 830:../Src/main.c **** {
 831:../Src/main.c **** 
 832:../Src/main.c ****   /* USER CODE BEGIN 1 */
 833:../Src/main.c ****   int ExitWithLongPress;
 834:../Src/main.c ****   RangingConfig_e RangingConfig = LONG_RANGE;
 835:../Src/main.c ****   DemoMode_e DemoMode = RANGE_VALUE;
 836:../Src/main.c ****   int UseSensorsMask = 1<<XNUCLEO53L0A1_DEV_CENTER;
 837:../Src/main.c ****   /* USER CODE END 1 */
 838:../Src/main.c **** 
 839:../Src/main.c ****   /* MCU Configuration----------------------------------------------------------*/
 840:../Src/main.c **** 
 841:../Src/main.c ****   /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
 842:../Src/main.c ****   HAL_Init();
 843:../Src/main.c **** 
 844:../Src/main.c ****   /* Configure the system clock */
 845:../Src/main.c ****   SystemClock_Config();
 846:../Src/main.c **** 
 847:../Src/main.c ****   /* Initialize all configured peripherals */
 848:../Src/main.c ****   MX_GPIO_Init();
 849:../Src/main.c ****   SystemClock_Config();
 850:../Src/main.c ****   MX_I2C1_Init();
 851:../Src/main.c ****   MX_TIM3_Init();
 852:../Src/main.c ****   MX_USART2_UART_Init();
 853:../Src/main.c ****   MX_USART1_UART_Init();
 854:../Src/main.c **** 
 855:../Src/main.c ****   /* USER CODE BEGIN 2 */
 856:../Src/main.c ****   XNUCLEO53L0A1_Init();
 857:../Src/main.c ****   uart_printf(WelcomeMsg);
 858:../Src/main.c ****   XNUCLEO53L0A1_SetDisplayString("53L0");
ARM GAS  /tmp/ccNelj9t.s 			page 19


 859:../Src/main.c ****   HAL_Delay(WelcomeTime);
 860:../Src/main.c ****   ResetAndDetectSensor(1);
 861:../Src/main.c ****   HAL_TIM_Base_Start_IT(&htim3); //£
 862:../Src/main.c **** 
 863:../Src/main.c ****   /* Set VL53L0X API trace level */
 864:../Src/main.c ****   VL53L0X_trace_config(NULL, TRACE_MODULE_NONE, TRACE_LEVEL_NONE, TRACE_FUNCTION_NONE); // No Trace
 865:../Src/main.c ****   //VL53L0X_trace_config(NULL,TRACE_MODULE_ALL, TRACE_LEVEL_ALL, TRACE_FUNCTION_ALL); // Full trace
 866:../Src/main.c **** 
 867:../Src/main.c ****   //XL maintenance ----------------------
 868:../Src/main.c ****   interface.send = XL_320_Send_HAL;
 869:../Src/main.c ****   interface.set_direction = XL_320_Set_Direction_HAL;
 870:../Src/main.c ****   interface.receive = XL_320_Receive_HAL;
 871:../Src/main.c ****   interface.delay = XL_320_Delay_HAL;
 872:../Src/main.c **** 
 873:../Src/main.c ****   HAL_Delay(1000);
 874:../Src/main.c **** 
 875:../Src/main.c ****   XL broadcast = (XL) {.interface = &interface, .id = XL_BROADCAST};
 876:../Src/main.c **** 
 877:../Src/main.c ****   XL servo;
 878:../Src/main.c ****   uint16_t nb_servos = 0;
 879:../Src/main.c ****   uint16_t positionGet;
 880:../Src/main.c ****   uint16_t positionSet = 0;
 881:../Src/main.c **** 
 882:../Src/main.c ****   XL_Discover(&interface, &servo, 1, &nb_servos);
 883:../Src/main.c ****   #if CONFIG==1
 884:../Src/main.c ****     XL_Configure_ID(&servo[0],3);
 885:../Src/main.c ****   #endif
 886:../Src/main.c ****   XL_Say_Hello(&servo);
 887:../Src/main.c ****   HAL_Delay(1000);
 888:../Src/main.c ****   XL_Power_On(&broadcast, XL_NOW);
 889:../Src/main.c ****   /* USER CODE END 2 */
 890:../Src/main.c **** 
 891:../Src/main.c ****   /* USER CODE BEGIN 3 */
 892:../Src/main.c ****   /* Infinite loop */
 893:../Src/main.c ****   /* USER CODE BEGIN WHILE */
 894:../Src/main.c ****   while (1)
 895:../Src/main.c ****   {
 896:../Src/main.c ****   /* USER CODE END WHILE */
 897:../Src/main.c ****       /* Display demo mode */
 898:../Src/main.c ****       XNUCLEO53L0A1_SetDisplayString(DemoModeTxt[DemoMode]);
 899:../Src/main.c ****       HAL_Delay(ModeChangeDispTime);
 900:../Src/main.c **** 
 901:../Src/main.c ****       /* Display Ranging config */
 902:../Src/main.c **** 	  XNUCLEO53L0A1_SetDisplayString(RangingConfigTxt[RangingConfig]);
 903:../Src/main.c **** 	  HAL_Delay(ModeChangeDispTime);
 904:../Src/main.c **** 
 905:../Src/main.c **** 	  /* Reset and Detect all sensors */
 906:../Src/main.c ****       ResetAndDetectSensor(0);
 907:../Src/main.c **** 
 908:../Src/main.c ****       /* Reset Timestamping */
 909:../Src/main.c ****       TimeStamp_Reset();
 910:../Src/main.c **** 
 911:../Src/main.c **** #if HAVE_ALARM_DEMO
 912:../Src/main.c ****       XNUCLEO53L0A1_SetDisplayString(TxtAlarm);
 913:../Src/main.c ****       HAL_Delay(ModeChangeDispTime);
 914:../Src/main.c ****       ResetAndDetectSensor(0);
 915:../Src/main.c ****       AlarmDemo();
ARM GAS  /tmp/ccNelj9t.s 			page 20


 916:../Src/main.c **** #else
 917:../Src/main.c **** 
 918:../Src/main.c ****       /* Start Ranging demo */
 919:../Src/main.c ****       ExitWithLongPress = RangeDemo(UseSensorsMask, RangingConfig);
 920:../Src/main.c **** 
 921:../Src/main.c ****       /* Blue button has been pressed (long or short press) */
 922:../Src/main.c ****       if(ExitWithLongPress){
 923:../Src/main.c ****     	  /* Long press : change demo mode if multiple sensors present*/
 924:../Src/main.c ****     	  if( nDevPresent >1 ){
 925:../Src/main.c ****     		  /* If more than one sensor is present then toggle demo mode */
 926:../Src/main.c ****     		  DemoMode = (DemoMode == RANGE_VALUE) ? BAR_GRAPH : RANGE_VALUE;
 927:../Src/main.c ****     		  UseSensorsMask = (DemoMode == BAR_GRAPH) ? 0x7 : 1<<XNUCLEO53L0A1_DEV_CENTER;
 928:../Src/main.c ****     	  }
 929:../Src/main.c ****       } else {
 930:../Src/main.c ****     	  /* Short press : change ranging config */
 931:../Src/main.c ****     	  RangingConfig = (RangingConfig == LONG_RANGE) ? HIGH_SPEED : ((RangingConfig == HIGH_SPEED) 
 932:../Src/main.c ****       }
 933:../Src/main.c **** #endif
 934:../Src/main.c ****   }
 935:../Src/main.c ****   /* USER CODE END 3 */
 936:../Src/main.c **** 
 937:../Src/main.c **** }
 938:../Src/main.c **** 
 939:../Src/main.c **** /** System Clock Configuration
 940:../Src/main.c **** */
 941:../Src/main.c **** void SystemClock_Config(void)
 942:../Src/main.c **** {
 943:../Src/main.c **** 
 944:../Src/main.c ****   RCC_OscInitTypeDef RCC_OscInitStruct;
 945:../Src/main.c ****   RCC_ClkInitTypeDef RCC_ClkInitStruct;
 946:../Src/main.c **** 
 947:../Src/main.c ****   __PWR_CLK_ENABLE();
 948:../Src/main.c **** 
 949:../Src/main.c ****   __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 950:../Src/main.c **** 
 951:../Src/main.c ****   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 952:../Src/main.c ****   RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 953:../Src/main.c ****   RCC_OscInitStruct.HSICalibrationValue = 6;
 954:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 955:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 956:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLM = 16;
 957:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLN = 336;
 958:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 959:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLQ = 7;
 960:../Src/main.c ****   HAL_RCC_OscConfig(&RCC_OscInitStruct);
 961:../Src/main.c **** 
 962:../Src/main.c ****   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1;
 963:../Src/main.c ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 964:../Src/main.c ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 965:../Src/main.c ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 966:../Src/main.c ****   RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 967:../Src/main.c ****   HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 968:../Src/main.c **** 
 969:../Src/main.c **** }
 970:../Src/main.c **** 
 971:../Src/main.c **** /* I2C1 init function */
 972:../Src/main.c **** void MX_I2C1_Init(void)
ARM GAS  /tmp/ccNelj9t.s 			page 21


 973:../Src/main.c **** {
 974:../Src/main.c **** 
 975:../Src/main.c ****   hi2c1.Instance = I2C1;
 976:../Src/main.c ****   hi2c1.Init.ClockSpeed = 400000;
 977:../Src/main.c ****   hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
 978:../Src/main.c ****   hi2c1.Init.OwnAddress1 = 0;
 979:../Src/main.c ****   hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 980:../Src/main.c ****   hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLED;
 981:../Src/main.c ****   hi2c1.Init.OwnAddress2 = 0;
 982:../Src/main.c ****   hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLED;
 983:../Src/main.c ****   hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLED;
 984:../Src/main.c ****   HAL_I2C_Init(&hi2c1);
 985:../Src/main.c **** 
 986:../Src/main.c **** }
 987:../Src/main.c **** 
 988:../Src/main.c **** /* TIM3 init function */
 989:../Src/main.c **** void MX_TIM3_Init(void)
 990:../Src/main.c **** {
 991:../Src/main.c **** 
 992:../Src/main.c ****   TIM_ClockConfigTypeDef sClockSourceConfig;
 993:../Src/main.c ****   TIM_MasterConfigTypeDef sMasterConfig;
 994:../Src/main.c **** 
 995:../Src/main.c ****   htim3.Instance = TIM3;
 996:../Src/main.c ****   htim3.Init.Prescaler = 42000-1;
 997:../Src/main.c ****   htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 998:../Src/main.c ****   htim3.Init.Period = 1000-1;
 999:../Src/main.c ****   htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
1000:../Src/main.c ****   HAL_TIM_Base_Init(&htim3);
1001:../Src/main.c **** 
1002:../Src/main.c ****   sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
1003:../Src/main.c ****   HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);
1004:../Src/main.c **** 
1005:../Src/main.c ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
1006:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
1007:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);
1008:../Src/main.c **** 
1009:../Src/main.c **** }
1010:../Src/main.c **** 
1011:../Src/main.c **** /* USART1 init function */
1012:../Src/main.c **** void MX_USART1_UART_Init(void)
1013:../Src/main.c **** {
1014:../Src/main.c **** 
1015:../Src/main.c ****   huart1.Instance = USART1;
1016:../Src/main.c ****   huart1.Init.BaudRate = 1000000;
1017:../Src/main.c ****   huart1.Init.WordLength = UART_WORDLENGTH_8B;
1018:../Src/main.c ****   huart1.Init.StopBits = UART_STOPBITS_1;
1019:../Src/main.c ****   huart1.Init.Parity = UART_PARITY_NONE;
1020:../Src/main.c ****   huart1.Init.Mode = UART_MODE_TX_RX;
1021:../Src/main.c ****   huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
1022:../Src/main.c ****   huart1.Init.OverSampling = UART_OVERSAMPLING_16;
1023:../Src/main.c ****   HAL_UART_Init(&huart1);
1024:../Src/main.c **** 
1025:../Src/main.c **** }
1026:../Src/main.c **** 
1027:../Src/main.c **** /* USART2 init function */
1028:../Src/main.c **** void MX_USART2_UART_Init(void)
1029:../Src/main.c **** {
ARM GAS  /tmp/ccNelj9t.s 			page 22


1030:../Src/main.c **** 
1031:../Src/main.c ****   huart2.Instance = USART2;
1032:../Src/main.c ****   huart2.Init.BaudRate = 115200;
1033:../Src/main.c ****   huart2.Init.WordLength = UART_WORDLENGTH_8B;
1034:../Src/main.c ****   huart2.Init.StopBits = UART_STOPBITS_1;
1035:../Src/main.c ****   huart2.Init.Parity = UART_PARITY_NONE;
1036:../Src/main.c ****   huart2.Init.Mode = UART_MODE_TX_RX;
1037:../Src/main.c ****   huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
1038:../Src/main.c ****   huart2.Init.OverSampling = UART_OVERSAMPLING_16;
1039:../Src/main.c ****   HAL_UART_Init(&huart2);
1040:../Src/main.c **** 
1041:../Src/main.c **** }
1042:../Src/main.c **** 
1043:../Src/main.c **** /** Configure pins as 
1044:../Src/main.c ****         * Analog 
1045:../Src/main.c ****         * Input 
1046:../Src/main.c ****         * Output
1047:../Src/main.c ****         * EVENT_OUT
1048:../Src/main.c ****         * EXTI
1049:../Src/main.c ****         * Free pins are configured automatically as Analog (this feature is enabled through 
1050:../Src/main.c ****         * the Code Generation settings)
1051:../Src/main.c **** */
1052:../Src/main.c **** void MX_GPIO_Init(void)
1053:../Src/main.c **** {
 170              		.loc 1 1053 0
 171              		.cfi_startproc
 172              		@ args = 0, pretend = 0, frame = 24
 173              		@ frame_needed = 0, uses_anonymous_args = 0
 174 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 175              	.LCFI4:
 176              		.cfi_def_cfa_offset 24
 177              		.cfi_offset 4, -24
 178              		.cfi_offset 5, -20
 179              		.cfi_offset 6, -16
 180              		.cfi_offset 7, -12
 181              		.cfi_offset 8, -8
 182              		.cfi_offset 14, -4
 183 0004 86B0     		sub	sp, sp, #24
 184              	.LCFI5:
 185              		.cfi_def_cfa_offset 48
1054:../Src/main.c **** 
1055:../Src/main.c ****   GPIO_InitTypeDef GPIO_InitStruct;
1056:../Src/main.c **** 
1057:../Src/main.c ****   /* GPIO Ports Clock Enable */
1058:../Src/main.c ****   __GPIOC_CLK_ENABLE();
 186              		.loc 1 1058 0
 187 0006 324B     		ldr	r3, .L17
 188 0008 1A6B     		ldr	r2, [r3, #48]
 189 000a 42F00402 		orr	r2, r2, #4
 190 000e 1A63     		str	r2, [r3, #48]
1059:../Src/main.c ****   __GPIOH_CLK_ENABLE();
 191              		.loc 1 1059 0
 192 0010 1A6B     		ldr	r2, [r3, #48]
 193 0012 42F08002 		orr	r2, r2, #128
 194 0016 1A63     		str	r2, [r3, #48]
1060:../Src/main.c ****   __GPIOA_CLK_ENABLE();
 195              		.loc 1 1060 0
ARM GAS  /tmp/ccNelj9t.s 			page 23


 196 0018 1A6B     		ldr	r2, [r3, #48]
 197 001a 42F00102 		orr	r2, r2, #1
 198 001e 1A63     		str	r2, [r3, #48]
1061:../Src/main.c ****   __GPIOB_CLK_ENABLE();
 199              		.loc 1 1061 0
 200 0020 1A6B     		ldr	r2, [r3, #48]
 201 0022 42F00202 		orr	r2, r2, #2
 202 0026 1A63     		str	r2, [r3, #48]
1062:../Src/main.c ****   __GPIOD_CLK_ENABLE();
 203              		.loc 1 1062 0
 204 0028 1A6B     		ldr	r2, [r3, #48]
 205 002a 42F00802 		orr	r2, r2, #8
 206 002e 1A63     		str	r2, [r3, #48]
1063:../Src/main.c **** 
1064:../Src/main.c ****   /*Configure GPIO pin : PC13 */
1065:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_13;
 207              		.loc 1 1065 0
 208 0030 4FF40053 		mov	r3, #8192
 209 0034 0193     		str	r3, [sp, #4]
1066:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 210              		.loc 1 1066 0
 211 0036 0024     		movs	r4, #0
 212 0038 0294     		str	r4, [sp, #8]
1067:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 213              		.loc 1 1067 0
 214 003a 0394     		str	r4, [sp, #12]
1068:../Src/main.c ****   HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 215              		.loc 1 1068 0
 216 003c 254E     		ldr	r6, .L17+4
 217 003e 01A9     		add	r1, sp, #4
 218 0040 3046     		mov	r0, r6
 219 0042 FFF7FEFF 		bl	HAL_GPIO_Init
 220              	.LVL17:
1069:../Src/main.c **** 
1070:../Src/main.c ****   /*Configure GPIO pins : PC0 PC1 PC2 PC3 
1071:../Src/main.c ****                            PC4 PC5 PC6 PC7 
1072:../Src/main.c ****                            PC8 PC10 PC11 PC12 */
1073:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
 221              		.loc 1 1073 0
 222 0046 41F6FF53 		movw	r3, #7679
 223 004a 0193     		str	r3, [sp, #4]
1074:../Src/main.c ****                           |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7 
1075:../Src/main.c ****                           |GPIO_PIN_8|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
1076:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 224              		.loc 1 1076 0
 225 004c 0325     		movs	r5, #3
 226 004e 0295     		str	r5, [sp, #8]
1077:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 227              		.loc 1 1077 0
 228 0050 0394     		str	r4, [sp, #12]
1078:../Src/main.c ****   HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 229              		.loc 1 1078 0
 230 0052 01A9     		add	r1, sp, #4
 231 0054 3046     		mov	r0, r6
 232 0056 FFF7FEFF 		bl	HAL_GPIO_Init
 233              	.LVL18:
1079:../Src/main.c **** 
ARM GAS  /tmp/ccNelj9t.s 			page 24


1080:../Src/main.c ****   /*Configure GPIO pin Output Level */
1081:../Src/main.c ****   HAL_GPIO_WritePin(USART1_DIR_GPIO_Port, USART1_DIR_Pin, GPIO_PIN_RESET);
 234              		.loc 1 1081 0
 235 005a 2246     		mov	r2, r4
 236 005c 4FF40071 		mov	r1, #512
 237 0060 3046     		mov	r0, r6
 238 0062 FFF7FEFF 		bl	HAL_GPIO_WritePin
 239              	.LVL19:
1082:../Src/main.c **** 
1083:../Src/main.c ****   /*Configure GPIO pins : PA0 PA1 PA4 PA6 
1084:../Src/main.c ****                            PA7 PA8 PA11 PA12 
1085:../Src/main.c ****                            PA15 */
1086:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_6 
 240              		.loc 1 1086 0
 241 0066 49F6D313 		movw	r3, #39379
 242 006a 0193     		str	r3, [sp, #4]
1087:../Src/main.c ****                           |GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12 
1088:../Src/main.c ****                           |GPIO_PIN_15;
1089:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 243              		.loc 1 1089 0
 244 006c 0295     		str	r5, [sp, #8]
1090:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 245              		.loc 1 1090 0
 246 006e 0394     		str	r4, [sp, #12]
1091:../Src/main.c ****   HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 247              		.loc 1 1091 0
 248 0070 DFF86C80 		ldr	r8, .L17+16
 249 0074 01A9     		add	r1, sp, #4
 250 0076 4046     		mov	r0, r8
 251 0078 FFF7FEFF 		bl	HAL_GPIO_Init
 252              	.LVL20:
1092:../Src/main.c **** 
1093:../Src/main.c ****   /*Configure GPIO pin : PA5 */
1094:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_5;
 253              		.loc 1 1094 0
 254 007c 2023     		movs	r3, #32
 255 007e 0193     		str	r3, [sp, #4]
1095:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 256              		.loc 1 1095 0
 257 0080 0127     		movs	r7, #1
 258 0082 0297     		str	r7, [sp, #8]
1096:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 259              		.loc 1 1096 0
 260 0084 0394     		str	r4, [sp, #12]
1097:../Src/main.c ****   GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 261              		.loc 1 1097 0
 262 0086 0494     		str	r4, [sp, #16]
1098:../Src/main.c ****   HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 263              		.loc 1 1098 0
 264 0088 01A9     		add	r1, sp, #4
 265 008a 4046     		mov	r0, r8
 266 008c FFF7FEFF 		bl	HAL_GPIO_Init
 267              	.LVL21:
1099:../Src/main.c **** 
1100:../Src/main.c ****   /*Configure GPIO pins : PB0 PB1 PB2 PB10 
1101:../Src/main.c ****                            PB12 PB13 PB14 PB15 
1102:../Src/main.c ****                            PB4 PB5 PB6 PB7 */
ARM GAS  /tmp/ccNelj9t.s 			page 25


1103:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10 
 268              		.loc 1 1103 0
 269 0090 4FF2F743 		movw	r3, #62711
 270 0094 0193     		str	r3, [sp, #4]
1104:../Src/main.c ****                           |GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15 
1105:../Src/main.c ****                           |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
1106:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 271              		.loc 1 1106 0
 272 0096 0295     		str	r5, [sp, #8]
1107:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 273              		.loc 1 1107 0
 274 0098 0394     		str	r4, [sp, #12]
1108:../Src/main.c ****   HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 275              		.loc 1 1108 0
 276 009a 01A9     		add	r1, sp, #4
 277 009c 0E48     		ldr	r0, .L17+8
 278 009e FFF7FEFF 		bl	HAL_GPIO_Init
 279              	.LVL22:
1109:../Src/main.c **** 
1110:../Src/main.c ****   /*Configure GPIO pin : PC9 */
1111:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_9;
 280              		.loc 1 1111 0
 281 00a2 4FF40073 		mov	r3, #512
 282 00a6 0193     		str	r3, [sp, #4]
1112:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 283              		.loc 1 1112 0
 284 00a8 0297     		str	r7, [sp, #8]
1113:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 285              		.loc 1 1113 0
 286 00aa 0394     		str	r4, [sp, #12]
1114:../Src/main.c ****   GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 287              		.loc 1 1114 0
 288 00ac 0494     		str	r4, [sp, #16]
1115:../Src/main.c ****   HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 289              		.loc 1 1115 0
 290 00ae 01A9     		add	r1, sp, #4
 291 00b0 3046     		mov	r0, r6
 292 00b2 FFF7FEFF 		bl	HAL_GPIO_Init
 293              	.LVL23:
1116:../Src/main.c **** 
1117:../Src/main.c ****   /*Configure GPIO pin : PD2 */
1118:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_2;
 294              		.loc 1 1118 0
 295 00b6 0423     		movs	r3, #4
 296 00b8 0193     		str	r3, [sp, #4]
1119:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 297              		.loc 1 1119 0
 298 00ba 0295     		str	r5, [sp, #8]
1120:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 299              		.loc 1 1120 0
 300 00bc 0394     		str	r4, [sp, #12]
1121:../Src/main.c ****   HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 301              		.loc 1 1121 0
 302 00be 0DEB0301 		add	r1, sp, r3
 303 00c2 0648     		ldr	r0, .L17+12
 304 00c4 FFF7FEFF 		bl	HAL_GPIO_Init
 305              	.LVL24:
ARM GAS  /tmp/ccNelj9t.s 			page 26


1122:../Src/main.c **** 
1123:../Src/main.c **** }
 306              		.loc 1 1123 0
 307 00c8 06B0     		add	sp, sp, #24
 308              	.LCFI6:
 309              		.cfi_def_cfa_offset 24
 310              		@ sp needed
 311 00ca BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 312              	.L18:
 313 00ce 00BF     		.align	2
 314              	.L17:
 315 00d0 00380240 		.word	1073887232
 316 00d4 00080240 		.word	1073874944
 317 00d8 00040240 		.word	1073873920
 318 00dc 000C0240 		.word	1073875968
 319 00e0 00000240 		.word	1073872896
 320              		.cfi_endproc
 321              	.LFE138:
 323              		.section	.text.SystemClock_Config,"ax",%progbits
 324              		.align	2
 325              		.thumb
 326              		.thumb_func
 328              	SystemClock_Config:
 329              	.LFB133:
 942:../Src/main.c **** 
 330              		.loc 1 942 0
 331              		.cfi_startproc
 332              		@ args = 0, pretend = 0, frame = 72
 333              		@ frame_needed = 0, uses_anonymous_args = 0
 334 0000 30B5     		push	{r4, r5, lr}
 335              	.LCFI7:
 336              		.cfi_def_cfa_offset 12
 337              		.cfi_offset 4, -12
 338              		.cfi_offset 5, -8
 339              		.cfi_offset 14, -4
 340 0002 93B0     		sub	sp, sp, #76
 341              	.LCFI8:
 342              		.cfi_def_cfa_offset 88
 947:../Src/main.c **** 
 343              		.loc 1 947 0
 344 0004 174A     		ldr	r2, .L21
 345 0006 136C     		ldr	r3, [r2, #64]
 346 0008 43F08053 		orr	r3, r3, #268435456
 347 000c 1364     		str	r3, [r2, #64]
 949:../Src/main.c **** 
 348              		.loc 1 949 0
 349 000e A2F5E432 		sub	r2, r2, #116736
 350 0012 1368     		ldr	r3, [r2]
 351 0014 23F44043 		bic	r3, r3, #49152
 352 0018 43F40043 		orr	r3, r3, #32768
 353 001c 1360     		str	r3, [r2]
 951:../Src/main.c ****   RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 354              		.loc 1 951 0
 355 001e 0224     		movs	r4, #2
 356 0020 0694     		str	r4, [sp, #24]
 952:../Src/main.c ****   RCC_OscInitStruct.HSICalibrationValue = 6;
 357              		.loc 1 952 0
ARM GAS  /tmp/ccNelj9t.s 			page 27


 358 0022 0123     		movs	r3, #1
 359 0024 0993     		str	r3, [sp, #36]
 953:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 360              		.loc 1 953 0
 361 0026 0623     		movs	r3, #6
 362 0028 0A93     		str	r3, [sp, #40]
 954:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 363              		.loc 1 954 0
 364 002a 0C94     		str	r4, [sp, #48]
 955:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLM = 16;
 365              		.loc 1 955 0
 366 002c 0025     		movs	r5, #0
 367 002e 0D95     		str	r5, [sp, #52]
 956:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLN = 336;
 368              		.loc 1 956 0
 369 0030 1023     		movs	r3, #16
 370 0032 0E93     		str	r3, [sp, #56]
 957:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 371              		.loc 1 957 0
 372 0034 4FF4A873 		mov	r3, #336
 373 0038 0F93     		str	r3, [sp, #60]
 958:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLQ = 7;
 374              		.loc 1 958 0
 375 003a 0423     		movs	r3, #4
 376 003c 1093     		str	r3, [sp, #64]
 959:../Src/main.c ****   HAL_RCC_OscConfig(&RCC_OscInitStruct);
 377              		.loc 1 959 0
 378 003e 0723     		movs	r3, #7
 379 0040 1193     		str	r3, [sp, #68]
 960:../Src/main.c **** 
 380              		.loc 1 960 0
 381 0042 06A8     		add	r0, sp, #24
 382 0044 FFF7FEFF 		bl	HAL_RCC_OscConfig
 383              	.LVL25:
 962:../Src/main.c ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 384              		.loc 1 962 0
 385 0048 0523     		movs	r3, #5
 386 004a 0193     		str	r3, [sp, #4]
 963:../Src/main.c ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 387              		.loc 1 963 0
 388 004c 0294     		str	r4, [sp, #8]
 964:../Src/main.c ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 389              		.loc 1 964 0
 390 004e 0395     		str	r5, [sp, #12]
 965:../Src/main.c ****   RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 391              		.loc 1 965 0
 392 0050 4FF48053 		mov	r3, #4096
 393 0054 0493     		str	r3, [sp, #16]
 966:../Src/main.c ****   HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 394              		.loc 1 966 0
 395 0056 0595     		str	r5, [sp, #20]
 967:../Src/main.c **** 
 396              		.loc 1 967 0
 397 0058 2146     		mov	r1, r4
 398 005a 01A8     		add	r0, sp, #4
 399 005c FFF7FEFF 		bl	HAL_RCC_ClockConfig
 400              	.LVL26:
ARM GAS  /tmp/ccNelj9t.s 			page 28


 969:../Src/main.c **** 
 401              		.loc 1 969 0
 402 0060 13B0     		add	sp, sp, #76
 403              	.LCFI9:
 404              		.cfi_def_cfa_offset 12
 405              		@ sp needed
 406 0062 30BD     		pop	{r4, r5, pc}
 407              	.L22:
 408              		.align	2
 409              	.L21:
 410 0064 00380240 		.word	1073887232
 411              		.cfi_endproc
 412              	.LFE133:
 414              		.section	.text.MX_I2C1_Init,"ax",%progbits
 415              		.align	2
 416              		.thumb
 417              		.thumb_func
 419              	MX_I2C1_Init:
 420              	.LFB134:
 973:../Src/main.c **** 
 421              		.loc 1 973 0
 422              		.cfi_startproc
 423              		@ args = 0, pretend = 0, frame = 0
 424              		@ frame_needed = 0, uses_anonymous_args = 0
 425 0000 08B5     		push	{r3, lr}
 426              	.LCFI10:
 427              		.cfi_def_cfa_offset 8
 428              		.cfi_offset 3, -8
 429              		.cfi_offset 14, -4
 975:../Src/main.c ****   hi2c1.Init.ClockSpeed = 400000;
 430              		.loc 1 975 0
 431 0002 0948     		ldr	r0, .L25
 432 0004 094B     		ldr	r3, .L25+4
 433 0006 0360     		str	r3, [r0]
 976:../Src/main.c ****   hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
 434              		.loc 1 976 0
 435 0008 094B     		ldr	r3, .L25+8
 436 000a 4360     		str	r3, [r0, #4]
 977:../Src/main.c ****   hi2c1.Init.OwnAddress1 = 0;
 437              		.loc 1 977 0
 438 000c 0023     		movs	r3, #0
 439 000e 8360     		str	r3, [r0, #8]
 978:../Src/main.c ****   hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 440              		.loc 1 978 0
 441 0010 C360     		str	r3, [r0, #12]
 979:../Src/main.c ****   hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLED;
 442              		.loc 1 979 0
 443 0012 4FF48042 		mov	r2, #16384
 444 0016 0261     		str	r2, [r0, #16]
 980:../Src/main.c ****   hi2c1.Init.OwnAddress2 = 0;
 445              		.loc 1 980 0
 446 0018 4361     		str	r3, [r0, #20]
 981:../Src/main.c ****   hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLED;
 447              		.loc 1 981 0
 448 001a 8361     		str	r3, [r0, #24]
 982:../Src/main.c ****   hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLED;
 449              		.loc 1 982 0
ARM GAS  /tmp/ccNelj9t.s 			page 29


 450 001c C361     		str	r3, [r0, #28]
 983:../Src/main.c ****   HAL_I2C_Init(&hi2c1);
 451              		.loc 1 983 0
 452 001e 0362     		str	r3, [r0, #32]
 984:../Src/main.c **** 
 453              		.loc 1 984 0
 454 0020 FFF7FEFF 		bl	HAL_I2C_Init
 455              	.LVL27:
 456 0024 08BD     		pop	{r3, pc}
 457              	.L26:
 458 0026 00BF     		.align	2
 459              	.L25:
 460 0028 00000000 		.word	hi2c1
 461 002c 00540040 		.word	1073763328
 462 0030 801A0600 		.word	400000
 463              		.cfi_endproc
 464              	.LFE134:
 466              		.section	.text.MX_TIM3_Init,"ax",%progbits
 467              		.align	2
 468              		.thumb
 469              		.thumb_func
 471              	MX_TIM3_Init:
 472              	.LFB135:
 990:../Src/main.c **** 
 473              		.loc 1 990 0
 474              		.cfi_startproc
 475              		@ args = 0, pretend = 0, frame = 24
 476              		@ frame_needed = 0, uses_anonymous_args = 0
 477 0000 30B5     		push	{r4, r5, lr}
 478              	.LCFI11:
 479              		.cfi_def_cfa_offset 12
 480              		.cfi_offset 4, -12
 481              		.cfi_offset 5, -8
 482              		.cfi_offset 14, -4
 483 0002 87B0     		sub	sp, sp, #28
 484              	.LCFI12:
 485              		.cfi_def_cfa_offset 40
 995:../Src/main.c ****   htim3.Init.Prescaler = 42000-1;
 486              		.loc 1 995 0
 487 0004 0F4C     		ldr	r4, .L29
 488 0006 104B     		ldr	r3, .L29+4
 489 0008 2360     		str	r3, [r4]
 996:../Src/main.c ****   htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 490              		.loc 1 996 0
 491 000a 4AF20F43 		movw	r3, #41999
 492 000e 6360     		str	r3, [r4, #4]
 997:../Src/main.c ****   htim3.Init.Period = 1000-1;
 493              		.loc 1 997 0
 494 0010 0025     		movs	r5, #0
 495 0012 A560     		str	r5, [r4, #8]
 998:../Src/main.c ****   htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 496              		.loc 1 998 0
 497 0014 40F2E733 		movw	r3, #999
 498 0018 E360     		str	r3, [r4, #12]
 999:../Src/main.c ****   HAL_TIM_Base_Init(&htim3);
 499              		.loc 1 999 0
 500 001a 2561     		str	r5, [r4, #16]
ARM GAS  /tmp/ccNelj9t.s 			page 30


1000:../Src/main.c **** 
 501              		.loc 1 1000 0
 502 001c 2046     		mov	r0, r4
 503 001e FFF7FEFF 		bl	HAL_TIM_Base_Init
 504              	.LVL28:
1002:../Src/main.c ****   HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);
 505              		.loc 1 1002 0
 506 0022 06A9     		add	r1, sp, #24
 507 0024 4FF48053 		mov	r3, #4096
 508 0028 41F8103D 		str	r3, [r1, #-16]!
1003:../Src/main.c **** 
 509              		.loc 1 1003 0
 510 002c 2046     		mov	r0, r4
 511 002e FFF7FEFF 		bl	HAL_TIM_ConfigClockSource
 512              	.LVL29:
1005:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 513              		.loc 1 1005 0
 514 0032 0095     		str	r5, [sp]
1006:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);
 515              		.loc 1 1006 0
 516 0034 0195     		str	r5, [sp, #4]
1007:../Src/main.c **** 
 517              		.loc 1 1007 0
 518 0036 6946     		mov	r1, sp
 519 0038 2046     		mov	r0, r4
 520 003a FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 521              	.LVL30:
1009:../Src/main.c **** 
 522              		.loc 1 1009 0
 523 003e 07B0     		add	sp, sp, #28
 524              	.LCFI13:
 525              		.cfi_def_cfa_offset 12
 526              		@ sp needed
 527 0040 30BD     		pop	{r4, r5, pc}
 528              	.L30:
 529 0042 00BF     		.align	2
 530              	.L29:
 531 0044 00000000 		.word	htim3
 532 0048 00040040 		.word	1073742848
 533              		.cfi_endproc
 534              	.LFE135:
 536              		.section	.text.MX_USART2_UART_Init,"ax",%progbits
 537              		.align	2
 538              		.thumb
 539              		.thumb_func
 541              	MX_USART2_UART_Init:
 542              	.LFB137:
1029:../Src/main.c **** 
 543              		.loc 1 1029 0
 544              		.cfi_startproc
 545              		@ args = 0, pretend = 0, frame = 0
 546              		@ frame_needed = 0, uses_anonymous_args = 0
 547 0000 08B5     		push	{r3, lr}
 548              	.LCFI14:
 549              		.cfi_def_cfa_offset 8
 550              		.cfi_offset 3, -8
 551              		.cfi_offset 14, -4
ARM GAS  /tmp/ccNelj9t.s 			page 31


1031:../Src/main.c ****   huart2.Init.BaudRate = 115200;
 552              		.loc 1 1031 0
 553 0002 0848     		ldr	r0, .L33
 554 0004 084B     		ldr	r3, .L33+4
 555 0006 0360     		str	r3, [r0]
1032:../Src/main.c ****   huart2.Init.WordLength = UART_WORDLENGTH_8B;
 556              		.loc 1 1032 0
 557 0008 4FF4E133 		mov	r3, #115200
 558 000c 4360     		str	r3, [r0, #4]
1033:../Src/main.c ****   huart2.Init.StopBits = UART_STOPBITS_1;
 559              		.loc 1 1033 0
 560 000e 0023     		movs	r3, #0
 561 0010 8360     		str	r3, [r0, #8]
1034:../Src/main.c ****   huart2.Init.Parity = UART_PARITY_NONE;
 562              		.loc 1 1034 0
 563 0012 C360     		str	r3, [r0, #12]
1035:../Src/main.c ****   huart2.Init.Mode = UART_MODE_TX_RX;
 564              		.loc 1 1035 0
 565 0014 0361     		str	r3, [r0, #16]
1036:../Src/main.c ****   huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 566              		.loc 1 1036 0
 567 0016 0C22     		movs	r2, #12
 568 0018 4261     		str	r2, [r0, #20]
1037:../Src/main.c ****   huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 569              		.loc 1 1037 0
 570 001a 8361     		str	r3, [r0, #24]
1038:../Src/main.c ****   HAL_UART_Init(&huart2);
 571              		.loc 1 1038 0
 572 001c C361     		str	r3, [r0, #28]
1039:../Src/main.c **** 
 573              		.loc 1 1039 0
 574 001e FFF7FEFF 		bl	HAL_UART_Init
 575              	.LVL31:
 576 0022 08BD     		pop	{r3, pc}
 577              	.L34:
 578              		.align	2
 579              	.L33:
 580 0024 00000000 		.word	huart2
 581 0028 00440040 		.word	1073759232
 582              		.cfi_endproc
 583              	.LFE137:
 585              		.section	.text.MX_USART1_UART_Init,"ax",%progbits
 586              		.align	2
 587              		.thumb
 588              		.thumb_func
 590              	MX_USART1_UART_Init:
 591              	.LFB136:
1013:../Src/main.c **** 
 592              		.loc 1 1013 0
 593              		.cfi_startproc
 594              		@ args = 0, pretend = 0, frame = 0
 595              		@ frame_needed = 0, uses_anonymous_args = 0
 596 0000 08B5     		push	{r3, lr}
 597              	.LCFI15:
 598              		.cfi_def_cfa_offset 8
 599              		.cfi_offset 3, -8
 600              		.cfi_offset 14, -4
ARM GAS  /tmp/ccNelj9t.s 			page 32


1015:../Src/main.c ****   huart1.Init.BaudRate = 1000000;
 601              		.loc 1 1015 0
 602 0002 0848     		ldr	r0, .L37
 603 0004 084B     		ldr	r3, .L37+4
 604 0006 0360     		str	r3, [r0]
1016:../Src/main.c ****   huart1.Init.WordLength = UART_WORDLENGTH_8B;
 605              		.loc 1 1016 0
 606 0008 084B     		ldr	r3, .L37+8
 607 000a 4360     		str	r3, [r0, #4]
1017:../Src/main.c ****   huart1.Init.StopBits = UART_STOPBITS_1;
 608              		.loc 1 1017 0
 609 000c 0023     		movs	r3, #0
 610 000e 8360     		str	r3, [r0, #8]
1018:../Src/main.c ****   huart1.Init.Parity = UART_PARITY_NONE;
 611              		.loc 1 1018 0
 612 0010 C360     		str	r3, [r0, #12]
1019:../Src/main.c ****   huart1.Init.Mode = UART_MODE_TX_RX;
 613              		.loc 1 1019 0
 614 0012 0361     		str	r3, [r0, #16]
1020:../Src/main.c ****   huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 615              		.loc 1 1020 0
 616 0014 0C22     		movs	r2, #12
 617 0016 4261     		str	r2, [r0, #20]
1021:../Src/main.c ****   huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 618              		.loc 1 1021 0
 619 0018 8361     		str	r3, [r0, #24]
1022:../Src/main.c ****   HAL_UART_Init(&huart1);
 620              		.loc 1 1022 0
 621 001a C361     		str	r3, [r0, #28]
1023:../Src/main.c **** 
 622              		.loc 1 1023 0
 623 001c FFF7FEFF 		bl	HAL_UART_Init
 624              	.LVL32:
 625 0020 08BD     		pop	{r3, pc}
 626              	.L38:
 627 0022 00BF     		.align	2
 628              	.L37:
 629 0024 00000000 		.word	huart1
 630 0028 00100140 		.word	1073811456
 631 002c 40420F00 		.word	1000000
 632              		.cfi_endproc
 633              	.LFE136:
 635              		.section	.text.MX_TIM5_Init,"ax",%progbits
 636              		.align	2
 637              		.global	MX_TIM5_Init
 638              		.thumb
 639              		.thumb_func
 641              	MX_TIM5_Init:
 642              	.LFB113:
 171:../Src/main.c **** 
 643              		.loc 1 171 0
 644              		.cfi_startproc
 645              		@ args = 0, pretend = 0, frame = 40
 646              		@ frame_needed = 0, uses_anonymous_args = 0
 647 0000 30B5     		push	{r4, r5, lr}
 648              	.LCFI16:
 649              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccNelj9t.s 			page 33


 650              		.cfi_offset 4, -12
 651              		.cfi_offset 5, -8
 652              		.cfi_offset 14, -4
 653 0002 8BB0     		sub	sp, sp, #44
 654              	.LCFI17:
 655              		.cfi_def_cfa_offset 56
 176:../Src/main.c ****   htim5.Init.Prescaler = 83;
 656              		.loc 1 176 0
 657 0004 0F4D     		ldr	r5, .L41
 658 0006 104B     		ldr	r3, .L41+4
 659 0008 2B60     		str	r3, [r5]
 177:../Src/main.c ****   htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 660              		.loc 1 177 0
 661 000a 5323     		movs	r3, #83
 662 000c 6B60     		str	r3, [r5, #4]
 178:../Src/main.c ****   htim5.Init.Period = 0xFFFFFFFF;
 663              		.loc 1 178 0
 664 000e 0024     		movs	r4, #0
 665 0010 AC60     		str	r4, [r5, #8]
 179:../Src/main.c ****   htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 666              		.loc 1 179 0
 667 0012 4FF0FF33 		mov	r3, #-1
 668 0016 EB60     		str	r3, [r5, #12]
 180:../Src/main.c ****   HAL_TIM_OC_Init(&htim5);
 669              		.loc 1 180 0
 670 0018 2C61     		str	r4, [r5, #16]
 181:../Src/main.c **** 
 671              		.loc 1 181 0
 672 001a 2846     		mov	r0, r5
 673 001c FFF7FEFF 		bl	HAL_TIM_OC_Init
 674              	.LVL33:
 183:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 675              		.loc 1 183 0
 676 0020 0894     		str	r4, [sp, #32]
 184:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig);
 677              		.loc 1 184 0
 678 0022 0994     		str	r4, [sp, #36]
 185:../Src/main.c **** 
 679              		.loc 1 185 0
 680 0024 08A9     		add	r1, sp, #32
 681 0026 2846     		mov	r0, r5
 682 0028 FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 683              	.LVL34:
 187:../Src/main.c ****   sConfigOC.Pulse = 0;
 684              		.loc 1 187 0
 685 002c 0194     		str	r4, [sp, #4]
 188:../Src/main.c ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 686              		.loc 1 188 0
 687 002e 0294     		str	r4, [sp, #8]
 189:../Src/main.c ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 688              		.loc 1 189 0
 689 0030 0394     		str	r4, [sp, #12]
 190:../Src/main.c ****   HAL_TIM_OC_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1);
 690              		.loc 1 190 0
 691 0032 0594     		str	r4, [sp, #20]
 191:../Src/main.c **** 
 692              		.loc 1 191 0
ARM GAS  /tmp/ccNelj9t.s 			page 34


 693 0034 2246     		mov	r2, r4
 694 0036 01A9     		add	r1, sp, #4
 695 0038 2846     		mov	r0, r5
 696 003a FFF7FEFF 		bl	HAL_TIM_OC_ConfigChannel
 697              	.LVL35:
 193:../Src/main.c **** 
 698              		.loc 1 193 0
 699 003e 0BB0     		add	sp, sp, #44
 700              	.LCFI18:
 701              		.cfi_def_cfa_offset 12
 702              		@ sp needed
 703 0040 30BD     		pop	{r4, r5, pc}
 704              	.L42:
 705 0042 00BF     		.align	2
 706              	.L41:
 707 0044 00000000 		.word	htim5
 708 0048 000C0040 		.word	1073744896
 709              		.cfi_endproc
 710              	.LFE113:
 712              		.section	.text.TimeStamp_Init,"ax",%progbits
 713              		.align	2
 714              		.global	TimeStamp_Init
 715              		.thumb
 716              		.thumb_func
 718              	TimeStamp_Init:
 719              	.LFB114:
 195:../Src/main.c ****     MX_TIM5_Init();
 720              		.loc 1 195 0
 721              		.cfi_startproc
 722              		@ args = 0, pretend = 0, frame = 0
 723              		@ frame_needed = 0, uses_anonymous_args = 0
 724 0000 08B5     		push	{r3, lr}
 725              	.LCFI19:
 726              		.cfi_def_cfa_offset 8
 727              		.cfi_offset 3, -8
 728              		.cfi_offset 14, -4
 196:../Src/main.c **** }
 729              		.loc 1 196 0
 730 0002 FFF7FEFF 		bl	MX_TIM5_Init
 731              	.LVL36:
 732 0006 08BD     		pop	{r3, pc}
 733              		.cfi_endproc
 734              	.LFE114:
 736              		.section	.text.TimeStamp_Reset,"ax",%progbits
 737              		.align	2
 738              		.global	TimeStamp_Reset
 739              		.thumb
 740              		.thumb_func
 742              	TimeStamp_Reset:
 743              	.LFB115:
 199:../Src/main.c ****     HAL_TIM_Base_Start(&htim5);
 744              		.loc 1 199 0
 745              		.cfi_startproc
 746              		@ args = 0, pretend = 0, frame = 0
 747              		@ frame_needed = 0, uses_anonymous_args = 0
 748 0000 10B5     		push	{r4, lr}
 749              	.LCFI20:
ARM GAS  /tmp/ccNelj9t.s 			page 35


 750              		.cfi_def_cfa_offset 8
 751              		.cfi_offset 4, -8
 752              		.cfi_offset 14, -4
 200:../Src/main.c ****     htim5.Instance->CNT=0;
 753              		.loc 1 200 0
 754 0002 044C     		ldr	r4, .L47
 755 0004 2046     		mov	r0, r4
 756 0006 FFF7FEFF 		bl	HAL_TIM_Base_Start
 757              	.LVL37:
 201:../Src/main.c **** }
 758              		.loc 1 201 0
 759 000a 2368     		ldr	r3, [r4]
 760 000c 0022     		movs	r2, #0
 761 000e 5A62     		str	r2, [r3, #36]
 762 0010 10BD     		pop	{r4, pc}
 763              	.L48:
 764 0012 00BF     		.align	2
 765              	.L47:
 766 0014 00000000 		.word	htim5
 767              		.cfi_endproc
 768              	.LFE115:
 770              		.section	.text.TimeStamp_Get,"ax",%progbits
 771              		.align	2
 772              		.global	TimeStamp_Get
 773              		.thumb
 774              		.thumb_func
 776              	TimeStamp_Get:
 777              	.LFB116:
 204:../Src/main.c ****     return htim5.Instance->CNT;
 778              		.loc 1 204 0
 779              		.cfi_startproc
 780              		@ args = 0, pretend = 0, frame = 0
 781              		@ frame_needed = 0, uses_anonymous_args = 0
 782              		@ link register save eliminated.
 205:../Src/main.c **** }
 783              		.loc 1 205 0
 784 0000 014B     		ldr	r3, .L50
 785 0002 1B68     		ldr	r3, [r3]
 786 0004 586A     		ldr	r0, [r3, #36]
 206:../Src/main.c **** 
 787              		.loc 1 206 0
 788 0006 7047     		bx	lr
 789              	.L51:
 790              		.align	2
 791              	.L50:
 792 0008 00000000 		.word	htim5
 793              		.cfi_endproc
 794              	.LFE116:
 796              		.section	.text.BSP_GetPushButton,"ax",%progbits
 797              		.align	2
 798              		.global	BSP_GetPushButton
 799              		.thumb
 800              		.thumb_func
 802              	BSP_GetPushButton:
 803              	.LFB117:
 239:../Src/main.c ****     GPIO_PinState state ;
 804              		.loc 1 239 0
ARM GAS  /tmp/ccNelj9t.s 			page 36


 805              		.cfi_startproc
 806              		@ args = 0, pretend = 0, frame = 0
 807              		@ frame_needed = 0, uses_anonymous_args = 0
 808 0000 08B5     		push	{r3, lr}
 809              	.LCFI21:
 810              		.cfi_def_cfa_offset 8
 811              		.cfi_offset 3, -8
 812              		.cfi_offset 14, -4
 241:../Src/main.c ****     return state;
 813              		.loc 1 241 0
 814 0002 4FF40051 		mov	r1, #8192
 815 0006 0248     		ldr	r0, .L54
 816 0008 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 817              	.LVL38:
 243:../Src/main.c **** 
 818              		.loc 1 243 0
 819 000c 08BD     		pop	{r3, pc}
 820              	.L55:
 821 000e 00BF     		.align	2
 822              	.L54:
 823 0010 00080240 		.word	1073874944
 824              		.cfi_endproc
 825              	.LFE117:
 827              		.section	.text.PusbButton_WaitUnPress,"ax",%progbits
 828              		.align	2
 829              		.global	PusbButton_WaitUnPress
 830              		.thumb
 831              		.thumb_func
 833              	PusbButton_WaitUnPress:
 834              	.LFB118:
 255:../Src/main.c ****     uint32_t TimeStarted;
 835              		.loc 1 255 0
 836              		.cfi_startproc
 837              		@ args = 0, pretend = 0, frame = 0
 838              		@ frame_needed = 0, uses_anonymous_args = 0
 839 0000 10B5     		push	{r4, lr}
 840              	.LCFI22:
 841              		.cfi_def_cfa_offset 8
 842              		.cfi_offset 4, -8
 843              		.cfi_offset 14, -4
 257:../Src/main.c ****     while( !BSP_GetPushButton() ){ ; /* debounce */
 844              		.loc 1 257 0
 845 0002 FFF7FEFF 		bl	HAL_GetTick
 846              	.LVL39:
 847 0006 0446     		mov	r4, r0
 848              	.LVL40:
 258:../Src/main.c ****         if(HAL_GetTick()- TimeStarted> PressBPSwicthTime){
 849              		.loc 1 258 0
 850 0008 08E0     		b	.L58
 851              	.LVL41:
 852              	.L59:
 259:../Src/main.c ****             XNUCLEO53L0A1_SetDisplayString (" rb ");
 853              		.loc 1 259 0
 854 000a FFF7FEFF 		bl	HAL_GetTick
 855              	.LVL42:
 856 000e 001B     		subs	r0, r0, r4
 857 0010 B0F57A7F 		cmp	r0, #1000
ARM GAS  /tmp/ccNelj9t.s 			page 37


 858 0014 02D9     		bls	.L58
 260:../Src/main.c ****         }
 859              		.loc 1 260 0
 860 0016 0848     		ldr	r0, .L61
 861 0018 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 862              	.LVL43:
 863              	.L58:
 258:../Src/main.c ****         if(HAL_GetTick()- TimeStarted> PressBPSwicthTime){
 864              		.loc 1 258 0
 865 001c FFF7FEFF 		bl	BSP_GetPushButton
 866              	.LVL44:
 867 0020 0028     		cmp	r0, #0
 868 0022 F2D0     		beq	.L59
 263:../Src/main.c **** 
 869              		.loc 1 263 0
 870 0024 FFF7FEFF 		bl	HAL_GetTick
 871              	.LVL45:
 872 0028 001B     		subs	r0, r0, r4
 265:../Src/main.c **** 
 873              		.loc 1 265 0
 874 002a B0F57A7F 		cmp	r0, #1000
 875 002e 94BF     		ite	ls
 876 0030 0020     		movls	r0, #0
 877 0032 0120     		movhi	r0, #1
 878 0034 10BD     		pop	{r4, pc}
 879              	.LVL46:
 880              	.L62:
 881 0036 00BF     		.align	2
 882              	.L61:
 883 0038 00000000 		.word	.LC1
 884              		.cfi_endproc
 885              	.LFE118:
 887              		.section	.text.HandleError,"ax",%progbits
 888              		.align	2
 889              		.global	HandleError
 890              		.thumb
 891              		.thumb_func
 893              	HandleError:
 894              	.LFB119:
 290:../Src/main.c ****     char msg[16];
 895              		.loc 1 290 0
 896              		.cfi_startproc
 897              		@ args = 0, pretend = 0, frame = 16
 898              		@ frame_needed = 0, uses_anonymous_args = 0
 899              	.LVL47:
 900 0000 00B5     		push	{lr}
 901              	.LCFI23:
 902              		.cfi_def_cfa_offset 4
 903              		.cfi_offset 14, -4
 904 0002 85B0     		sub	sp, sp, #20
 905              	.LCFI24:
 906              		.cfi_def_cfa_offset 24
 292:../Src/main.c ****     XNUCLEO53L0A1_SetDisplayString(msg);
 907              		.loc 1 292 0
 908 0004 0246     		mov	r2, r0
 909 0006 0449     		ldr	r1, .L66
 910 0008 6846     		mov	r0, sp
ARM GAS  /tmp/ccNelj9t.s 			page 38


 911              	.LVL48:
 912 000a FFF7FEFF 		bl	sprintf
 913              	.LVL49:
 293:../Src/main.c ****     while(1){};
 914              		.loc 1 293 0
 915 000e 6846     		mov	r0, sp
 916 0010 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 917              	.LVL50:
 918              	.L64:
 919 0014 FEE7     		b	.L64
 920              	.L67:
 921 0016 00BF     		.align	2
 922              	.L66:
 923 0018 08000000 		.word	.LC2
 924              		.cfi_endproc
 925              	.LFE119:
 927              		.section	.text.DetectSensors,"ax",%progbits
 928              		.align	2
 929              		.global	DetectSensors
 930              		.thumb
 931              		.thumb_func
 933              	DetectSensors:
 934              	.LFB120:
 303:../Src/main.c ****     int i;
 935              		.loc 1 303 0
 936              		.cfi_startproc
 937              		@ args = 0, pretend = 0, frame = 8
 938              		@ frame_needed = 0, uses_anonymous_args = 0
 939              	.LVL51:
 940 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 941              	.LCFI25:
 942              		.cfi_def_cfa_offset 24
 943              		.cfi_offset 4, -24
 944              		.cfi_offset 5, -20
 945              		.cfi_offset 6, -16
 946              		.cfi_offset 7, -12
 947              		.cfi_offset 8, -8
 948              		.cfi_offset 14, -4
 949 0004 82B0     		sub	sp, sp, #8
 950              	.LCFI26:
 951              		.cfi_def_cfa_offset 32
 952 0006 0746     		mov	r7, r0
 309:../Src/main.c ****     /* Reset all */
 953              		.loc 1 309 0
 954 0008 4F4B     		ldr	r3, .L83
 955 000a 93E80300 		ldmia	r3, {r0, r1}
 956              	.LVL52:
 957 000e 0090     		str	r0, [sp]
 958 0010 8DF80410 		strb	r1, [sp, #4]
 311:../Src/main.c ****     for (i = 0; i < 3; i++)
 959              		.loc 1 311 0
 960 0014 0024     		movs	r4, #0
 961 0016 4D4B     		ldr	r3, .L83+4
 962 0018 1C60     		str	r4, [r3]
 963              	.LVL53:
 312:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 964              		.loc 1 312 0
ARM GAS  /tmp/ccNelj9t.s 			page 39


 965 001a 04E0     		b	.L69
 966              	.LVL54:
 967              	.L70:
 313:../Src/main.c **** 
 968              		.loc 1 313 0 discriminator 3
 969 001c 0021     		movs	r1, #0
 970 001e 2046     		mov	r0, r4
 971 0020 FFF7FEFF 		bl	XNUCLEO53L0A1_ResetId
 972              	.LVL55:
 312:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 973              		.loc 1 312 0 discriminator 3
 974 0024 0134     		adds	r4, r4, #1
 975              	.LVL56:
 976              	.L69:
 312:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 977              		.loc 1 312 0 is_stmt 0 discriminator 1
 978 0026 022C     		cmp	r4, #2
 979 0028 F8DD     		ble	.L70
 980 002a 0025     		movs	r5, #0
 981 002c 60E0     		b	.L71
 982              	.LVL57:
 983              	.L75:
 984              	.LBB2:
 318:../Src/main.c ****         pDev->I2cDevAddr = 0x52;
 985              		.loc 1 318 0 is_stmt 1
 986 002e 4FF4C874 		mov	r4, #400
 987 0032 474B     		ldr	r3, .L83+8
 988 0034 04FB0534 		mla	r4, r4, r5, r3
 989              	.LVL58:
 319:../Src/main.c ****         pDev->Present = 0;
 990              		.loc 1 319 0
 991 0038 5223     		movs	r3, #82
 992 003a 84F86031 		strb	r3, [r4, #352]
 320:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId( pDev->Id, 1);
 993              		.loc 1 320 0
 994 003e 0023     		movs	r3, #0
 995 0040 C4F86831 		str	r3, [r4, #360]
 321:../Src/main.c ****         HAL_Delay(2);
 996              		.loc 1 321 0
 997 0044 0121     		movs	r1, #1
 998 0046 D4F86401 		ldr	r0, [r4, #356]
 999 004a FFF7FEFF 		bl	XNUCLEO53L0A1_ResetId
 1000              	.LVL59:
 1001 004e 0646     		mov	r6, r0
 1002              	.LVL60:
 322:../Src/main.c ****         FinalAddress=0x52+(i+1)*2;
 1003              		.loc 1 322 0
 1004 0050 0220     		movs	r0, #2
 1005              	.LVL61:
 1006 0052 FFF7FEFF 		bl	HAL_Delay
 1007              	.LVL62:
 323:../Src/main.c **** 
 1008              		.loc 1 323 0
 1009 0056 05F12A03 		add	r3, r5, #42
 1010 005a 4FEA4308 		lsl	r8, r3, #1
 1011              	.LVL63:
 327:../Src/main.c ****         		status = VL53L0X_WrByte(pDev, 0x88, 0x00);
ARM GAS  /tmp/ccNelj9t.s 			page 40


 1012              		.loc 1 327 0
 1013 005e 26B9     		cbnz	r6, .L72
 328:../Src/main.c **** 
 1014              		.loc 1 328 0
 1015 0060 0022     		movs	r2, #0
 1016 0062 8821     		movs	r1, #136
 1017 0064 2046     		mov	r0, r4
 1018 0066 FFF7FEFF 		bl	VL53L0X_WrByte
 1019              	.LVL64:
 1020              	.L72:
 331:../Src/main.c ****             if (status) {
 1021              		.loc 1 331 0
 1022 006a 0DF10602 		add	r2, sp, #6
 1023 006e C021     		movs	r1, #192
 1024 0070 2046     		mov	r0, r4
 1025 0072 FFF7FEFF 		bl	VL53L0X_RdWord
 1026              	.LVL65:
 1027 0076 0346     		mov	r3, r0
 1028              	.LVL66:
 332:../Src/main.c ****                 debug_printf("#%d Read id fail\n", i);
 1029              		.loc 1 332 0
 1030 0078 A0BB     		cbnz	r0, .L73
 336:../Src/main.c **** 				/* Sensor is found => Change its I2C address to final one */
 1031              		.loc 1 336 0
 1032 007a BDF80620 		ldrh	r2, [sp, #6]
 1033 007e 4EF6AA63 		movw	r3, #61098
 1034 0082 9A42     		cmp	r2, r3
 1035 0084 2DD1     		bne	.L80
 338:../Src/main.c ****                 if (status != 0) {
 1036              		.loc 1 338 0
 1037 0086 5FFA88F8 		uxtb	r8, r8
 1038              	.LVL67:
 1039 008a 4146     		mov	r1, r8
 1040 008c 2046     		mov	r0, r4
 1041              	.LVL68:
 1042 008e FFF7FEFF 		bl	VL53L0X_SetDeviceAddress
 1043              	.LVL69:
 1044 0092 0346     		mov	r3, r0
 1045              	.LVL70:
 339:../Src/main.c ****                     debug_printf("#i VL53L0X_SetDeviceAddress fail\n", i);
 1046              		.loc 1 339 0
 1047 0094 30BB     		cbnz	r0, .L73
 343:../Src/main.c ****                 /* Check all is OK with the new I2C address and initialize the sensor */
 1048              		.loc 1 343 0
 1049 0096 4FF4C873 		mov	r3, #400
 1050 009a 2D4A     		ldr	r2, .L83+8
 1051 009c 03FB0523 		mla	r3, r3, r5, r2
 1052 00a0 83F86081 		strb	r8, [r3, #352]
 345:../Src/main.c ****                 if (status != 0) {
 1053              		.loc 1 345 0
 1054 00a4 0DF10602 		add	r2, sp, #6
 1055 00a8 C021     		movs	r1, #192
 1056 00aa 2046     		mov	r0, r4
 1057              	.LVL71:
 1058 00ac FFF7FEFF 		bl	VL53L0X_RdWord
 1059              	.LVL72:
 1060 00b0 0346     		mov	r3, r0
ARM GAS  /tmp/ccNelj9t.s 			page 41


 1061              	.LVL73:
 346:../Src/main.c **** 					debug_printf("#i VL53L0X_RdWord fail\n", i);
 1062              		.loc 1 346 0
 1063 00b2 B8B9     		cbnz	r0, .L73
 351:../Src/main.c ****                 if( status == 0 ){
 1064              		.loc 1 351 0
 1065 00b4 2046     		mov	r0, r4
 1066              	.LVL74:
 1067 00b6 FFF7FEFF 		bl	VL53L0X_DataInit
 1068              	.LVL75:
 1069 00ba 0346     		mov	r3, r0
 1070              	.LVL76:
 352:../Src/main.c ****                     pDev->Present = 1;
 1071              		.loc 1 352 0
 1072 00bc 90B9     		cbnz	r0, .L73
 353:../Src/main.c ****                 }
 1073              		.loc 1 353 0
 1074 00be 4FF4C872 		mov	r2, #400
 1075 00c2 2349     		ldr	r1, .L83+8
 1076 00c4 02FB0511 		mla	r1, r2, r5, r1
 1077 00c8 0122     		movs	r2, #1
 1078 00ca C1F86821 		str	r2, [r1, #360]
 360:../Src/main.c ****                 nDevMask |= 1 << i;
 1079              		.loc 1 360 0
 1080 00ce 1F48     		ldr	r0, .L83+4
 1081              	.LVL77:
 1082 00d0 0168     		ldr	r1, [r0]
 1083 00d2 1144     		add	r1, r1, r2
 1084 00d4 0160     		str	r1, [r0]
 361:../Src/main.c ****                 pDev->Present = 1;
 1085              		.loc 1 361 0
 1086 00d6 AA40     		lsls	r2, r2, r5
 1087 00d8 1E49     		ldr	r1, .L83+12
 1088 00da 0868     		ldr	r0, [r1]
 1089 00dc 0243     		orrs	r2, r2, r0
 1090 00de 0A60     		str	r2, [r1]
 1091 00e0 00E0     		b	.L73
 1092              	.LVL78:
 1093              	.L80:
 366:../Src/main.c ****             }
 1094              		.loc 1 366 0
 1095 00e2 0123     		movs	r3, #1
 1096              	.LVL79:
 1097              	.L73:
 370:../Src/main.c ****             XNUCLEO53L0A1_ResetId(i, 0);
 1098              		.loc 1 370 0
 1099 00e4 1BB1     		cbz	r3, .L74
 371:../Src/main.c ****         }
 1100              		.loc 1 371 0
 1101 00e6 0021     		movs	r1, #0
 1102 00e8 2846     		mov	r0, r5
 1103 00ea FFF7FEFF 		bl	XNUCLEO53L0A1_ResetId
 1104              	.LVL80:
 1105              	.L74:
 1106              	.LBE2:
 316:../Src/main.c ****         VL53L0X_Dev_t *pDev;
 1107              		.loc 1 316 0 discriminator 2
ARM GAS  /tmp/ccNelj9t.s 			page 42


 1108 00ee 0135     		adds	r5, r5, #1
 1109              	.LVL81:
 1110              	.L71:
 316:../Src/main.c ****         VL53L0X_Dev_t *pDev;
 1111              		.loc 1 316 0 is_stmt 0 discriminator 1
 1112 00f0 022D     		cmp	r5, #2
 1113 00f2 9CDD     		ble	.L75
 375:../Src/main.c ****         for(i=0; i<3; i++){
 1114              		.loc 1 375 0 is_stmt 1
 1115 00f4 B7B9     		cbnz	r7, .L81
 1116 00f6 22E0     		b	.L77
 1117              	.LVL82:
 1118              	.L79:
 377:../Src/main.c ****                 PresentMsg[i+1]=VL53L0XDevs[i].DevLetter;
 1119              		.loc 1 377 0
 1120 00f8 4FF4C872 		mov	r2, #400
 1121 00fc 1449     		ldr	r1, .L83+8
 1122 00fe 02FB0312 		mla	r2, r2, r3, r1
 1123 0102 D2F86821 		ldr	r2, [r2, #360]
 1124 0106 5AB1     		cbz	r2, .L78
 378:../Src/main.c ****             }
 1125              		.loc 1 378 0
 1126 0108 5A1C     		adds	r2, r3, #1
 1127 010a 4FF4C871 		mov	r1, #400
 1128 010e 1048     		ldr	r0, .L83+8
 1129 0110 01FB0301 		mla	r1, r1, r3, r0
 1130 0114 91F86111 		ldrb	r1, [r1, #353]	@ zero_extendqisi2
 1131 0118 02A8     		add	r0, sp, #8
 1132 011a 0244     		add	r2, r2, r0
 1133 011c 02F8081C 		strb	r1, [r2, #-8]
 1134              	.L78:
 376:../Src/main.c ****             if( VL53L0XDevs[i].Present ){
 1135              		.loc 1 376 0 discriminator 2
 1136 0120 0133     		adds	r3, r3, #1
 1137              	.LVL83:
 1138 0122 00E0     		b	.L76
 1139              	.LVL84:
 1140              	.L81:
 1141 0124 0023     		movs	r3, #0
 1142              	.LVL85:
 1143              	.L76:
 376:../Src/main.c ****             if( VL53L0XDevs[i].Present ){
 1144              		.loc 1 376 0 is_stmt 0 discriminator 1
 1145 0126 022B     		cmp	r3, #2
 1146 0128 E6DD     		ble	.L79
 381:../Src/main.c ****         XNUCLEO53L0A1_SetDisplayString(PresentMsg);
 1147              		.loc 1 381 0 is_stmt 1
 1148 012a 02A8     		add	r0, sp, #8
 1149 012c 2023     		movs	r3, #32
 1150              	.LVL86:
 1151 012e 00F8083D 		strb	r3, [r0, #-8]!
 382:../Src/main.c ****         HAL_Delay(1000);
 1152              		.loc 1 382 0
 1153 0132 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 1154              	.LVL87:
 383:../Src/main.c ****     }
 1155              		.loc 1 383 0
ARM GAS  /tmp/ccNelj9t.s 			page 43


 1156 0136 4FF47A70 		mov	r0, #1000
 1157 013a FFF7FEFF 		bl	HAL_Delay
 1158              	.LVL88:
 1159              	.L77:
 387:../Src/main.c **** 
 1160              		.loc 1 387 0
 1161 013e 034B     		ldr	r3, .L83+4
 1162 0140 1868     		ldr	r0, [r3]
 1163 0142 02B0     		add	sp, sp, #8
 1164              	.LCFI27:
 1165              		.cfi_def_cfa_offset 24
 1166              		@ sp needed
 1167 0144 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1168              	.LVL89:
 1169              	.L84:
 1170              		.align	2
 1171              	.L83:
 1172 0148 10000000 		.word	.LC3
 1173 014c 00000000 		.word	.LANCHOR0
 1174 0150 00000000 		.word	.LANCHOR1
 1175 0154 00000000 		.word	nDevMask
 1176              		.cfi_endproc
 1177              	.LFE120:
 1179              		.section	.text.SetupSingleShot,"ax",%progbits
 1180              		.align	2
 1181              		.global	SetupSingleShot
 1182              		.thumb
 1183              		.thumb_func
 1185              	SetupSingleShot:
 1186              	.LFB121:
 392:../Src/main.c ****     int i;
 1187              		.loc 1 392 0
 1188              		.cfi_startproc
 1189              		@ args = 0, pretend = 0, frame = 16
 1190              		@ frame_needed = 0, uses_anonymous_args = 0
 1191              	.LVL90:
 1192 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1193              	.LCFI28:
 1194              		.cfi_def_cfa_offset 36
 1195              		.cfi_offset 4, -36
 1196              		.cfi_offset 5, -32
 1197              		.cfi_offset 6, -28
 1198              		.cfi_offset 7, -24
 1199              		.cfi_offset 8, -20
 1200              		.cfi_offset 9, -16
 1201              		.cfi_offset 10, -12
 1202              		.cfi_offset 11, -8
 1203              		.cfi_offset 14, -4
 1204 0004 85B0     		sub	sp, sp, #20
 1205              	.LCFI29:
 1206              		.cfi_def_cfa_offset 56
 1207 0006 0646     		mov	r6, r0
 1208              	.LVL91:
 403:../Src/main.c **** 
 1209              		.loc 1 403 0
 1210 0008 4FF00A0B 		mov	fp, #10
 402:../Src/main.c **** 	uint8_t finalRangeVcselPeriod = 10;
ARM GAS  /tmp/ccNelj9t.s 			page 44


 1211              		.loc 1 402 0
 1212 000c 4FF00E0A 		mov	r10, #14
 401:../Src/main.c **** 	uint8_t preRangeVcselPeriod = 14;
 1213              		.loc 1 401 0
 1214 0010 48F2E809 		movw	r9, #33000
 400:../Src/main.c **** 	uint32_t timingBudget = 33000;
 1215              		.loc 1 400 0
 1216 0014 4FF49018 		mov	r8, #1179648
 399:../Src/main.c **** 	FixPoint1616_t sigmaLimit = (FixPoint1616_t)(18*65536);
 1217              		.loc 1 399 0
 1218 0018 4FF48047 		mov	r7, #16384
 405:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 1219              		.loc 1 405 0
 1220 001c 0024     		movs	r4, #0
 1221 001e 77E0     		b	.L86
 1222              	.LVL92:
 1223              	.L92:
 406:../Src/main.c ****             status=VL53L0X_StaticInit(&VL53L0XDevs[i]);
 1224              		.loc 1 406 0
 1225 0020 4FF4C873 		mov	r3, #400
 1226 0024 3D4A     		ldr	r2, .L95
 1227 0026 03FB0423 		mla	r3, r3, r4, r2
 1228 002a D3F86831 		ldr	r3, [r3, #360]
 1229 002e 002B     		cmp	r3, #0
 1230 0030 6DD0     		beq	.L87
 407:../Src/main.c ****             if( status ){
 1231              		.loc 1 407 0
 1232 0032 4FF4C873 		mov	r3, #400
 1233 0036 03FB0425 		mla	r5, r3, r4, r2
 1234 003a 2846     		mov	r0, r5
 1235 003c FFF7FEFF 		bl	VL53L0X_StaticInit
 1236              	.LVL93:
 412:../Src/main.c **** 			if( status ){
 1237              		.loc 1 412 0
 1238 0040 0DF10E02 		add	r2, sp, #14
 1239 0044 0DF10F01 		add	r1, sp, #15
 1240 0048 2846     		mov	r0, r5
 1241 004a FFF7FEFF 		bl	VL53L0X_PerformRefCalibration
 1242              	.LVL94:
 417:../Src/main.c **** 			if( status ){
 1243              		.loc 1 417 0
 1244 004e 0DF10702 		add	r2, sp, #7
 1245 0052 02A9     		add	r1, sp, #8
 1246 0054 2846     		mov	r0, r5
 1247 0056 FFF7FEFF 		bl	VL53L0X_PerformRefSpadManagement
 1248              	.LVL95:
 422:../Src/main.c ****             if( status ){
 1249              		.loc 1 422 0
 1250 005a 0021     		movs	r1, #0
 1251 005c 2846     		mov	r0, r5
 1252 005e FFF7FEFF 		bl	VL53L0X_SetDeviceMode
 1253              	.LVL96:
 427:../Src/main.c **** 			if( status ){
 1254              		.loc 1 427 0
 1255 0062 0122     		movs	r2, #1
 1256 0064 0021     		movs	r1, #0
 1257 0066 2846     		mov	r0, r5
ARM GAS  /tmp/ccNelj9t.s 			page 45


 1258 0068 FFF7FEFF 		bl	VL53L0X_SetLimitCheckEnable
 1259              	.LVL97:
 432:../Src/main.c **** 			if( status ){
 1260              		.loc 1 432 0
 1261 006c 0122     		movs	r2, #1
 1262 006e 1146     		mov	r1, r2
 1263 0070 2846     		mov	r0, r5
 1264 0072 FFF7FEFF 		bl	VL53L0X_SetLimitCheckEnable
 1265              	.LVL98:
 437:../Src/main.c ****             case LONG_RANGE:
 1266              		.loc 1 437 0
 1267 0076 012E     		cmp	r6, #1
 1268 0078 0DD0     		beq	.L89
 1269 007a BEB1     		cbz	r6, .L93
 1270 007c 022E     		cmp	r6, #2
 1271 007e 1FD1     		bne	.L90
 1272              	.LVL99:
 450:../Src/main.c **** 				break;
 1273              		.loc 1 450 0
 1274 0080 4FF00A0B 		mov	fp, #10
 449:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 1275              		.loc 1 449 0
 1276 0084 4FF00E0A 		mov	r10, #14
 448:../Src/main.c **** 				preRangeVcselPeriod = 14; //laser pulse periods
 1277              		.loc 1 448 0
 1278 0088 DFF89490 		ldr	r9, .L95+4
 447:../Src/main.c **** 				timingBudget = 200000; //200ms
 1279              		.loc 1 447 0
 1280 008c 4FF49018 		mov	r8, #1179648
 446:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(18*65536);
 1281              		.loc 1 446 0
 1282 0090 4FF48047 		mov	r7, #16384
 451:../Src/main.c ****             case HIGH_SPEED:
 1283              		.loc 1 451 0
 1284 0094 14E0     		b	.L90
 1285              	.LVL100:
 1286              	.L89:
 457:../Src/main.c **** 				break;
 1287              		.loc 1 457 0
 1288 0096 4FF00A0B 		mov	fp, #10
 456:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 1289              		.loc 1 456 0
 1290 009a 4FF00E0A 		mov	r10, #14
 455:../Src/main.c **** 				preRangeVcselPeriod = 14;
 1291              		.loc 1 455 0
 1292 009e 44F62069 		movw	r9, #20000
 454:../Src/main.c **** 				timingBudget = 20000; //20ms
 1293              		.loc 1 454 0
 1294 00a2 4FF40018 		mov	r8, #2097152
 453:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(32*65536);
 1295              		.loc 1 453 0
 1296 00a6 4FF48047 		mov	r7, #16384
 458:../Src/main.c ****             default:
 1297              		.loc 1 458 0
 1298 00aa 09E0     		b	.L90
 1299              	.LVL101:
 1300              	.L93:
ARM GAS  /tmp/ccNelj9t.s 			page 46


 443:../Src/main.c ****             	break;
 1301              		.loc 1 443 0
 1302 00ac 4FF00E0B 		mov	fp, #14
 1303              	.LVL102:
 442:../Src/main.c ****             	finalRangeVcselPeriod = 14;
 1304              		.loc 1 442 0
 1305 00b0 4FF0120A 		mov	r10, #18
 1306              	.LVL103:
 441:../Src/main.c ****             	preRangeVcselPeriod = 18;
 1307              		.loc 1 441 0
 1308 00b4 48F2E809 		movw	r9, #33000
 1309              	.LVL104:
 440:../Src/main.c ****             	timingBudget = 33000; //33ms
 1310              		.loc 1 440 0
 1311 00b8 4FF47018 		mov	r8, #3932160
 1312              	.LVL105:
 439:../Src/main.c ****             	sigmaLimit = (FixPoint1616_t)(60*65536);
 1313              		.loc 1 439 0
 1314 00bc 41F69917 		movw	r7, #6553
 1315              	.LVL106:
 1316              	.L90:
 463:../Src/main.c **** 			if( status ){
 1317              		.loc 1 463 0
 1318 00c0 3A46     		mov	r2, r7
 1319 00c2 0121     		movs	r1, #1
 1320 00c4 2846     		mov	r0, r5
 1321 00c6 FFF7FEFF 		bl	VL53L0X_SetLimitCheckValue
 1322              	.LVL107:
 468:../Src/main.c **** 			if( status ){
 1323              		.loc 1 468 0
 1324 00ca 4246     		mov	r2, r8
 1325 00cc 0021     		movs	r1, #0
 1326 00ce 2846     		mov	r0, r5
 1327 00d0 FFF7FEFF 		bl	VL53L0X_SetLimitCheckValue
 1328              	.LVL108:
 473:../Src/main.c ****             if( status ){
 1329              		.loc 1 473 0
 1330 00d4 4946     		mov	r1, r9
 1331 00d6 2846     		mov	r0, r5
 1332 00d8 FFF7FEFF 		bl	VL53L0X_SetMeasurementTimingBudgetMicroSeconds
 1333              	.LVL109:
 478:../Src/main.c **** 			if( status ){
 1334              		.loc 1 478 0
 1335 00dc 5246     		mov	r2, r10
 1336 00de 0021     		movs	r1, #0
 1337 00e0 2846     		mov	r0, r5
 1338 00e2 FFF7FEFF 		bl	VL53L0X_SetVcselPulsePeriod
 1339              	.LVL110:
 483:../Src/main.c **** 			if( status ){
 1340              		.loc 1 483 0
 1341 00e6 5A46     		mov	r2, fp
 1342 00e8 0121     		movs	r1, #1
 1343 00ea 2846     		mov	r0, r5
 1344 00ec FFF7FEFF 		bl	VL53L0X_SetVcselPulsePeriod
 1345              	.LVL111:
 488:../Src/main.c **** 			if( status ){
 1346              		.loc 1 488 0
ARM GAS  /tmp/ccNelj9t.s 			page 47


 1347 00f0 0DF10E02 		add	r2, sp, #14
 1348 00f4 0DF10F01 		add	r1, sp, #15
 1349 00f8 2846     		mov	r0, r5
 1350 00fa FFF7FEFF 		bl	VL53L0X_PerformRefCalibration
 1351              	.LVL112:
 493:../Src/main.c ****         }
 1352              		.loc 1 493 0
 1353 00fe 4FF4C873 		mov	r3, #400
 1354 0102 064A     		ldr	r2, .L95
 1355 0104 03FB0423 		mla	r3, r3, r4, r2
 1356 0108 0122     		movs	r2, #1
 1357 010a C3F87C21 		str	r2, [r3, #380]
 1358              	.L87:
 405:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 1359              		.loc 1 405 0 discriminator 2
 1360 010e 0134     		adds	r4, r4, #1
 1361              	.LVL113:
 1362              	.L86:
 405:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 1363              		.loc 1 405 0 is_stmt 0 discriminator 1
 1364 0110 022C     		cmp	r4, #2
 1365 0112 85DD     		ble	.L92
 496:../Src/main.c **** 
 1366              		.loc 1 496 0 is_stmt 1
 1367 0114 05B0     		add	sp, sp, #20
 1368              	.LCFI30:
 1369              		.cfi_def_cfa_offset 36
 1370              		@ sp needed
 1371 0116 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1372              	.LVL114:
 1373              	.L96:
 1374 011a 00BF     		.align	2
 1375              	.L95:
 1376 011c 00000000 		.word	.LANCHOR1
 1377 0120 400D0300 		.word	200000
 1378              		.cfi_endproc
 1379              	.LFE121:
 1381              		.section	.text.RangeToLetter,"ax",%progbits
 1382              		.align	2
 1383              		.global	RangeToLetter
 1384              		.thumb
 1385              		.thumb_func
 1387              	RangeToLetter:
 1388              	.LFB122:
 498:../Src/main.c ****     char c;
 1389              		.loc 1 498 0
 1390              		.cfi_startproc
 1391              		@ args = 0, pretend = 0, frame = 0
 1392              		@ frame_needed = 0, uses_anonymous_args = 0
 1393              		@ link register save eliminated.
 1394              	.LVL115:
 500:../Src/main.c ****         if( pDev->LeakyRange < RangeLow ){
 1395              		.loc 1 500 0
 1396 0000 0B7E     		ldrb	r3, [r1, #24]	@ zero_extendqisi2
 1397 0002 5BB9     		cbnz	r3, .L99
 501:../Src/main.c ****             c='_';
 1398              		.loc 1 501 0
ARM GAS  /tmp/ccNelj9t.s 			page 48


 1399 0004 D0F87831 		ldr	r3, [r0, #376]
 1400 0008 074A     		ldr	r2, .L102
 1401 000a 1268     		ldr	r2, [r2]
 1402 000c 9342     		cmp	r3, r2
 1403 000e 07DB     		blt	.L100
 504:../Src/main.c ****                 c='=';
 1404              		.loc 1 504 0
 1405 0010 064A     		ldr	r2, .L102+4
 1406 0012 1268     		ldr	r2, [r2]
 1407 0014 9342     		cmp	r3, r2
 1408 0016 05DA     		bge	.L101
 505:../Src/main.c ****         }
 1409              		.loc 1 505 0
 1410 0018 3D20     		movs	r0, #61
 1411              	.LVL116:
 1412 001a 7047     		bx	lr
 1413              	.LVL117:
 1414              	.L99:
 513:../Src/main.c ****     }
 1415              		.loc 1 513 0
 1416 001c 2D20     		movs	r0, #45
 1417              	.LVL118:
 1418 001e 7047     		bx	lr
 1419              	.LVL119:
 1420              	.L100:
 502:../Src/main.c ****         }
 1421              		.loc 1 502 0
 1422 0020 5F20     		movs	r0, #95
 1423              	.LVL120:
 1424 0022 7047     		bx	lr
 1425              	.LVL121:
 1426              	.L101:
 508:../Src/main.c ****         }
 1427              		.loc 1 508 0
 1428 0024 7E20     		movs	r0, #126
 1429              	.LVL122:
 516:../Src/main.c **** 
 1430              		.loc 1 516 0
 1431 0026 7047     		bx	lr
 1432              	.L103:
 1433              		.align	2
 1434              	.L102:
 1435 0028 00000000 		.word	.LANCHOR2
 1436 002c 00000000 		.word	.LANCHOR3
 1437              		.cfi_endproc
 1438              	.LFE122:
 1440              		.section	.text.Sensor_SetNewRange,"ax",%progbits
 1441              		.align	2
 1442              		.global	Sensor_SetNewRange
 1443              		.thumb
 1444              		.thumb_func
 1446              	Sensor_SetNewRange:
 1447              	.LFB123:
 519:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 1448              		.loc 1 519 0
 1449              		.cfi_startproc
 1450              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccNelj9t.s 			page 49


 1451              		@ frame_needed = 0, uses_anonymous_args = 0
 1452              		@ link register save eliminated.
 1453              	.LVL123:
 520:../Src/main.c ****         if( pDev->LeakyFirst ){
 1454              		.loc 1 520 0
 1455 0000 0B7E     		ldrb	r3, [r1, #24]	@ zero_extendqisi2
 1456 0002 CBB9     		cbnz	r3, .L105
 521:../Src/main.c ****             pDev->LeakyFirst = 0;
 1457              		.loc 1 521 0
 1458 0004 D0F87C31 		ldr	r3, [r0, #380]
 1459 0008 33B1     		cbz	r3, .L106
 522:../Src/main.c ****             pDev->LeakyRange = pRange->RangeMilliMeter;
 1460              		.loc 1 522 0
 1461 000a 0023     		movs	r3, #0
 1462 000c C0F87C31 		str	r3, [r0, #380]
 523:../Src/main.c ****         }
 1463              		.loc 1 523 0
 1464 0010 0B89     		ldrh	r3, [r1, #8]
 1465 0012 C0F87831 		str	r3, [r0, #376]
 1466 0016 7047     		bx	lr
 1467              	.L106:
 519:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 1468              		.loc 1 519 0
 1469 0018 10B4     		push	{r4}
 1470              	.LCFI31:
 1471              		.cfi_def_cfa_offset 4
 1472              		.cfi_offset 4, -4
 526:../Src/main.c ****         }
 1473              		.loc 1 526 0
 1474 001a D0F87831 		ldr	r3, [r0, #376]
 1475 001e 0A4A     		ldr	r2, .L110
 1476 0020 1468     		ldr	r4, [r2]
 1477 0022 C4F58072 		rsb	r2, r4, #256
 1478 0026 0989     		ldrh	r1, [r1, #8]
 1479              	.LVL124:
 1480 0028 02FB01F2 		mul	r2, r2, r1
 1481 002c 04FB0323 		mla	r3, r4, r3, r2
 1482 0030 1B12     		asrs	r3, r3, #8
 1483 0032 C0F87831 		str	r3, [r0, #376]
 1484 0036 03E0     		b	.L104
 1485              	.LVL125:
 1486              	.L105:
 1487              	.LCFI32:
 1488              		.cfi_def_cfa_offset 0
 1489              		.cfi_restore 4
 530:../Src/main.c ****     }
 1490              		.loc 1 530 0
 1491 0038 0123     		movs	r3, #1
 1492 003a C0F87C31 		str	r3, [r0, #380]
 532:../Src/main.c **** 
 1493              		.loc 1 532 0
 1494 003e 7047     		bx	lr
 1495              	.LVL126:
 1496              	.L104:
 1497              	.LCFI33:
 1498              		.cfi_def_cfa_offset 4
 1499              		.cfi_offset 4, -4
ARM GAS  /tmp/ccNelj9t.s 			page 50


 1500 0040 5DF8044B 		ldr	r4, [sp], #4
 1501              	.LCFI34:
 1502              		.cfi_restore 4
 1503              		.cfi_def_cfa_offset 0
 1504 0044 7047     		bx	lr
 1505              	.L111:
 1506 0046 00BF     		.align	2
 1507              	.L110:
 1508 0048 00000000 		.word	.LANCHOR4
 1509              		.cfi_endproc
 1510              	.LFE123:
 1512              		.section	.text.blink_led,"ax",%progbits
 1513              		.align	2
 1514              		.global	blink_led
 1515              		.thumb
 1516              		.thumb_func
 1518              	blink_led:
 1519              	.LFB124:
 534:../Src/main.c ****     if (*compteur == 6){                       /////modification toutes les 6 mesures correctes du 
 1520              		.loc 1 534 0
 1521              		.cfi_startproc
 1522              		@ args = 0, pretend = 0, frame = 0
 1523              		@ frame_needed = 0, uses_anonymous_args = 0
 1524              	.LVL127:
 535:../Src/main.c ****         HAL_TIM_Base_Stop_IT(&htim3);
 1525              		.loc 1 535 0
 1526 0000 0B68     		ldr	r3, [r1]
 1527 0002 062B     		cmp	r3, #6
 1528 0004 12D1     		bne	.L115
 534:../Src/main.c ****     if (*compteur == 6){                       /////modification toutes les 6 mesures correctes du 
 1529              		.loc 1 534 0
 1530 0006 70B5     		push	{r4, r5, r6, lr}
 1531              	.LCFI35:
 1532              		.cfi_def_cfa_offset 16
 1533              		.cfi_offset 4, -16
 1534              		.cfi_offset 5, -12
 1535              		.cfi_offset 6, -8
 1536              		.cfi_offset 14, -4
 1537 0008 0D46     		mov	r5, r1
 1538 000a 0446     		mov	r4, r0
 536:../Src/main.c ****         htim3.Instance->ARR = 2*valeur-1+20;   /////modification de la periode du capteur (voir wik
 1539              		.loc 1 536 0
 1540 000c 084E     		ldr	r6, .L116
 1541 000e 3046     		mov	r0, r6
 1542              	.LVL128:
 1543 0010 FFF7FEFF 		bl	HAL_TIM_Base_Stop_IT
 1544              	.LVL129:
 537:../Src/main.c ****         HAL_TIM_Base_Start_IT(&htim3);  
 1545              		.loc 1 537 0
 1546 0014 3368     		ldr	r3, [r6]
 1547 0016 6000     		lsls	r0, r4, #1
 1548 0018 1330     		adds	r0, r0, #19
 1549 001a D862     		str	r0, [r3, #44]
 538:../Src/main.c ****         htim3.Instance->CNT = 0;               /////remise a zero du timer de la led
 1550              		.loc 1 538 0
 1551 001c 3046     		mov	r0, r6
 1552 001e FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
ARM GAS  /tmp/ccNelj9t.s 			page 51


 1553              	.LVL130:
 539:../Src/main.c ****         *compteur = 0;                         /////remise a zero du compteur
 1554              		.loc 1 539 0
 1555 0022 3268     		ldr	r2, [r6]
 1556 0024 0023     		movs	r3, #0
 1557 0026 5362     		str	r3, [r2, #36]
 540:../Src/main.c ****     }
 1558              		.loc 1 540 0
 1559 0028 2B60     		str	r3, [r5]
 1560 002a 70BD     		pop	{r4, r5, r6, pc}
 1561              	.LVL131:
 1562              	.L115:
 1563              	.LCFI36:
 1564              		.cfi_def_cfa_offset 0
 1565              		.cfi_restore 4
 1566              		.cfi_restore 5
 1567              		.cfi_restore 6
 1568              		.cfi_restore 14
 1569 002c 7047     		bx	lr
 1570              	.L117:
 1571 002e 00BF     		.align	2
 1572              	.L116:
 1573 0030 00000000 		.word	htim3
 1574              		.cfi_endproc
 1575              	.LFE124:
 1577              		.section	.text.transmit,"ax",%progbits
 1578              		.align	2
 1579              		.global	transmit
 1580              		.thumb
 1581              		.thumb_func
 1583              	transmit:
 1584              	.LFB125:
 546:../Src/main.c ****     char data[10];                                /////variable stockage de la valeur du capteur
 1585              		.loc 1 546 0
 1586              		.cfi_startproc
 1587              		@ args = 0, pretend = 0, frame = 16
 1588              		@ frame_needed = 0, uses_anonymous_args = 0
 1589              	.LVL132:
 1590 0000 70B5     		push	{r4, r5, r6, lr}
 1591              	.LCFI37:
 1592              		.cfi_def_cfa_offset 16
 1593              		.cfi_offset 4, -16
 1594              		.cfi_offset 5, -12
 1595              		.cfi_offset 6, -8
 1596              		.cfi_offset 14, -4
 1597 0002 84B0     		sub	sp, sp, #16
 1598              	.LCFI38:
 1599              		.cfi_def_cfa_offset 32
 1600 0004 0446     		mov	r4, r0
 1601 0006 0D46     		mov	r5, r1
 550:../Src/main.c ****         sprintf(data, "%d,",valeur);
 1602              		.loc 1 550 0
 1603 0008 0368     		ldr	r3, [r0]
 1604 000a 262B     		cmp	r3, #38
 1605 000c 04DC     		bgt	.L119
 551:../Src/main.c ****     }
 1606              		.loc 1 551 0
ARM GAS  /tmp/ccNelj9t.s 			page 52


 1607 000e 1949     		ldr	r1, .L123
 1608              	.LVL133:
 1609 0010 01A8     		add	r0, sp, #4
 1610              	.LVL134:
 1611 0012 FFF7FEFF 		bl	sprintf
 1612              	.LVL135:
 1613 0016 05E0     		b	.L120
 1614              	.LVL136:
 1615              	.L119:
 553:../Src/main.c ****         sprintf(data, "%d",valeur);
 1616              		.loc 1 553 0
 1617 0018 272B     		cmp	r3, #39
 1618 001a 03D1     		bne	.L120
 554:../Src/main.c ****     }
 1619              		.loc 1 554 0
 1620 001c 1649     		ldr	r1, .L123+4
 1621              	.LVL137:
 1622 001e 01A8     		add	r0, sp, #4
 1623              	.LVL138:
 1624 0020 FFF7FEFF 		bl	sprintf
 1625              	.LVL139:
 1626              	.L120:
 556:../Src/main.c ****     if (*i==Maxi_char_transmit-1){
 1627              		.loc 1 556 0
 1628 0024 01A9     		add	r1, sp, #4
 1629 0026 2846     		mov	r0, r5
 1630 0028 FFF7FEFF 		bl	strcat
 1631              	.LVL140:
 557:../Src/main.c ****         len=strlen(buffer);                       /////longueur du buffer
 1632              		.loc 1 557 0
 1633 002c 2368     		ldr	r3, [r4]
 1634 002e 272B     		cmp	r3, #39
 1635 0030 1DD1     		bne	.L118
 558:../Src/main.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)(buffer), len, 1000); /////transmission du buffer
 1636              		.loc 1 558 0
 1637 0032 2846     		mov	r0, r5
 1638 0034 FFF7FEFF 		bl	strlen
 1639              	.LVL141:
 559:../Src/main.c ****         sprintf(ligne, "\n");                                     /////ajout \n a ligne
 1640              		.loc 1 559 0
 1641 0038 104E     		ldr	r6, .L123+8
 1642 003a 4FF47A73 		mov	r3, #1000
 1643 003e 82B2     		uxth	r2, r0
 1644 0040 2946     		mov	r1, r5
 1645 0042 3046     		mov	r0, r6
 1646              	.LVL142:
 1647 0044 FFF7FEFF 		bl	HAL_UART_Transmit
 1648              	.LVL143:
 560:../Src/main.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)ligne, 1, 1000);     /////transmission pour cloturer l
 1649              		.loc 1 560 0
 1650 0048 04A9     		add	r1, sp, #16
 1651 004a 0A23     		movs	r3, #10
 1652 004c 21F8103D 		strh	r3, [r1, #-16]!	@ movhi
 561:../Src/main.c ****         (*i)=-1;                                                  /////remise a zero du compteur
 1653              		.loc 1 561 0
 1654 0050 4FF47A73 		mov	r3, #1000
 1655 0054 0122     		movs	r2, #1
ARM GAS  /tmp/ccNelj9t.s 			page 53


 1656 0056 3046     		mov	r0, r6
 1657 0058 FFF7FEFF 		bl	HAL_UART_Transmit
 1658              	.LVL144:
 562:../Src/main.c ****         sprintf(buffer, "");                                      /////remise a zero du buffer
 1659              		.loc 1 562 0
 1660 005c 4FF0FF33 		mov	r3, #-1
 1661 0060 2360     		str	r3, [r4]
 563:../Src/main.c ****         HAL_Delay(Delay);         //////necessaire pour le graphique
 1662              		.loc 1 563 0
 1663 0062 0023     		movs	r3, #0
 1664 0064 2B70     		strb	r3, [r5]
 564:../Src/main.c ****     }
 1665              		.loc 1 564 0
 1666 0066 4FF47A70 		mov	r0, #1000
 1667 006a FFF7FEFF 		bl	HAL_Delay
 1668              	.LVL145:
 1669              	.L118:
 566:../Src/main.c **** 
 1670              		.loc 1 566 0
 1671 006e 04B0     		add	sp, sp, #16
 1672              	.LCFI39:
 1673              		.cfi_def_cfa_offset 16
 1674              		@ sp needed
 1675 0070 70BD     		pop	{r4, r5, r6, pc}
 1676              	.LVL146:
 1677              	.L124:
 1678 0072 00BF     		.align	2
 1679              	.L123:
 1680 0074 18000000 		.word	.LC4
 1681 0078 1C000000 		.word	.LC5
 1682 007c 00000000 		.word	huart2
 1683              		.cfi_endproc
 1684              	.LFE125:
 1686              		.section	.text.RangeDemo,"ax",%progbits
 1687              		.align	2
 1688              		.global	RangeDemo
 1689              		.thumb
 1690              		.thumb_func
 1692              	RangeDemo:
 1693              	.LFB126:
 575:../Src/main.c ****     int over=0;
 1694              		.loc 1 575 0
 1695              		.cfi_startproc
 1696              		@ args = 0, pretend = 0, frame = 176
 1697              		@ frame_needed = 0, uses_anonymous_args = 0
 1698              	.LVL147:
 1699 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 1700              	.LCFI40:
 1701              		.cfi_def_cfa_offset 28
 1702              		.cfi_offset 4, -28
 1703              		.cfi_offset 5, -24
 1704              		.cfi_offset 6, -20
 1705              		.cfi_offset 7, -16
 1706              		.cfi_offset 8, -12
 1707              		.cfi_offset 9, -8
 1708              		.cfi_offset 14, -4
 1709 0004 ADB0     		sub	sp, sp, #180
ARM GAS  /tmp/ccNelj9t.s 			page 54


 1710              	.LCFI41:
 1711              		.cfi_def_cfa_offset 208
 1712 0006 0546     		mov	r5, r0
 1713              	.LVL148:
 584:../Src/main.c ****     int* compteur = NULL;   ///creation pointeur sur compteur
 1714              		.loc 1 584 0
 1715 0008 0024     		movs	r4, #0
 1716 000a 2994     		str	r4, [sp, #164]
 1717              	.LVL149:
 587:../Src/main.c ****     int* compteur2 = NULL;   ///creation pointeur sur compteur2
 1718              		.loc 1 587 0
 1719 000c 2894     		str	r4, [sp, #160]
 1720              	.LVL150:
 591:../Src/main.c **** 
 1721              		.loc 1 591 0
 1722 000e 8DF80040 		strb	r4, [sp]
 594:../Src/main.c **** 
 1723              		.loc 1 594 0
 1724 0012 0846     		mov	r0, r1
 1725              	.LVL151:
 1726 0014 FFF7FEFF 		bl	SetupSingleShot
 1727              	.LVL152:
 582:../Src/main.c ****     int valeur;             ///creation variable valeur
 1728              		.loc 1 582 0
 1729 0018 2746     		mov	r7, r4
 597:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 1730              		.loc 1 597 0
 1731 001a 2646     		mov	r6, r4
 1732 001c 2346     		mov	r3, r4
 1733 001e 11E0     		b	.L126
 1734              	.LVL153:
 1735              	.L128:
 598:../Src/main.c ****             nSensorToUse++;
 1736              		.loc 1 598 0
 1737 0020 45FA03F2 		asr	r2, r5, r3
 1738 0024 12F0010F 		tst	r2, #1
 1739 0028 0BD0     		beq	.L127
 598:../Src/main.c ****             nSensorToUse++;
 1740              		.loc 1 598 0 is_stmt 0 discriminator 1
 1741 002a 4FF4C872 		mov	r2, #400
 1742 002e 5249     		ldr	r1, .L142
 1743 0030 02FB0312 		mla	r2, r2, r3, r1
 1744 0034 D2F86821 		ldr	r2, [r2, #360]
 1745 0038 1AB1     		cbz	r2, .L127
 599:../Src/main.c ****             if( nSensorToUse==1 )
 1746              		.loc 1 599 0 is_stmt 1
 1747 003a 0136     		adds	r6, r6, #1
 1748              	.LVL154:
 600:../Src/main.c ****                 SingleSensorNo=i;
 1749              		.loc 1 600 0
 1750 003c 012E     		cmp	r6, #1
 1751 003e 00D1     		bne	.L127
 601:../Src/main.c ****         }
 1752              		.loc 1 601 0
 1753 0040 1F46     		mov	r7, r3
 1754              	.LVL155:
 1755              	.L127:
ARM GAS  /tmp/ccNelj9t.s 			page 55


 597:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 1756              		.loc 1 597 0 discriminator 2
 1757 0042 0133     		adds	r3, r3, #1
 1758              	.LVL156:
 1759              	.L126:
 597:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 1760              		.loc 1 597 0 is_stmt 0 discriminator 1
 1761 0044 022B     		cmp	r3, #2
 1762 0046 EBDD     		ble	.L128
 604:../Src/main.c ****         return -1;
 1763              		.loc 1 604 0 is_stmt 1
 1764 0048 002E     		cmp	r6, #0
 1765 004a 00F09080 		beq	.L140
 1766              	.LVL157:
 1767              	.L138:
 610:../Src/main.c ****         	/* Multiple devices */
 1768              		.loc 1 610 0
 1769 004e 012E     		cmp	r6, #1
 1770 0050 33DD     		ble	.L130
 612:../Src/main.c ****             for( i=0; i<3; i++){
 1771              		.loc 1 612 0
 1772 0052 4A4B     		ldr	r3, .L142+4
 1773 0054 93E80300 		ldmia	r3, {r0, r1}
 1774 0058 2A90     		str	r0, [sp, #168]
 1775 005a 8DF8AC10 		strb	r1, [sp, #172]
 1776              	.LVL158:
 613:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 1777              		.loc 1 613 0
 1778 005e 0024     		movs	r4, #0
 1779 0060 28E0     		b	.L131
 1780              	.LVL159:
 1781              	.L134:
 614:../Src/main.c ****                     continue;
 1782              		.loc 1 614 0
 1783 0062 4FF4C873 		mov	r3, #400
 1784 0066 444A     		ldr	r2, .L142
 1785 0068 03FB0423 		mla	r3, r3, r4, r2
 1786 006c D3F86831 		ldr	r3, [r3, #360]
 1787 0070 FBB1     		cbz	r3, .L132
 614:../Src/main.c ****                     continue;
 1788              		.loc 1 614 0 is_stmt 0 discriminator 1
 1789 0072 45FA04F3 		asr	r3, r5, r4
 1790 0076 13F0010F 		tst	r3, #1
 1791 007a 1AD0     		beq	.L132
 617:../Src/main.c ****                 if( status ){
 1792              		.loc 1 617 0 is_stmt 1
 1793 007c 4FF4C873 		mov	r3, #400
 1794 0080 03FB0428 		mla	r8, r3, r4, r2
 1795 0084 3E49     		ldr	r1, .L142+8
 1796 0086 4046     		mov	r0, r8
 1797 0088 FFF7FEFF 		bl	VL53L0X_PerformSingleRangingMeasurement
 1798              	.LVL160:
 618:../Src/main.c ****                     HandleError(ERR_DEMO_RANGE_MULTI);
 1799              		.loc 1 618 0
 1800 008c 10B1     		cbz	r0, .L133
 619:../Src/main.c ****                 }
 1801              		.loc 1 619 0
ARM GAS  /tmp/ccNelj9t.s 			page 56


 1802 008e 0220     		movs	r0, #2
 1803              	.LVL161:
 1804 0090 FFF7FEFF 		bl	HandleError
 1805              	.LVL162:
 1806              	.L133:
 624:../Src/main.c ****                 /* Translate distance in bar graph (multiple device) */
 1807              		.loc 1 624 0
 1808 0094 DFF8E890 		ldr	r9, .L142+8
 1809 0098 4946     		mov	r1, r9
 1810 009a 4046     		mov	r0, r8
 1811              	.LVL163:
 1812 009c FFF7FEFF 		bl	Sensor_SetNewRange
 1813              	.LVL164:
 626:../Src/main.c ****                 StrDisplay[i+1]=c;
 1814              		.loc 1 626 0
 1815 00a0 4946     		mov	r1, r9
 1816 00a2 4046     		mov	r0, r8
 1817 00a4 FFF7FEFF 		bl	RangeToLetter
 1818              	.LVL165:
 627:../Src/main.c ****             }
 1819              		.loc 1 627 0
 1820 00a8 631C     		adds	r3, r4, #1
 1821 00aa 2CAA     		add	r2, sp, #176
 1822 00ac 1344     		add	r3, r3, r2
 1823 00ae 03F8080C 		strb	r0, [r3, #-8]
 1824              	.LVL166:
 1825              	.L132:
 613:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 1826              		.loc 1 613 0 discriminator 2
 1827 00b2 0134     		adds	r4, r4, #1
 1828              	.LVL167:
 1829              	.L131:
 613:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 1830              		.loc 1 613 0 is_stmt 0 discriminator 1
 1831 00b4 022C     		cmp	r4, #2
 1832 00b6 D4DD     		ble	.L134
 1833 00b8 4AE0     		b	.L135
 1834              	.LVL168:
 1835              	.L130:
 633:../Src/main.c ****             if( status ==0 ){
 1836              		.loc 1 633 0 is_stmt 1
 1837 00ba 4FF4C873 		mov	r3, #400
 1838 00be 2E4C     		ldr	r4, .L142
 1839 00c0 03FB0744 		mla	r4, r3, r7, r4
 1840 00c4 2E49     		ldr	r1, .L142+8
 1841 00c6 2046     		mov	r0, r4
 1842 00c8 FFF7FEFF 		bl	VL53L0X_PerformSingleRangingMeasurement
 1843              	.LVL169:
 634:../Src/main.c ****             	/* Push data logging to UART */
 1844              		.loc 1 634 0
 1845 00cc 0028     		cmp	r0, #0
 1846 00ce 3CD1     		bne	.L136
 637:../Src/main.c ****                 /* Display distance in cm */
 1847              		.loc 1 637 0
 1848 00d0 DFF8AC80 		ldr	r8, .L142+8
 1849 00d4 4146     		mov	r1, r8
 1850 00d6 2046     		mov	r0, r4
ARM GAS  /tmp/ccNelj9t.s 			page 57


 1851              	.LVL170:
 1852 00d8 FFF7FEFF 		bl	Sensor_SetNewRange
 1853              	.LVL171:
 639:../Src/main.c ****                     *compteur+=1;                               /////incrementation du compteur
 1854              		.loc 1 639 0
 1855 00dc 98F81830 		ldrb	r3, [r8, #24]	@ zero_extendqisi2
 1856 00e0 1BBB     		cbnz	r3, .L137
 640:../Src/main.c ****                     sprintf(StrDisplay, "%3dc",(int)VL53L0XDevs[SingleSensorNo].LeakyRange/10);  //
 1857              		.loc 1 640 0
 1858 00e2 299B     		ldr	r3, [sp, #164]
 1859 00e4 0133     		adds	r3, r3, #1
 1860 00e6 2993     		str	r3, [sp, #164]
 641:../Src/main.c ****                     valeur=(int)VL53L0XDevs[SingleSensorNo].LeakyRange/10;   /////valeur lue par le
 1861              		.loc 1 641 0
 1862 00e8 A046     		mov	r8, r4
 1863 00ea D4F87831 		ldr	r3, [r4, #376]
 1864 00ee 254C     		ldr	r4, .L142+12
 1865 00f0 84FB0312 		smull	r1, r2, r4, r3
 1866 00f4 DB17     		asrs	r3, r3, #31
 1867 00f6 C3EBA202 		rsb	r2, r3, r2, asr #2
 1868 00fa 2349     		ldr	r1, .L142+16
 1869 00fc 2AA8     		add	r0, sp, #168
 1870 00fe FFF7FEFF 		bl	sprintf
 1871              	.LVL172:
 642:../Src/main.c ****                     blink_led(valeur, compteur);                 /////fonction blink_led
 1872              		.loc 1 642 0
 1873 0102 D8F87831 		ldr	r3, [r8, #376]
 1874 0106 84FB0324 		smull	r2, r4, r4, r3
 1875 010a DB17     		asrs	r3, r3, #31
 1876 010c C3EBA404 		rsb	r4, r3, r4, asr #2
 1877              	.LVL173:
 643:../Src/main.c ****                     transmit(compteur2, buffer, valeur);        /////fonction transmit vers pc
 1878              		.loc 1 643 0
 1879 0110 29A9     		add	r1, sp, #164
 1880              	.LVL174:
 1881 0112 2046     		mov	r0, r4
 1882 0114 FFF7FEFF 		bl	blink_led
 1883              	.LVL175:
 644:../Src/main.c ****                     *compteur2+=1;                              /////incrementation du compteur2
 1884              		.loc 1 644 0
 1885 0118 2246     		mov	r2, r4
 1886 011a 6946     		mov	r1, sp
 1887 011c 28A8     		add	r0, sp, #160
 1888              	.LVL176:
 1889 011e FFF7FEFF 		bl	transmit
 1890              	.LVL177:
 645:../Src/main.c ****                 }
 1891              		.loc 1 645 0
 1892 0122 289B     		ldr	r3, [sp, #160]
 1893 0124 0133     		adds	r3, r3, #1
 1894 0126 2893     		str	r3, [sp, #160]
 1895 0128 12E0     		b	.L135
 1896              	.LVL178:
 1897              	.L137:
 648:../Src/main.c ****                     StrDisplay[0]=VL53L0XDevs[SingleSensorNo].DevLetter;
 1898              		.loc 1 648 0
 1899 012a 184B     		ldr	r3, .L142+20
ARM GAS  /tmp/ccNelj9t.s 			page 58


 1900 012c 93E80300 		ldmia	r3, {r0, r1}
 1901 0130 2A90     		str	r0, [sp, #168]
 1902 0132 8DF8AC10 		strb	r1, [sp, #172]
 649:../Src/main.c ****                     //HAL_TIM_Base_Stop_IT(&htim3);             /////version courante : memoire de 
 1903              		.loc 1 649 0
 1904 0136 4FF4C873 		mov	r3, #400
 1905 013a 0F4A     		ldr	r2, .L142
 1906 013c 03FB0723 		mla	r3, r3, r7, r2
 1907 0140 93F86131 		ldrb	r3, [r3, #353]	@ zero_extendqisi2
 1908 0144 8DF8A830 		strb	r3, [sp, #168]
 1909 0148 02E0     		b	.L135
 1910              	.LVL179:
 1911              	.L136:
 656:../Src/main.c ****             }
 1912              		.loc 1 656 0
 1913 014a 0120     		movs	r0, #1
 1914              	.LVL180:
 1915 014c FFF7FEFF 		bl	HandleError
 1916              	.LVL181:
 1917              	.L135:
 659:../Src/main.c ****         /* Check blue button */
 1918              		.loc 1 659 0
 1919 0150 2AA8     		add	r0, sp, #168
 1920 0152 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 1921              	.LVL182:
 661:../Src/main.c ****             over=1;
 1922              		.loc 1 661 0
 1923 0156 FFF7FEFF 		bl	BSP_GetPushButton
 1924              	.LVL183:
 1925 015a 0028     		cmp	r0, #0
 1926 015c 7FF477AF 		bne	.L138
 667:../Src/main.c ****     htim3.Instance->CNT=0;       /////remise a zero du timer de la led
 1927              		.loc 1 667 0
 1928 0160 FFF7FEFF 		bl	PusbButton_WaitUnPress
 1929              	.LVL184:
 668:../Src/main.c ****     return status;
 1930              		.loc 1 668 0
 1931 0164 0A4B     		ldr	r3, .L142+24
 1932 0166 1B68     		ldr	r3, [r3]
 1933 0168 0022     		movs	r2, #0
 1934 016a 5A62     		str	r2, [r3, #36]
 669:../Src/main.c **** }
 1935              		.loc 1 669 0
 1936 016c 01E0     		b	.L129
 1937              	.LVL185:
 1938              	.L140:
 605:../Src/main.c ****     }
 1939              		.loc 1 605 0
 1940 016e 4FF0FF30 		mov	r0, #-1
 1941              	.LVL186:
 1942              	.L129:
 670:../Src/main.c **** 
 1943              		.loc 1 670 0
 1944 0172 2DB0     		add	sp, sp, #180
 1945              	.LCFI42:
 1946              		.cfi_def_cfa_offset 28
 1947              		@ sp needed
ARM GAS  /tmp/ccNelj9t.s 			page 59


 1948 0174 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 1949              	.LVL187:
 1950              	.L143:
 1951              		.align	2
 1952              	.L142:
 1953 0178 00000000 		.word	.LANCHOR1
 1954 017c 10000000 		.word	.LC3
 1955 0180 00000000 		.word	RangingMeasurementData
 1956 0184 67666666 		.word	1717986919
 1957 0188 20000000 		.word	.LC6
 1958 018c 28000000 		.word	.LC7
 1959 0190 00000000 		.word	htim3
 1960              		.cfi_endproc
 1961              	.LFE126:
 1963              		.section	.text.ResetAndDetectSensor,"ax",%progbits
 1964              		.align	2
 1965              		.global	ResetAndDetectSensor
 1966              		.thumb
 1967              		.thumb_func
 1969              	ResetAndDetectSensor:
 1970              	.LFB127:
 798:../Src/main.c ****     int nSensor;
 1971              		.loc 1 798 0
 1972              		.cfi_startproc
 1973              		@ args = 0, pretend = 0, frame = 0
 1974              		@ frame_needed = 0, uses_anonymous_args = 0
 1975              	.LVL188:
 1976 0000 08B5     		push	{r3, lr}
 1977              	.LCFI43:
 1978              		.cfi_def_cfa_offset 8
 1979              		.cfi_offset 3, -8
 1980              		.cfi_offset 14, -4
 800:../Src/main.c ****     /* at least one sensor and if one it must be the built-in one  */
 1981              		.loc 1 800 0
 1982 0002 FFF7FEFF 		bl	DetectSensors
 1983              	.LVL189:
 802:../Src/main.c ****         HandleError(ERR_DETECT);
 1984              		.loc 1 802 0
 1985 0006 0028     		cmp	r0, #0
 1986 0008 05DD     		ble	.L145
 802:../Src/main.c ****         HandleError(ERR_DETECT);
 1987              		.loc 1 802 0 is_stmt 0 discriminator 1
 1988 000a 0128     		cmp	r0, #1
 1989 000c 07D1     		bne	.L144
 802:../Src/main.c ****         HandleError(ERR_DETECT);
 1990              		.loc 1 802 0 discriminator 2
 1991 000e 044B     		ldr	r3, .L148
 1992 0010 D3F8F832 		ldr	r3, [r3, #760]
 1993 0014 1BB9     		cbnz	r3, .L144
 1994              	.L145:
 803:../Src/main.c ****     }
 1995              		.loc 1 803 0 is_stmt 1
 1996 0016 4FF0FF30 		mov	r0, #-1
 1997              	.LVL190:
 1998 001a FFF7FEFF 		bl	HandleError
 1999              	.LVL191:
 2000              	.L144:
ARM GAS  /tmp/ccNelj9t.s 			page 60


 2001 001e 08BD     		pop	{r3, pc}
 2002              	.L149:
 2003              		.align	2
 2004              	.L148:
 2005 0020 00000000 		.word	.LANCHOR1
 2006              		.cfi_endproc
 2007              	.LFE127:
 2009              		.section	.text.main,"ax",%progbits
 2010              		.align	2
 2011              		.global	main
 2012              		.thumb
 2013              		.thumb_func
 2015              	main:
 2016              	.LFB132:
 830:../Src/main.c **** 
 2017              		.loc 1 830 0
 2018              		.cfi_startproc
 2019              		@ args = 0, pretend = 0, frame = 24
 2020              		@ frame_needed = 0, uses_anonymous_args = 0
 2021 0000 70B5     		push	{r4, r5, r6, lr}
 2022              	.LCFI44:
 2023              		.cfi_def_cfa_offset 16
 2024              		.cfi_offset 4, -16
 2025              		.cfi_offset 5, -12
 2026              		.cfi_offset 6, -8
 2027              		.cfi_offset 14, -4
 2028 0002 86B0     		sub	sp, sp, #24
 2029              	.LCFI45:
 2030              		.cfi_def_cfa_offset 40
 2031              	.LVL192:
 842:../Src/main.c **** 
 2032              		.loc 1 842 0
 2033 0004 FFF7FEFF 		bl	HAL_Init
 2034              	.LVL193:
 845:../Src/main.c **** 
 2035              		.loc 1 845 0
 2036 0008 FFF7FEFF 		bl	SystemClock_Config
 2037              	.LVL194:
 848:../Src/main.c ****   SystemClock_Config();
 2038              		.loc 1 848 0
 2039 000c FFF7FEFF 		bl	MX_GPIO_Init
 2040              	.LVL195:
 849:../Src/main.c ****   MX_I2C1_Init();
 2041              		.loc 1 849 0
 2042 0010 FFF7FEFF 		bl	SystemClock_Config
 2043              	.LVL196:
 850:../Src/main.c ****   MX_TIM3_Init();
 2044              		.loc 1 850 0
 2045 0014 FFF7FEFF 		bl	MX_I2C1_Init
 2046              	.LVL197:
 851:../Src/main.c ****   MX_USART2_UART_Init();
 2047              		.loc 1 851 0
 2048 0018 FFF7FEFF 		bl	MX_TIM3_Init
 2049              	.LVL198:
 852:../Src/main.c ****   MX_USART1_UART_Init();
 2050              		.loc 1 852 0
 2051 001c FFF7FEFF 		bl	MX_USART2_UART_Init
ARM GAS  /tmp/ccNelj9t.s 			page 61


 2052              	.LVL199:
 853:../Src/main.c **** 
 2053              		.loc 1 853 0
 2054 0020 FFF7FEFF 		bl	MX_USART1_UART_Init
 2055              	.LVL200:
 856:../Src/main.c ****   uart_printf(WelcomeMsg);
 2056              		.loc 1 856 0
 2057 0024 FFF7FEFF 		bl	XNUCLEO53L0A1_Init
 2058              	.LVL201:
 858:../Src/main.c ****   HAL_Delay(WelcomeTime);
 2059              		.loc 1 858 0
 2060 0028 3348     		ldr	r0, .L158
 2061 002a FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 2062              	.LVL202:
 859:../Src/main.c ****   ResetAndDetectSensor(1);
 2063              		.loc 1 859 0
 2064 002e 4FF42570 		mov	r0, #660
 2065 0032 FFF7FEFF 		bl	HAL_Delay
 2066              	.LVL203:
 860:../Src/main.c ****   HAL_TIM_Base_Start_IT(&htim3); //£
 2067              		.loc 1 860 0
 2068 0036 0120     		movs	r0, #1
 2069 0038 FFF7FEFF 		bl	ResetAndDetectSensor
 2070              	.LVL204:
 861:../Src/main.c **** 
 2071              		.loc 1 861 0
 2072 003c 2F48     		ldr	r0, .L158+4
 2073 003e FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 2074              	.LVL205:
 868:../Src/main.c ****   interface.set_direction = XL_320_Set_Direction_HAL;
 2075              		.loc 1 868 0
 2076 0042 2F4D     		ldr	r5, .L158+8
 2077 0044 2F4B     		ldr	r3, .L158+12
 2078 0046 2B60     		str	r3, [r5]
 869:../Src/main.c ****   interface.receive = XL_320_Receive_HAL;
 2079              		.loc 1 869 0
 2080 0048 2F4B     		ldr	r3, .L158+16
 2081 004a AB60     		str	r3, [r5, #8]
 870:../Src/main.c ****   interface.delay = XL_320_Delay_HAL;
 2082              		.loc 1 870 0
 2083 004c 2F4B     		ldr	r3, .L158+20
 2084 004e 6B60     		str	r3, [r5, #4]
 871:../Src/main.c **** 
 2085              		.loc 1 871 0
 2086 0050 2F4B     		ldr	r3, .L158+24
 2087 0052 EB60     		str	r3, [r5, #12]
 873:../Src/main.c **** 
 2088              		.loc 1 873 0
 2089 0054 4FF47A70 		mov	r0, #1000
 2090 0058 FFF7FEFF 		bl	HAL_Delay
 2091              	.LVL206:
 875:../Src/main.c **** 
 2092              		.loc 1 875 0
 2093 005c 2D4B     		ldr	r3, .L158+28
 2094 005e 04AE     		add	r6, sp, #16
 2095 0060 93E80300 		ldmia	r3, {r0, r1}
 2096 0064 86E80300 		stmia	r6, {r0, r1}
ARM GAS  /tmp/ccNelj9t.s 			page 62


 878:../Src/main.c ****   uint16_t positionGet;
 2097              		.loc 1 878 0
 2098 0068 0024     		movs	r4, #0
 2099 006a 06AB     		add	r3, sp, #24
 2100 006c 23F8124D 		strh	r4, [r3, #-18]!	@ movhi
 2101              	.LVL207:
 882:../Src/main.c ****   #if CONFIG==1
 2102              		.loc 1 882 0
 2103 0070 0122     		movs	r2, #1
 2104 0072 02A9     		add	r1, sp, #8
 2105 0074 2846     		mov	r0, r5
 2106 0076 FFF7FEFF 		bl	XL_Discover
 2107              	.LVL208:
 886:../Src/main.c ****   HAL_Delay(1000);
 2108              		.loc 1 886 0
 2109 007a 02A8     		add	r0, sp, #8
 2110 007c FFF7FEFF 		bl	XL_Say_Hello
 2111              	.LVL209:
 887:../Src/main.c ****   XL_Power_On(&broadcast, XL_NOW);
 2112              		.loc 1 887 0
 2113 0080 4FF47A70 		mov	r0, #1000
 2114 0084 FFF7FEFF 		bl	HAL_Delay
 2115              	.LVL210:
 888:../Src/main.c ****   /* USER CODE END 2 */
 2116              		.loc 1 888 0
 2117 0088 0121     		movs	r1, #1
 2118 008a 3046     		mov	r0, r6
 2119 008c FFF7FEFF 		bl	XL_Power_On
 2120              	.LVL211:
 836:../Src/main.c ****   /* USER CODE END 1 */
 2121              		.loc 1 836 0
 2122 0090 0226     		movs	r6, #2
 835:../Src/main.c ****   int UseSensorsMask = 1<<XNUCLEO53L0A1_DEV_CENTER;
 2123              		.loc 1 835 0
 2124 0092 2546     		mov	r5, r4
 2125 0094 04E0     		b	.L151
 2126              	.LVL212:
 2127              	.L154:
 927:../Src/main.c ****     	  }
 2128              		.loc 1 927 0
 2129 0096 0226     		movs	r6, #2
 2130              	.LVL213:
 2131 0098 02E0     		b	.L151
 2132              	.LVL214:
 2133              	.L155:
 931:../Src/main.c ****       }
 2134              		.loc 1 931 0
 2135 009a 0124     		movs	r4, #1
 2136              	.LVL215:
 2137 009c 00E0     		b	.L151
 2138              	.LVL216:
 2139              	.L156:
 2140 009e 0024     		movs	r4, #0
 2141              	.LVL217:
 2142              	.L151:
 898:../Src/main.c ****       HAL_Delay(ModeChangeDispTime);
 2143              		.loc 1 898 0
ARM GAS  /tmp/ccNelj9t.s 			page 63


 2144 00a0 1D4B     		ldr	r3, .L158+32
 2145 00a2 53F82500 		ldr	r0, [r3, r5, lsl #2]
 2146 00a6 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 2147              	.LVL218:
 899:../Src/main.c **** 
 2148              		.loc 1 899 0
 2149 00aa 4FF4FA70 		mov	r0, #500
 2150 00ae FFF7FEFF 		bl	HAL_Delay
 2151              	.LVL219:
 902:../Src/main.c **** 	  HAL_Delay(ModeChangeDispTime);
 2152              		.loc 1 902 0
 2153 00b2 1A4B     		ldr	r3, .L158+36
 2154 00b4 53F82400 		ldr	r0, [r3, r4, lsl #2]
 2155 00b8 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 2156              	.LVL220:
 903:../Src/main.c **** 
 2157              		.loc 1 903 0
 2158 00bc 4FF4FA70 		mov	r0, #500
 2159 00c0 FFF7FEFF 		bl	HAL_Delay
 2160              	.LVL221:
 906:../Src/main.c **** 
 2161              		.loc 1 906 0
 2162 00c4 0020     		movs	r0, #0
 2163 00c6 FFF7FEFF 		bl	ResetAndDetectSensor
 2164              	.LVL222:
 909:../Src/main.c **** 
 2165              		.loc 1 909 0
 2166 00ca FFF7FEFF 		bl	TimeStamp_Reset
 2167              	.LVL223:
 919:../Src/main.c **** 
 2168              		.loc 1 919 0
 2169 00ce 2146     		mov	r1, r4
 2170 00d0 3046     		mov	r0, r6
 2171 00d2 FFF7FEFF 		bl	RangeDemo
 2172              	.LVL224:
 922:../Src/main.c ****     	  /* Long press : change demo mode if multiple sensors present*/
 2173              		.loc 1 922 0
 2174 00d6 40B1     		cbz	r0, .L152
 924:../Src/main.c ****     		  /* If more than one sensor is present then toggle demo mode */
 2175              		.loc 1 924 0
 2176 00d8 114B     		ldr	r3, .L158+40
 2177 00da 1B68     		ldr	r3, [r3]
 2178 00dc 012B     		cmp	r3, #1
 2179 00de DFDD     		ble	.L151
 2180              	.LVL225:
 927:../Src/main.c ****     	  }
 2181              		.loc 1 927 0
 2182 00e0 95F00105 		eors	r5, r5, #1
 2183              	.LVL226:
 2184 00e4 D7D0     		beq	.L154
 2185 00e6 0726     		movs	r6, #7
 2186              	.LVL227:
 2187 00e8 DAE7     		b	.L151
 2188              	.LVL228:
 2189              	.L152:
 931:../Src/main.c ****       }
 2190              		.loc 1 931 0
ARM GAS  /tmp/ccNelj9t.s 			page 64


 2191 00ea 002C     		cmp	r4, #0
 2192 00ec D5D0     		beq	.L155
 931:../Src/main.c ****       }
 2193              		.loc 1 931 0 is_stmt 0 discriminator 1
 2194 00ee 012C     		cmp	r4, #1
 2195 00f0 D5D1     		bne	.L156
 931:../Src/main.c ****       }
 2196              		.loc 1 931 0
 2197 00f2 0224     		movs	r4, #2
 2198              	.LVL229:
 2199 00f4 D4E7     		b	.L151
 2200              	.L159:
 2201 00f6 00BF     		.align	2
 2202              	.L158:
 2203 00f8 30000000 		.word	.LC8
 2204 00fc 00000000 		.word	htim3
 2205 0100 00000000 		.word	interface
 2206 0104 00000000 		.word	XL_320_Send_HAL
 2207 0108 00000000 		.word	XL_320_Set_Direction_HAL
 2208 010c 00000000 		.word	XL_320_Receive_HAL
 2209 0110 00000000 		.word	XL_320_Delay_HAL
 2210 0114 00000000 		.word	.LANCHOR5
 2211 0118 00000000 		.word	.LANCHOR6
 2212 011c 00000000 		.word	.LANCHOR7
 2213 0120 00000000 		.word	.LANCHOR0
 2214              		.cfi_endproc
 2215              	.LFE132:
 2217              		.section	.text.HAL_TIM_PeriodElapsedCallback,"ax",%progbits
 2218              		.align	2
 2219              		.global	HAL_TIM_PeriodElapsedCallback
 2220              		.thumb
 2221              		.thumb_func
 2223              	HAL_TIM_PeriodElapsedCallback:
 2224              	.LFB139:
1124:../Src/main.c **** 
1125:../Src/main.c **** /* USER CODE BEGIN 4 */
1126:../Src/main.c **** 
1127:../Src/main.c **** void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim){ //£
 2225              		.loc 1 1127 0 is_stmt 1
 2226              		.cfi_startproc
 2227              		@ args = 0, pretend = 0, frame = 0
 2228              		@ frame_needed = 0, uses_anonymous_args = 0
 2229              	.LVL230:
 2230 0000 08B5     		push	{r3, lr}
 2231              	.LCFI46:
 2232              		.cfi_def_cfa_offset 8
 2233              		.cfi_offset 3, -8
 2234              		.cfi_offset 14, -4
1128:../Src/main.c ****   if(htim->Instance == htim3.Instance){
 2235              		.loc 1 1128 0
 2236 0002 0268     		ldr	r2, [r0]
 2237 0004 044B     		ldr	r3, .L163
 2238 0006 1B68     		ldr	r3, [r3]
 2239 0008 9A42     		cmp	r2, r3
 2240 000a 03D1     		bne	.L160
1129:../Src/main.c ****     HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);              /////changement d'etat de la led
 2241              		.loc 1 1129 0
ARM GAS  /tmp/ccNelj9t.s 			page 65


 2242 000c 2021     		movs	r1, #32
 2243 000e 0348     		ldr	r0, .L163+4
 2244              	.LVL231:
 2245 0010 FFF7FEFF 		bl	HAL_GPIO_TogglePin
 2246              	.LVL232:
 2247              	.L160:
 2248 0014 08BD     		pop	{r3, pc}
 2249              	.L164:
 2250 0016 00BF     		.align	2
 2251              	.L163:
 2252 0018 00000000 		.word	htim3
 2253 001c 00000240 		.word	1073872896
 2254              		.cfi_endproc
 2255              	.LFE139:
 2257              		.comm	interface,104,4
 2258              		.global	WelcomeMsg
 2259              		.comm	htim5,60,4
 2260              		.global	RangeMedium
 2261              		.global	RangeLow
 2262              		.global	VL53L0XDevs
 2263              		.comm	nDevMask,4,4
 2264              		.global	nDevPresent
 2265              		.global	LeakyFactorFix8
 2266              		.comm	RangingMeasurementData,28,4
 2267              		.global	DemoModeTxt
 2268              		.global	RangingConfigTxt
 2269              		.global	TxtBarGraph
 2270              		.global	TxtRangeValue
 2271              		.comm	huart2,60,4
 2272              		.comm	huart1,60,4
 2273              		.comm	htim3,60,4
 2274              		.comm	hi2c1,56,4
 2275              		.section	.rodata
 2276              		.align	2
 2277              		.set	.LANCHOR5,. + 0
 2278              	.LC0:
 2279 0000 FE       		.byte	-2
 2280 0001 000000   		.space	3
 2281 0004 00000000 		.word	interface
 2282              		.section	.bss.nDevPresent,"aw",%nobits
 2283              		.align	2
 2284              		.set	.LANCHOR0,. + 0
 2287              	nDevPresent:
 2288 0000 00000000 		.space	4
 2289              		.section	.rodata.TxtRangeValue,"a",%progbits
 2290              		.align	2
 2293              	TxtRangeValue:
 2294 0000 726E6700 		.ascii	"rng\000"
 2295              		.section	.data.VL53L0XDevs,"aw",%progbits
 2296              		.align	2
 2297              		.set	.LANCHOR1,. + 0
 2300              	VL53L0XDevs:
 2301 0000 00000000 		.space	348
 2301      00000000 
 2301      00000000 
 2301      00000000 
 2301      00000000 
ARM GAS  /tmp/ccNelj9t.s 			page 66


 2302 015c 00000000 		.word	XNUCLEO53L0A1_hi2c
 2303 0160 52       		.byte	82
 2304 0161 6C       		.byte	108
 2305 0162 0000     		.space	2
 2306 0164 00000000 		.word	0
 2307 0168 00000000 		.space	40
 2307      00000000 
 2307      00000000 
 2307      00000000 
 2307      00000000 
 2308 0190 00000000 		.space	348
 2308      00000000 
 2308      00000000 
 2308      00000000 
 2308      00000000 
 2309 02ec 00000000 		.word	XNUCLEO53L0A1_hi2c
 2310 02f0 52       		.byte	82
 2311 02f1 63       		.byte	99
 2312 02f2 0000     		.space	2
 2313 02f4 01000000 		.word	1
 2314 02f8 00000000 		.space	40
 2314      00000000 
 2314      00000000 
 2314      00000000 
 2314      00000000 
 2315 0320 00000000 		.space	348
 2315      00000000 
 2315      00000000 
 2315      00000000 
 2315      00000000 
 2316 047c 00000000 		.word	XNUCLEO53L0A1_hi2c
 2317 0480 52       		.byte	82
 2318 0481 72       		.byte	114
 2319 0482 0000     		.space	2
 2320 0484 02000000 		.word	2
 2321 0488 00000000 		.space	40
 2321      00000000 
 2321      00000000 
 2321      00000000 
 2321      00000000 
 2322              		.section	.data.LeakyFactorFix8,"aw",%progbits
 2323              		.align	2
 2324              		.set	.LANCHOR4,. + 0
 2327              	LeakyFactorFix8:
 2328 0000 99000000 		.word	153
 2329              		.section	.data.WelcomeMsg,"aw",%progbits
 2330              		.align	2
 2333              	WelcomeMsg:
 2334 0000 48692049 		.ascii	"Hi I am Ranging VL53L0X mcu STM32F401xE\012\000"
 2334      20616D20 
 2334      52616E67 
 2334      696E6720 
 2334      564C3533 
 2335              		.section	.rodata.str1.4,"aMS",%progbits,1
 2336              		.align	2
 2337              	.LC1:
 2338 0000 20726220 		.ascii	" rb \000"
ARM GAS  /tmp/ccNelj9t.s 			page 67


 2338      00
 2339 0005 000000   		.space	3
 2340              	.LC2:
 2341 0008 45722564 		.ascii	"Er%d\000"
 2341      00
 2342 000d 000000   		.space	3
 2343              	.LC3:
 2344 0010 20202020 		.ascii	"    \000"
 2344      00
 2345 0015 000000   		.space	3
 2346              	.LC4:
 2347 0018 25642C00 		.ascii	"%d,\000"
 2348              	.LC5:
 2349 001c 256400   		.ascii	"%d\000"
 2350 001f 00       		.space	1
 2351              	.LC6:
 2352 0020 25336463 		.ascii	"%3dc\000"
 2352      00
 2353 0025 000000   		.space	3
 2354              	.LC7:
 2355 0028 2D2D2D2D 		.ascii	"----\000"
 2355      00
 2356 002d 000000   		.space	3
 2357              	.LC8:
 2358 0030 35334C30 		.ascii	"53L0\000"
 2358      00
 2359 0035 000000   		.space	3
 2360              	.LC9:
 2361 0038 726E6700 		.ascii	"rng\000"
 2362              	.LC10:
 2363 003c 62617200 		.ascii	"bar\000"
 2364              	.LC11:
 2365 0040 4C5200   		.ascii	"LR\000"
 2366 0043 00       		.space	1
 2367              	.LC12:
 2368 0044 485300   		.ascii	"HS\000"
 2369 0047 00       		.space	1
 2370              	.LC13:
 2371 0048 484100   		.ascii	"HA\000"
 2372              		.section	.data.RangingConfigTxt,"aw",%progbits
 2373              		.align	2
 2374              		.set	.LANCHOR7,. + 0
 2377              	RangingConfigTxt:
 2378 0000 40000000 		.word	.LC11
 2379 0004 44000000 		.word	.LC12
 2380 0008 48000000 		.word	.LC13
 2381              		.section	.rodata.TxtBarGraph,"a",%progbits
 2382              		.align	2
 2385              	TxtBarGraph:
 2386 0000 62617200 		.ascii	"bar\000"
 2387              		.section	.data.RangeLow,"aw",%progbits
 2388              		.align	2
 2389              		.set	.LANCHOR2,. + 0
 2392              	RangeLow:
 2393 0000 64000000 		.word	100
 2394              		.section	.data.RangeMedium,"aw",%progbits
 2395              		.align	2
ARM GAS  /tmp/ccNelj9t.s 			page 68


 2396              		.set	.LANCHOR3,. + 0
 2399              	RangeMedium:
 2400 0000 2C010000 		.word	300
 2401              		.section	.data.DemoModeTxt,"aw",%progbits
 2402              		.align	2
 2403              		.set	.LANCHOR6,. + 0
 2406              	DemoModeTxt:
 2407 0000 38000000 		.word	.LC9
 2408 0004 3C000000 		.word	.LC10
 2409              		.text
 2410              	.Letext0:
 2411              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 2412              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 2413              		.file 4 "../Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f401xe.h"
 2414              		.file 5 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 2415              		.file 6 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_rcc.h"
 2416              		.file 7 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_gpio.h"
 2417              		.file 8 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 2418              		.file 9 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_i2c.h"
 2419              		.file 10 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_tim.h"
 2420              		.file 11 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_tim_ex.h"
 2421              		.file 12 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_uart.h"
 2422              		.file 13 "../Drivers/BSP/Components/vl53l0x/vl53l0x_types.h"
 2423              		.file 14 "../Drivers/BSP/Components/vl53l0x/vl53l0x_device.h"
 2424              		.file 15 "../Drivers/BSP/Components/vl53l0x/vl53l0x_def.h"
 2425              		.file 16 "../Drivers/BSP/X-NUCLEO-53L0A1/vl53l0x_platform.h"
 2426              		.file 17 "../Inc/xl_320.h"
 2427              		.file 18 "../Drivers/BSP/X-NUCLEO-53L0A1/X-NUCLEO-53L0A1.h"
 2428              		.file 19 "../Drivers/CMSIS/Include/core_cm4.h"
 2429              		.file 20 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal.h"
 2430              		.file 21 "/usr/include/newlib/stdio.h"
 2431              		.file 22 "../Drivers/BSP/Components/vl53l0x/vl53l0x_api.h"
 2432              		.file 23 "/usr/include/newlib/string.h"
ARM GAS  /tmp/ccNelj9t.s 			page 69


DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccNelj9t.s:22     .text.XL_320_Delay_HAL:00000000 $t
     /tmp/ccNelj9t.s:27     .text.XL_320_Delay_HAL:00000000 XL_320_Delay_HAL
     /tmp/ccNelj9t.s:48     .text.XL_320_Send_HAL:00000000 $t
     /tmp/ccNelj9t.s:53     .text.XL_320_Send_HAL:00000000 XL_320_Send_HAL
     /tmp/ccNelj9t.s:84     .text.XL_320_Send_HAL:00000018 $d
                            *COM*:0000003c huart1
     /tmp/ccNelj9t.s:89     .text.XL_320_Set_Direction_HAL:00000000 $t
     /tmp/ccNelj9t.s:94     .text.XL_320_Set_Direction_HAL:00000000 XL_320_Set_Direction_HAL
     /tmp/ccNelj9t.s:118    .text.XL_320_Set_Direction_HAL:00000014 $d
     /tmp/ccNelj9t.s:123    .text.XL_320_Receive_HAL:00000000 $t
     /tmp/ccNelj9t.s:128    .text.XL_320_Receive_HAL:00000000 XL_320_Receive_HAL
     /tmp/ccNelj9t.s:159    .text.XL_320_Receive_HAL:00000018 $d
     /tmp/ccNelj9t.s:164    .text.MX_GPIO_Init:00000000 $t
     /tmp/ccNelj9t.s:168    .text.MX_GPIO_Init:00000000 MX_GPIO_Init
     /tmp/ccNelj9t.s:315    .text.MX_GPIO_Init:000000d0 $d
     /tmp/ccNelj9t.s:324    .text.SystemClock_Config:00000000 $t
     /tmp/ccNelj9t.s:328    .text.SystemClock_Config:00000000 SystemClock_Config
     /tmp/ccNelj9t.s:410    .text.SystemClock_Config:00000064 $d
     /tmp/ccNelj9t.s:415    .text.MX_I2C1_Init:00000000 $t
     /tmp/ccNelj9t.s:419    .text.MX_I2C1_Init:00000000 MX_I2C1_Init
     /tmp/ccNelj9t.s:460    .text.MX_I2C1_Init:00000028 $d
                            *COM*:00000038 hi2c1
     /tmp/ccNelj9t.s:467    .text.MX_TIM3_Init:00000000 $t
     /tmp/ccNelj9t.s:471    .text.MX_TIM3_Init:00000000 MX_TIM3_Init
     /tmp/ccNelj9t.s:531    .text.MX_TIM3_Init:00000044 $d
                            *COM*:0000003c htim3
     /tmp/ccNelj9t.s:537    .text.MX_USART2_UART_Init:00000000 $t
     /tmp/ccNelj9t.s:541    .text.MX_USART2_UART_Init:00000000 MX_USART2_UART_Init
     /tmp/ccNelj9t.s:580    .text.MX_USART2_UART_Init:00000024 $d
                            *COM*:0000003c huart2
     /tmp/ccNelj9t.s:586    .text.MX_USART1_UART_Init:00000000 $t
     /tmp/ccNelj9t.s:590    .text.MX_USART1_UART_Init:00000000 MX_USART1_UART_Init
     /tmp/ccNelj9t.s:629    .text.MX_USART1_UART_Init:00000024 $d
     /tmp/ccNelj9t.s:636    .text.MX_TIM5_Init:00000000 $t
     /tmp/ccNelj9t.s:641    .text.MX_TIM5_Init:00000000 MX_TIM5_Init
     /tmp/ccNelj9t.s:707    .text.MX_TIM5_Init:00000044 $d
                            *COM*:0000003c htim5
     /tmp/ccNelj9t.s:713    .text.TimeStamp_Init:00000000 $t
     /tmp/ccNelj9t.s:718    .text.TimeStamp_Init:00000000 TimeStamp_Init
     /tmp/ccNelj9t.s:737    .text.TimeStamp_Reset:00000000 $t
     /tmp/ccNelj9t.s:742    .text.TimeStamp_Reset:00000000 TimeStamp_Reset
     /tmp/ccNelj9t.s:766    .text.TimeStamp_Reset:00000014 $d
     /tmp/ccNelj9t.s:771    .text.TimeStamp_Get:00000000 $t
     /tmp/ccNelj9t.s:776    .text.TimeStamp_Get:00000000 TimeStamp_Get
     /tmp/ccNelj9t.s:792    .text.TimeStamp_Get:00000008 $d
     /tmp/ccNelj9t.s:797    .text.BSP_GetPushButton:00000000 $t
     /tmp/ccNelj9t.s:802    .text.BSP_GetPushButton:00000000 BSP_GetPushButton
     /tmp/ccNelj9t.s:823    .text.BSP_GetPushButton:00000010 $d
     /tmp/ccNelj9t.s:828    .text.PusbButton_WaitUnPress:00000000 $t
     /tmp/ccNelj9t.s:833    .text.PusbButton_WaitUnPress:00000000 PusbButton_WaitUnPress
     /tmp/ccNelj9t.s:883    .text.PusbButton_WaitUnPress:00000038 $d
     /tmp/ccNelj9t.s:888    .text.HandleError:00000000 $t
     /tmp/ccNelj9t.s:893    .text.HandleError:00000000 HandleError
     /tmp/ccNelj9t.s:923    .text.HandleError:00000018 $d
     /tmp/ccNelj9t.s:928    .text.DetectSensors:00000000 $t
ARM GAS  /tmp/ccNelj9t.s 			page 70


     /tmp/ccNelj9t.s:933    .text.DetectSensors:00000000 DetectSensors
     /tmp/ccNelj9t.s:1172   .text.DetectSensors:00000148 $d
                            *COM*:00000004 nDevMask
     /tmp/ccNelj9t.s:1180   .text.SetupSingleShot:00000000 $t
     /tmp/ccNelj9t.s:1185   .text.SetupSingleShot:00000000 SetupSingleShot
     /tmp/ccNelj9t.s:1376   .text.SetupSingleShot:0000011c $d
     /tmp/ccNelj9t.s:1382   .text.RangeToLetter:00000000 $t
     /tmp/ccNelj9t.s:1387   .text.RangeToLetter:00000000 RangeToLetter
     /tmp/ccNelj9t.s:1435   .text.RangeToLetter:00000028 $d
     /tmp/ccNelj9t.s:1441   .text.Sensor_SetNewRange:00000000 $t
     /tmp/ccNelj9t.s:1446   .text.Sensor_SetNewRange:00000000 Sensor_SetNewRange
     /tmp/ccNelj9t.s:1508   .text.Sensor_SetNewRange:00000048 $d
     /tmp/ccNelj9t.s:1513   .text.blink_led:00000000 $t
     /tmp/ccNelj9t.s:1518   .text.blink_led:00000000 blink_led
     /tmp/ccNelj9t.s:1573   .text.blink_led:00000030 $d
     /tmp/ccNelj9t.s:1578   .text.transmit:00000000 $t
     /tmp/ccNelj9t.s:1583   .text.transmit:00000000 transmit
     /tmp/ccNelj9t.s:1680   .text.transmit:00000074 $d
     /tmp/ccNelj9t.s:1687   .text.RangeDemo:00000000 $t
     /tmp/ccNelj9t.s:1692   .text.RangeDemo:00000000 RangeDemo
     /tmp/ccNelj9t.s:1953   .text.RangeDemo:00000178 $d
                            *COM*:0000001c RangingMeasurementData
     /tmp/ccNelj9t.s:1964   .text.ResetAndDetectSensor:00000000 $t
     /tmp/ccNelj9t.s:1969   .text.ResetAndDetectSensor:00000000 ResetAndDetectSensor
     /tmp/ccNelj9t.s:2005   .text.ResetAndDetectSensor:00000020 $d
     /tmp/ccNelj9t.s:2010   .text.main:00000000 $t
     /tmp/ccNelj9t.s:2015   .text.main:00000000 main
     /tmp/ccNelj9t.s:2203   .text.main:000000f8 $d
                            *COM*:00000068 interface
     /tmp/ccNelj9t.s:2218   .text.HAL_TIM_PeriodElapsedCallback:00000000 $t
     /tmp/ccNelj9t.s:2223   .text.HAL_TIM_PeriodElapsedCallback:00000000 HAL_TIM_PeriodElapsedCallback
     /tmp/ccNelj9t.s:2252   .text.HAL_TIM_PeriodElapsedCallback:00000018 $d
     /tmp/ccNelj9t.s:2333   .data.WelcomeMsg:00000000 WelcomeMsg
     /tmp/ccNelj9t.s:2399   .data.RangeMedium:00000000 RangeMedium
     /tmp/ccNelj9t.s:2392   .data.RangeLow:00000000 RangeLow
     /tmp/ccNelj9t.s:2300   .data.VL53L0XDevs:00000000 VL53L0XDevs
     /tmp/ccNelj9t.s:2287   .bss.nDevPresent:00000000 nDevPresent
     /tmp/ccNelj9t.s:2327   .data.LeakyFactorFix8:00000000 LeakyFactorFix8
     /tmp/ccNelj9t.s:2406   .data.DemoModeTxt:00000000 DemoModeTxt
     /tmp/ccNelj9t.s:2377   .data.RangingConfigTxt:00000000 RangingConfigTxt
     /tmp/ccNelj9t.s:2385   .rodata.TxtBarGraph:00000000 TxtBarGraph
     /tmp/ccNelj9t.s:2293   .rodata.TxtRangeValue:00000000 TxtRangeValue
     /tmp/ccNelj9t.s:2276   .rodata:00000000 $d
     /tmp/ccNelj9t.s:2283   .bss.nDevPresent:00000000 $d
     /tmp/ccNelj9t.s:2290   .rodata.TxtRangeValue:00000000 $d
     /tmp/ccNelj9t.s:2296   .data.VL53L0XDevs:00000000 $d
     /tmp/ccNelj9t.s:2323   .data.LeakyFactorFix8:00000000 $d
     /tmp/ccNelj9t.s:2330   .data.WelcomeMsg:00000000 $d
     /tmp/ccNelj9t.s:2336   .rodata.str1.4:00000000 $d
     /tmp/ccNelj9t.s:2373   .data.RangingConfigTxt:00000000 $d
     /tmp/ccNelj9t.s:2382   .rodata.TxtBarGraph:00000000 $d
     /tmp/ccNelj9t.s:2388   .data.RangeLow:00000000 $d
     /tmp/ccNelj9t.s:2395   .data.RangeMedium:00000000 $d
     /tmp/ccNelj9t.s:2402   .data.DemoModeTxt:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ARM GAS  /tmp/ccNelj9t.s 			page 71


HAL_Delay
HAL_UART_Transmit
HAL_GPIO_WritePin
HAL_UART_Receive
HAL_GPIO_Init
HAL_RCC_OscConfig
HAL_RCC_ClockConfig
HAL_I2C_Init
HAL_TIM_Base_Init
HAL_TIM_ConfigClockSource
HAL_TIMEx_MasterConfigSynchronization
HAL_UART_Init
HAL_TIM_OC_Init
HAL_TIM_OC_ConfigChannel
HAL_TIM_Base_Start
HAL_GPIO_ReadPin
HAL_GetTick
XNUCLEO53L0A1_SetDisplayString
sprintf
XNUCLEO53L0A1_ResetId
VL53L0X_WrByte
VL53L0X_RdWord
VL53L0X_SetDeviceAddress
VL53L0X_DataInit
VL53L0X_StaticInit
VL53L0X_PerformRefCalibration
VL53L0X_PerformRefSpadManagement
VL53L0X_SetDeviceMode
VL53L0X_SetLimitCheckEnable
VL53L0X_SetLimitCheckValue
VL53L0X_SetMeasurementTimingBudgetMicroSeconds
VL53L0X_SetVcselPulsePeriod
HAL_TIM_Base_Stop_IT
HAL_TIM_Base_Start_IT
strcat
strlen
VL53L0X_PerformSingleRangingMeasurement
HAL_Init
XNUCLEO53L0A1_Init
XL_Discover
XL_Say_Hello
XL_Power_On
HAL_GPIO_TogglePin
XNUCLEO53L0A1_hi2c
