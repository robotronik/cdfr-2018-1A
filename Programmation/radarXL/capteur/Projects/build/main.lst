ARM GAS  /tmp/ccx8Hxdu.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.syntax unified
  17              		.file	"main.c"
  18              		.text
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.section	.text.MX_GPIO_Init,"ax",%progbits
  22              		.align	2
  23              		.thumb
  24              		.thumb_func
  26              	MX_GPIO_Init:
  27              	.LFB135:
  28              		.file 1 "../Src/main.c"
   1:../Src/main.c **** /*!!!!!WARNING : ALIMENTATION!!!!!
   2:../Src/main.c **** ~> Nucleo : 5V ?(ordi)
   3:../Src/main.c **** -> Servo : 7.40V / 500mA ?
   4:../Src/main.c **** */
   5:../Src/main.c **** 
   6:../Src/main.c **** 
   7:../Src/main.c **** /**
   8:../Src/main.c ****   ******************************************************************************
   9:../Src/main.c ****   * File Name          : main.c
  10:../Src/main.c ****   * Date               : 01/03/2018 16:55:48
  11:../Src/main.c ****   * Description        : Main program body
  12:../Src/main.c ****   ******************************************************************************
  13:../Src/main.c ****   *
  14:../Src/main.c ****   * COPYRIGHT(c) 2018 STMicroelectronics
  15:../Src/main.c ****   *
  16:../Src/main.c ****   * Redistribution and use in source and binary forms, with or without modification,
  17:../Src/main.c ****   * are permitted provided that the following conditions are met:
  18:../Src/main.c ****   *   1. Redistributions of source code must retain the above copyright notice,
  19:../Src/main.c ****   *      this list of conditions and the following disclaimer.
  20:../Src/main.c ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
  21:../Src/main.c ****   *      this list of conditions and the following disclaimer in the documentation
  22:../Src/main.c ****   *      and/or other materials provided with the distribution.
  23:../Src/main.c ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
  24:../Src/main.c ****   *      may be used to endorse or promote products derived from this software
  25:../Src/main.c ****   *      without specific prior written permission.
  26:../Src/main.c ****   *
  27:../Src/main.c ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  28:../Src/main.c ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  29:../Src/main.c ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  30:../Src/main.c ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
ARM GAS  /tmp/ccx8Hxdu.s 			page 2


  31:../Src/main.c ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  32:../Src/main.c ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  33:../Src/main.c ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  34:../Src/main.c ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  35:../Src/main.c ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  36:../Src/main.c ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  37:../Src/main.c ****   *
  38:../Src/main.c ****   ******************************************************************************
  39:../Src/main.c ****   */
  40:../Src/main.c **** 
  41:../Src/main.c **** /* Includes ------------------------------------------------------------------*/
  42:../Src/main.c **** #include "stm32f4xx_hal.h"
  43:../Src/main.c **** 
  44:../Src/main.c **** /* USER CODE BEGIN Includes */
  45:../Src/main.c **** #include <string.h>
  46:../Src/main.c **** #include "X-NUCLEO-53L0A1.h"
  47:../Src/main.c **** #include "vl53l0x_api.h"
  48:../Src/main.c **** #include <limits.h>
  49:../Src/main.c **** #include <stdio.h>
  50:../Src/main.c **** #include <stdlib.h>
  51:../Src/main.c **** #include "xl_320.h"
  52:../Src/main.c **** #include "servo.h"
  53:../Src/main.c **** 
  54:../Src/main.c **** /**
  55:../Src/main.c ****  * @defgroup Configuration Static configuration
  56:../Src/main.c ****  * @{
  57:../Src/main.c ****  */
  58:../Src/main.c **** #define HAVE_ALARM_DEMO 0
  59:../Src/main.c **** 
  60:../Src/main.c **** /** Time the initial 53L0 message is shown at power up */
  61:../Src/main.c **** #define WelcomeTime 660
  62:../Src/main.c **** 
  63:../Src/main.c **** /** Time the initial 53L0 message is shown at power up */
  64:../Src/main.c **** #define ModeChangeDispTime  500
  65:../Src/main.c **** 
  66:../Src/main.c **** /**
  67:../Src/main.c ****  * Time considered as  a "long push" on push button
  68:../Src/main.c ****  */
  69:../Src/main.c **** #define PressBPSwicthTime   1000
  70:../Src/main.c **** 
  71:../Src/main.c **** /** @}  */ /* config group */
  72:../Src/main.c **** 
  73:../Src/main.c **** #ifndef MIN
  74:../Src/main.c **** #   define MIN(a,b) ((a) < (b) ? (a) : (b))
  75:../Src/main.c **** #endif
  76:../Src/main.c **** 
  77:../Src/main.c **** #define B1_Pin GPIO_PIN_13
  78:../Src/main.c **** #define B1_GPIO_Port GPIOC
  79:../Src/main.c **** #define LD2_Pin GPIO_PIN_5
  80:../Src/main.c **** #define LD2_GPIO_Port GPIOA
  81:../Src/main.c **** #define USART1_DIR_Pin GPIO_PIN_9
  82:../Src/main.c **** #define USART1_DIR_GPIO_Port GPIOC
  83:../Src/main.c **** 
  84:../Src/main.c **** 
  85:../Src/main.c **** #ifndef ARRAY_SIZE
  86:../Src/main.c **** #   define ARRAY_SIZE(x) (sizeof((x))/sizeof((x)[0]))
  87:../Src/main.c **** #endif
ARM GAS  /tmp/ccx8Hxdu.s 			page 3


  88:../Src/main.c **** 
  89:../Src/main.c **** /**
  90:../Src/main.c ****  * @defgroup ErrCode Errors code shown on display
  91:../Src/main.c ****  * @{
  92:../Src/main.c ****  */
  93:../Src/main.c **** #define ERR_DETECT             -1
  94:../Src/main.c **** #define ERR_DEMO_RANGE_ONE     1
  95:../Src/main.c **** #define ERR_DEMO_RANGE_MULTI   2
  96:../Src/main.c **** 
  97:../Src/main.c **** 
  98:../Src/main.c **** /** }@} */ /* defgroup ErrCode */
  99:../Src/main.c **** 
 100:../Src/main.c **** 
 101:../Src/main.c **** /* USER CODE END Includes */
 102:../Src/main.c **** 
 103:../Src/main.c **** /* Private variables ---------------------------------------------------------*/
 104:../Src/main.c **** I2C_HandleTypeDef hi2c1;
 105:../Src/main.c **** 
 106:../Src/main.c **** TIM_HandleTypeDef htim3;
 107:../Src/main.c **** 
 108:../Src/main.c **** UART_HandleTypeDef huart1;
 109:../Src/main.c **** UART_HandleTypeDef huart2;
 110:../Src/main.c **** 
 111:../Src/main.c **** /* USER CODE BEGIN PV */
 112:../Src/main.c **** /* Private variables ---------------------------------------------------------*/
 113:../Src/main.c **** 
 114:../Src/main.c **** const char TxtRangeValue[]  = "rng";
 115:../Src/main.c **** const char TxtBarGraph[]    = "bar";
 116:../Src/main.c **** #if HAVE_ALARM_DEMO
 117:../Src/main.c **** const char TxtAlarm[]       = "Alr";
 118:../Src/main.c **** #endif
 119:../Src/main.c **** 
 120:../Src/main.c **** 
 121:../Src/main.c **** typedef enum {
 122:../Src/main.c **** 	LONG_RANGE 		= 0, /*!< Long range mode */
 123:../Src/main.c **** 	HIGH_SPEED 		= 1, /*!< High speed mode */
 124:../Src/main.c **** 	HIGH_ACCURACY	= 2, /*!< High accuracy mode */
 125:../Src/main.c **** } RangingConfig_e;
 126:../Src/main.c **** char *RangingConfigTxt[3] = {"LR", "HS", "HA"};
 127:../Src/main.c **** 
 128:../Src/main.c **** typedef enum {
 129:../Src/main.c **** 	RANGE_VALUE 	= 0, /*!< Range displayed in cm */
 130:../Src/main.c **** 	BAR_GRAPH 		= 1, /*!< Range displayed as a bar graph : one bar per sensor */
 131:../Src/main.c **** } DemoMode_e;
 132:../Src/main.c **** char *DemoModeTxt[2] = {"rng", "bar"};
 133:../Src/main.c **** 
 134:../Src/main.c **** /**
 135:../Src/main.c ****  * Global ranging struct
 136:../Src/main.c ****  */
 137:../Src/main.c **** VL53L0X_RangingMeasurementData_t RangingMeasurementData;
 138:../Src/main.c **** 
 139:../Src/main.c **** 
 140:../Src/main.c **** /** leaky factor for filtered range
 141:../Src/main.c ****  *
 142:../Src/main.c ****  * r(n) = averaged_r(n-1)*leaky +r(n)(1-leaky)
 143:../Src/main.c ****  *
 144:../Src/main.c ****  * */
ARM GAS  /tmp/ccx8Hxdu.s 			page 4


 145:../Src/main.c **** int LeakyFactorFix8 = (int)( 0.6 *256);
 146:../Src/main.c **** /** How many device detect set by @a DetectSensors()*/
 147:../Src/main.c **** int nDevPresent=0;
 148:../Src/main.c **** /** bit is index in VL53L0XDevs that is not necessary the dev id of the BSP */
 149:../Src/main.c **** int nDevMask;
 150:../Src/main.c **** 
 151:../Src/main.c **** 
 152:../Src/main.c **** VL53L0X_Dev_t VL53L0XDevs[]={
 153:../Src/main.c ****         {.Id=XNUCLEO53L0A1_DEV_LEFT, .DevLetter='l', .I2cHandle=&XNUCLEO53L0A1_hi2c, .I2cDevAddr=0x
 154:../Src/main.c ****         {.Id=XNUCLEO53L0A1_DEV_CENTER, .DevLetter='c', .I2cHandle=&XNUCLEO53L0A1_hi2c, .I2cDevAddr=
 155:../Src/main.c ****         {.Id=XNUCLEO53L0A1_DEV_RIGHT, .DevLetter='r', .I2cHandle=&XNUCLEO53L0A1_hi2c, .I2cDevAddr=0
 156:../Src/main.c **** };
 157:../Src/main.c **** 
 158:../Src/main.c **** /** range low (and high) in @a RangeToLetter()
 159:../Src/main.c ****  *
 160:../Src/main.c ****  * used for displaying  multiple sensor as bar graph
 161:../Src/main.c ****  */
 162:../Src/main.c **** int RangeLow=100;
 163:../Src/main.c **** 
 164:../Src/main.c **** /** range medium in @a RangeToLetter()
 165:../Src/main.c ****  *
 166:../Src/main.c ****  * used for displaying  multiple sensor as bar graph
 167:../Src/main.c ****  */
 168:../Src/main.c **** int RangeMedium=300;
 169:../Src/main.c **** 
 170:../Src/main.c **** /** Timer
 171:../Src/main.c ****  *
 172:../Src/main.c ****  * Used to get time stamp for UART logging
 173:../Src/main.c ****  */
 174:../Src/main.c **** TIM_HandleTypeDef htim5;
 175:../Src/main.c **** 
 176:../Src/main.c **** /* TIM5 init function */
 177:../Src/main.c **** void MX_TIM5_Init(void)
 178:../Src/main.c **** {
 179:../Src/main.c **** 
 180:../Src/main.c ****   TIM_MasterConfigTypeDef sMasterConfig;
 181:../Src/main.c ****   TIM_OC_InitTypeDef sConfigOC;
 182:../Src/main.c **** 
 183:../Src/main.c ****   htim5.Instance = TIM5;
 184:../Src/main.c ****   htim5.Init.Prescaler = 83;
 185:../Src/main.c ****   htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 186:../Src/main.c ****   htim5.Init.Period = 0xFFFFFFFF;
 187:../Src/main.c ****   htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 188:../Src/main.c ****   HAL_TIM_OC_Init(&htim5);
 189:../Src/main.c **** 
 190:../Src/main.c ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 191:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 192:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig);
 193:../Src/main.c **** 
 194:../Src/main.c ****   sConfigOC.OCMode = TIM_OCMODE_TIMING;
 195:../Src/main.c ****   sConfigOC.Pulse = 0;
 196:../Src/main.c ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 197:../Src/main.c ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 198:../Src/main.c ****   HAL_TIM_OC_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1);
 199:../Src/main.c **** 
 200:../Src/main.c **** }
 201:../Src/main.c **** 
ARM GAS  /tmp/ccx8Hxdu.s 			page 5


 202:../Src/main.c **** void TimeStamp_Init(){
 203:../Src/main.c ****     MX_TIM5_Init();
 204:../Src/main.c **** }
 205:../Src/main.c **** 
 206:../Src/main.c **** void TimeStamp_Reset(){
 207:../Src/main.c ****     HAL_TIM_Base_Start(&htim5);
 208:../Src/main.c ****     htim5.Instance->CNT=0;
 209:../Src/main.c **** }
 210:../Src/main.c **** 
 211:../Src/main.c **** uint32_t TimeStamp_Get(){
 212:../Src/main.c ****     return htim5.Instance->CNT;
 213:../Src/main.c **** }
 214:../Src/main.c **** 
 215:../Src/main.c **** /* USER CODE END PV */
 216:../Src/main.c **** 
 217:../Src/main.c **** /* Private function prototypes -----------------------------------------------*/
 218:../Src/main.c **** static void MX_GPIO_Init(void);
 219:../Src/main.c **** static void SystemClock_Config(void);
 220:../Src/main.c **** static void MX_I2C1_Init(void);
 221:../Src/main.c **** static void MX_TIM3_Init(void);
 222:../Src/main.c **** static void MX_USART2_UART_Init(void);
 223:../Src/main.c **** static void MX_USART1_UART_Init(void);
 224:../Src/main.c **** 
 225:../Src/main.c **** /* USER CODE BEGIN PFP */
 226:../Src/main.c **** /* Private function prototypes -----------------------------------------------*/
 227:../Src/main.c **** void ResetAndDetectSensor(int SetDisplay);
 228:../Src/main.c **** 
 229:../Src/main.c **** /* USER CODE END PFP */
 230:../Src/main.c **** 
 231:../Src/main.c **** /* USER CODE BEGIN 0 */
 232:../Src/main.c **** 
 233:../Src/main.c **** #define debug_printf    trace_printf
 234:../Src/main.c **** char WelcomeMsg[]="Hi I am Ranging VL53L0X mcu " MCU_NAME "\n";
 235:../Src/main.c **** 
 236:../Src/main.c **** #if HAVE_ALARM_DEMO
 237:../Src/main.c **** volatile int IntrCount;
 238:../Src/main.c **** volatile int LastIntrPin;
 239:../Src/main.c **** volatile int LastIntrId;
 240:../Src/main.c **** volatile int IntrCounts[3];
 241:../Src/main.c **** #endif
 242:../Src/main.c **** 
 243:../Src/main.c **** #define BSP_BP_PORT GPIOC
 244:../Src/main.c **** #define BSP_BP_PIN  GPIO_PIN_13
 245:../Src/main.c **** 
 246:../Src/main.c **** int BSP_GetPushButton(void){
 247:../Src/main.c ****     GPIO_PinState state ;
 248:../Src/main.c ****     state = HAL_GPIO_ReadPin(BSP_BP_PORT, BSP_BP_PIN);
 249:../Src/main.c ****     return state;
 250:../Src/main.c **** }
 251:../Src/main.c **** 
 252:../Src/main.c **** /**
 253:../Src/main.c ****  * When button is already pressed it waits for user to release it.
 254:../Src/main.c ****  * if button remains pressed for a given time it returns true.
 255:../Src/main.c ****  * This is used to detect mode switch by long press on blue Push Button
 256:../Src/main.c ****  *
 257:../Src/main.c ****  * As soon as time is elapsed -rb- is displayed to let user know the mode
 258:../Src/main.c ****  * switch is taken into account
ARM GAS  /tmp/ccx8Hxdu.s 			page 6


 259:../Src/main.c ****  *
 260:../Src/main.c ****  * @return True if button remains pressed more than specified time
 261:../Src/main.c ****  */
 262:../Src/main.c **** int PusbButton_WaitUnPress(void){
 263:../Src/main.c ****     uint32_t TimeStarted;
 264:../Src/main.c ****     TimeStarted = HAL_GetTick();
 265:../Src/main.c ****     while( !BSP_GetPushButton() ){ ; /* debounce */
 266:../Src/main.c ****         if(HAL_GetTick()- TimeStarted> PressBPSwicthTime){
 267:../Src/main.c ****             XNUCLEO53L0A1_SetDisplayString (" rb ");
 268:../Src/main.c ****         }
 269:../Src/main.c ****     }
 270:../Src/main.c ****     return  HAL_GetTick() - TimeStarted>PressBPSwicthTime;
 271:../Src/main.c **** 
 272:../Src/main.c **** }
 273:../Src/main.c **** 
 274:../Src/main.c **** #if HAVE_ALARM_DEMO
 275:../Src/main.c **** /**
 276:../Src/main.c ****  * Interrupt handler called each time an interrupt is produced by the ranging sensor (in ALARM mode
 277:../Src/main.c ****  * @param err
 278:../Src/main.c ****  */
 279:../Src/main.c **** void VL53L0A1_EXTI_Callback(int DevNo, int GPIO_Pin){
 280:../Src/main.c ****     IntrCount++;
 281:../Src/main.c ****     LastIntrPin=GPIO_Pin;
 282:../Src/main.c ****     LastIntrId=DevNo;
 283:../Src/main.c **** 
 284:../Src/main.c ****     if( DevNo< ARRAY_SIZE(IntrCounts)  ){
 285:../Src/main.c ****         IntrCounts[DevNo]++;
 286:../Src/main.c ****     }
 287:../Src/main.c **** }
 288:../Src/main.c **** #endif
 289:../Src/main.c **** 
 290:../Src/main.c **** 
 291:../Src/main.c **** /**
 292:../Src/main.c ****  * Handle Error
 293:../Src/main.c ****  *
 294:../Src/main.c ****  * Set err on display and loop forever
 295:../Src/main.c ****  * @param err Error case code
 296:../Src/main.c ****  */
 297:../Src/main.c **** void HandleError(int err){
 298:../Src/main.c ****     char msg[16];
 299:../Src/main.c ****     sprintf(msg,"Er%d", err);
 300:../Src/main.c ****     XNUCLEO53L0A1_SetDisplayString(msg);
 301:../Src/main.c ****     while(1){};
 302:../Src/main.c **** }
 303:../Src/main.c **** 
 304:../Src/main.c **** /**
 305:../Src/main.c ****  * Reset all sensor then do presence detection
 306:../Src/main.c ****  *
 307:../Src/main.c ****  * All present devices are data initiated and assigned to their final I2C address
 308:../Src/main.c ****  * @return
 309:../Src/main.c ****  */
 310:../Src/main.c **** int DetectSensors(int SetDisplay) {
 311:../Src/main.c ****     int i;
 312:../Src/main.c ****     uint16_t Id;
 313:../Src/main.c ****     int status;
 314:../Src/main.c ****     int FinalAddress;
 315:../Src/main.c **** 
ARM GAS  /tmp/ccx8Hxdu.s 			page 7


 316:../Src/main.c ****     char PresentMsg[5]="    ";
 317:../Src/main.c ****     /* Reset all */
 318:../Src/main.c ****     nDevPresent = 0;
 319:../Src/main.c ****     for (i = 0; i < 3; i++)
 320:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 321:../Src/main.c **** 
 322:../Src/main.c ****     /* detect all sensors (even on-board)*/
 323:../Src/main.c ****     for (i = 0; i < 3; i++) {
 324:../Src/main.c ****         VL53L0X_Dev_t *pDev;
 325:../Src/main.c ****         pDev = &VL53L0XDevs[i];
 326:../Src/main.c ****         pDev->I2cDevAddr = 0x52;
 327:../Src/main.c ****         pDev->Present = 0;
 328:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId( pDev->Id, 1);
 329:../Src/main.c ****         HAL_Delay(2);
 330:../Src/main.c ****         FinalAddress=0x52+(i+1)*2;
 331:../Src/main.c **** 
 332:../Src/main.c ****         do {
 333:../Src/main.c ****         	/* Set I2C standard mode (400 KHz) before doing the first register access */
 334:../Src/main.c ****         	if (status == VL53L0X_ERROR_NONE)
 335:../Src/main.c ****         		status = VL53L0X_WrByte(pDev, 0x88, 0x00);
 336:../Src/main.c **** 
 337:../Src/main.c ****         	/* Try to read one register using default 0x52 address */
 338:../Src/main.c ****             status = VL53L0X_RdWord(pDev, VL53L0X_REG_IDENTIFICATION_MODEL_ID, &Id);
 339:../Src/main.c ****             if (status) {
 340:../Src/main.c ****                 debug_printf("#%d Read id fail\n", i);
 341:../Src/main.c ****                 break;
 342:../Src/main.c ****             }
 343:../Src/main.c ****             if (Id == 0xEEAA) {
 344:../Src/main.c **** 				/* Sensor is found => Change its I2C address to final one */
 345:../Src/main.c ****                 status = VL53L0X_SetDeviceAddress(pDev,FinalAddress);
 346:../Src/main.c ****                 if (status != 0) {
 347:../Src/main.c ****                     debug_printf("#i VL53L0X_SetDeviceAddress fail\n", i);
 348:../Src/main.c ****                     break;
 349:../Src/main.c ****                 }
 350:../Src/main.c ****                 pDev->I2cDevAddr = FinalAddress;
 351:../Src/main.c ****                 /* Check all is OK with the new I2C address and initialize the sensor */
 352:../Src/main.c ****                 status = VL53L0X_RdWord(pDev, VL53L0X_REG_IDENTIFICATION_MODEL_ID, &Id);
 353:../Src/main.c ****                 if (status != 0) {
 354:../Src/main.c **** 					debug_printf("#i VL53L0X_RdWord fail\n", i);
 355:../Src/main.c **** 					break;
 356:../Src/main.c **** 				}
 357:../Src/main.c **** 
 358:../Src/main.c ****                 status = VL53L0X_DataInit(pDev);
 359:../Src/main.c ****                 if( status == 0 ){
 360:../Src/main.c ****                     pDev->Present = 1;
 361:../Src/main.c ****                 }
 362:../Src/main.c ****                 else{
 363:../Src/main.c ****                     debug_printf("VL53L0X_DataInit %d fail\n", i);
 364:../Src/main.c ****                     break;
 365:../Src/main.c ****                 }
 366:../Src/main.c ****                 trace_printf("VL53L0X %d Present and initiated to final 0x%x\n", pDev->Id, pDev->I2
 367:../Src/main.c ****                 nDevPresent++;
 368:../Src/main.c ****                 nDevMask |= 1 << i;
 369:../Src/main.c ****                 pDev->Present = 1;
 370:../Src/main.c ****             }
 371:../Src/main.c ****             else {
 372:../Src/main.c ****                 debug_printf("#%d unknown ID %x\n", i, Id);
ARM GAS  /tmp/ccx8Hxdu.s 			page 8


 373:../Src/main.c ****                 status = 1;
 374:../Src/main.c ****             }
 375:../Src/main.c ****         } while (0);
 376:../Src/main.c ****         /* if fail r can't use for any reason then put the  device back to reset */
 377:../Src/main.c ****         if (status) {
 378:../Src/main.c ****             XNUCLEO53L0A1_ResetId(i, 0);
 379:../Src/main.c ****         }
 380:../Src/main.c ****     }
 381:../Src/main.c ****     /* Display detected sensor(s) */
 382:../Src/main.c ****     if( SetDisplay ){
 383:../Src/main.c ****         for(i=0; i<3; i++){
 384:../Src/main.c ****             if( VL53L0XDevs[i].Present ){
 385:../Src/main.c ****                 PresentMsg[i+1]=VL53L0XDevs[i].DevLetter;
 386:../Src/main.c ****             }
 387:../Src/main.c ****         }
 388:../Src/main.c ****         PresentMsg[0]=' ';
 389:../Src/main.c ****         XNUCLEO53L0A1_SetDisplayString(PresentMsg);
 390:../Src/main.c ****         HAL_Delay(1000);
 391:../Src/main.c ****     }
 392:../Src/main.c **** 
 393:../Src/main.c ****     return nDevPresent;
 394:../Src/main.c **** }
 395:../Src/main.c **** 
 396:../Src/main.c **** /**
 397:../Src/main.c ****  *  Setup all detected sensors for single shot mode and setup ranging configuration
 398:../Src/main.c ****  */
 399:../Src/main.c **** void SetupSingleShot(RangingConfig_e rangingConfig){
 400:../Src/main.c ****     int i;
 401:../Src/main.c ****     int status;
 402:../Src/main.c ****     uint8_t VhvSettings;
 403:../Src/main.c ****     uint8_t PhaseCal;
 404:../Src/main.c ****     uint32_t refSpadCount;
 405:../Src/main.c **** 	uint8_t isApertureSpads;
 406:../Src/main.c **** 	FixPoint1616_t signalLimit = (FixPoint1616_t)(0.25*65536);
 407:../Src/main.c **** 	FixPoint1616_t sigmaLimit = (FixPoint1616_t)(18*65536);
 408:../Src/main.c **** 	uint32_t timingBudget = 33000;
 409:../Src/main.c **** 	uint8_t preRangeVcselPeriod = 14;
 410:../Src/main.c **** 	uint8_t finalRangeVcselPeriod = 10;
 411:../Src/main.c **** 
 412:../Src/main.c ****     for( i=0; i<3; i++){
 413:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 414:../Src/main.c ****             status=VL53L0X_StaticInit(&VL53L0XDevs[i]);
 415:../Src/main.c ****             if( status ){
 416:../Src/main.c ****                 debug_printf("VL53L0X_StaticInit %d failed\n",i);
 417:../Src/main.c ****             }
 418:../Src/main.c **** 
 419:../Src/main.c ****             status = VL53L0X_PerformRefCalibration(&VL53L0XDevs[i], &VhvSettings, &PhaseCal);
 420:../Src/main.c **** 			if( status ){
 421:../Src/main.c **** 			   debug_printf("VL53L0X_PerformRefCalibration failed\n");
 422:../Src/main.c **** 			}
 423:../Src/main.c **** 
 424:../Src/main.c **** 			status = VL53L0X_PerformRefSpadManagement(&VL53L0XDevs[i], &refSpadCount, &isApertureSpads);
 425:../Src/main.c **** 			if( status ){
 426:../Src/main.c **** 			   debug_printf("VL53L0X_PerformRefSpadManagement failed\n");
 427:../Src/main.c **** 			}
 428:../Src/main.c **** 
 429:../Src/main.c ****             status = VL53L0X_SetDeviceMode(&VL53L0XDevs[i], VL53L0X_DEVICEMODE_SINGLE_RANGING); // 
ARM GAS  /tmp/ccx8Hxdu.s 			page 9


 430:../Src/main.c ****             if( status ){
 431:../Src/main.c ****                debug_printf("VL53L0X_SetDeviceMode failed\n");
 432:../Src/main.c ****             }
 433:../Src/main.c **** 
 434:../Src/main.c ****             status = VL53L0X_SetLimitCheckEnable(&VL53L0XDevs[i], VL53L0X_CHECKENABLE_SIGMA_FINAL_R
 435:../Src/main.c **** 			if( status ){
 436:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckEnable failed\n");
 437:../Src/main.c **** 			}
 438:../Src/main.c **** 
 439:../Src/main.c **** 			status = VL53L0X_SetLimitCheckEnable(&VL53L0XDevs[i], VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANG
 440:../Src/main.c **** 			if( status ){
 441:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckEnable failed\n");
 442:../Src/main.c **** 			}
 443:../Src/main.c **** 			/* Ranging configuration */
 444:../Src/main.c ****             switch(rangingConfig) {
 445:../Src/main.c ****             case LONG_RANGE:
 446:../Src/main.c ****             	signalLimit = (FixPoint1616_t)(0.1*65536);
 447:../Src/main.c ****             	sigmaLimit = (FixPoint1616_t)(60*65536);
 448:../Src/main.c ****             	timingBudget = 33000; //33ms
 449:../Src/main.c ****             	preRangeVcselPeriod = 18;
 450:../Src/main.c ****             	finalRangeVcselPeriod = 14;
 451:../Src/main.c ****             	break;
 452:../Src/main.c ****             case HIGH_ACCURACY:
 453:../Src/main.c **** 				signalLimit = (FixPoint1616_t)(0.25*65536); //the return signal rate limit in MCPS
 454:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(18*65536);
 455:../Src/main.c **** 				timingBudget = 200000; //200ms
 456:../Src/main.c **** 				preRangeVcselPeriod = 14; //laser pulse periods
 457:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 458:../Src/main.c **** 				break;
 459:../Src/main.c ****             case HIGH_SPEED:
 460:../Src/main.c **** 				signalLimit = (FixPoint1616_t)(0.25*65536);
 461:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(32*65536);
 462:../Src/main.c **** 				timingBudget = 20000; //20ms
 463:../Src/main.c **** 				preRangeVcselPeriod = 14;
 464:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 465:../Src/main.c **** 				break;
 466:../Src/main.c ****             default:
 467:../Src/main.c ****             	debug_printf("Not Supported");
 468:../Src/main.c ****             }
 469:../Src/main.c **** 
 470:../Src/main.c ****             status = VL53L0X_SetLimitCheckValue(&VL53L0XDevs[i],  VL53L0X_CHECKENABLE_SIGNAL_RATE_F
 471:../Src/main.c **** 			if( status ){
 472:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckValue failed\n");
 473:../Src/main.c **** 			}
 474:../Src/main.c **** 
 475:../Src/main.c **** 			status = VL53L0X_SetLimitCheckValue(&VL53L0XDevs[i],  VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE, sig
 476:../Src/main.c **** 			if( status ){
 477:../Src/main.c **** 			   debug_printf("VL53L0X_SetLimitCheckValue failed\n");
 478:../Src/main.c **** 			}
 479:../Src/main.c **** 
 480:../Src/main.c ****             status = VL53L0X_SetMeasurementTimingBudgetMicroSeconds(&VL53L0XDevs[i],  timingBudget)
 481:../Src/main.c ****             if( status ){
 482:../Src/main.c ****                debug_printf("VL53L0X_SetMeasurementTimingBudgetMicroSeconds failed\n");
 483:../Src/main.c ****             }
 484:../Src/main.c **** 
 485:../Src/main.c ****             status = VL53L0X_SetVcselPulsePeriod(&VL53L0XDevs[i],  VL53L0X_VCSEL_PERIOD_PRE_RANGE, 
 486:../Src/main.c **** 			if( status ){
ARM GAS  /tmp/ccx8Hxdu.s 			page 10


 487:../Src/main.c **** 			   debug_printf("VL53L0X_SetVcselPulsePeriod failed\n");
 488:../Src/main.c **** 			}
 489:../Src/main.c **** 
 490:../Src/main.c ****             status = VL53L0X_SetVcselPulsePeriod(&VL53L0XDevs[i],  VL53L0X_VCSEL_PERIOD_FINAL_RANGE
 491:../Src/main.c **** 			if( status ){
 492:../Src/main.c **** 			   debug_printf("VL53L0X_SetVcselPulsePeriod failed\n");
 493:../Src/main.c **** 			}
 494:../Src/main.c **** 
 495:../Src/main.c **** 			status = VL53L0X_PerformRefCalibration(&VL53L0XDevs[i], &VhvSettings, &PhaseCal);
 496:../Src/main.c **** 			if( status ){
 497:../Src/main.c **** 			   debug_printf("VL53L0X_PerformRefCalibration failed\n");
 498:../Src/main.c **** 			}
 499:../Src/main.c **** 
 500:../Src/main.c ****             VL53L0XDevs[i].LeakyFirst=1;
 501:../Src/main.c ****         }
 502:../Src/main.c ****     }
 503:../Src/main.c **** }
 504:../Src/main.c **** 
 505:../Src/main.c **** char RangeToLetter(VL53L0X_Dev_t *pDev, VL53L0X_RangingMeasurementData_t *pRange){
 506:../Src/main.c ****     char c;
 507:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 508:../Src/main.c ****         if( pDev->LeakyRange < RangeLow ){
 509:../Src/main.c ****             c='_';
 510:../Src/main.c ****         }
 511:../Src/main.c ****         else if( pDev->LeakyRange < RangeMedium ){
 512:../Src/main.c ****                 c='=';
 513:../Src/main.c ****         }
 514:../Src/main.c ****         else {
 515:../Src/main.c ****             c = '~';
 516:../Src/main.c ****         }
 517:../Src/main.c **** 
 518:../Src/main.c ****     }
 519:../Src/main.c ****     else{
 520:../Src/main.c ****         c='-';
 521:../Src/main.c ****     }
 522:../Src/main.c ****     return c;
 523:../Src/main.c **** }
 524:../Src/main.c **** 
 525:../Src/main.c **** /* Store new ranging data into the device structure, apply leaky integrator if needed */
 526:../Src/main.c **** void Sensor_SetNewRange(VL53L0X_Dev_t *pDev, VL53L0X_RangingMeasurementData_t *pRange){
 527:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 528:../Src/main.c ****         if( pDev->LeakyFirst ){
 529:../Src/main.c ****             pDev->LeakyFirst = 0;
 530:../Src/main.c ****             pDev->LeakyRange = pRange->RangeMilliMeter;
 531:../Src/main.c ****         }
 532:../Src/main.c ****         else{
 533:../Src/main.c ****             pDev->LeakyRange = (pDev->LeakyRange*LeakyFactorFix8 + (256-LeakyFactorFix8)*pRange->Ra
 534:../Src/main.c ****         }
 535:../Src/main.c ****     }
 536:../Src/main.c ****     else{
 537:../Src/main.c ****         pDev->LeakyFirst = 1;
 538:../Src/main.c ****     }
 539:../Src/main.c **** }
 540:../Src/main.c **** 
 541:../Src/main.c **** void blink_led(int valeur, int* compteur){     /////modification de la led
 542:../Src/main.c ****     if (*compteur == 6){                       /////modification toutes les 6 mesures correctes du 
 543:../Src/main.c ****         HAL_TIM_Base_Stop_IT(&htim3);
ARM GAS  /tmp/ccx8Hxdu.s 			page 11


 544:../Src/main.c ****         htim3.Instance->ARR = 2*valeur-1+20;   /////modification de la periode du capteur (voir wik
 545:../Src/main.c ****         HAL_TIM_Base_Start_IT(&htim3);
 546:../Src/main.c ****         htim3.Instance->CNT = 0;               /////remise a zero du timer de la led
 547:../Src/main.c ****         *compteur = 0;                         /////remise a zero du compteur
 548:../Src/main.c ****     }
 549:../Src/main.c **** }
 550:../Src/main.c **** 
 551:../Src/main.c **** #define Maxi_char_transmit 10  /////////
 552:../Src/main.c **** #define Delay 1000  /////////
 553:../Src/main.c **** #define Delay2 10//////
 554:../Src/main.c **** 
 555:../Src/main.c **** /////transmit modifie a retoucher
 556:../Src/main.c **** 
 557:../Src/main.c **** /*void transmit(int* i, char* bufferDistance, char* bufferAngle, int distance, int angle){  /////tr
 558:../Src/main.c ****     char dataDistance[10];                                /////variable stockage de la valeur du ca
 559:../Src/main.c ****     char dataAngle[10];
 560:../Src/main.c ****     char ligne[2];                                /////variable stockage du separateur \n
 561:../Src/main.c ****     int len;                                      /////variable longueur du buffer
 562:../Src/main.c ****     if (*i<Maxi_char_transmit-1){                 /////ajout valeur, dans data
 563:../Src/main.c ****         sprintf(dataDistance, "%d,",distance);
 564:../Src/main.c ****         sprintf(dataAngle, "%d,",angle);
 565:../Src/main.c ****     }
 566:../Src/main.c ****     else if (*i==Maxi_char_transmit-1){           /////ajout valeur dans data -> pour cloturer la s
 567:../Src/main.c ****         sprintf(dataDistance, "%d",distance);
 568:../Src/main.c ****         sprintf(dataAngle, "%d",angle);
 569:../Src/main.c ****     }
 570:../Src/main.c ****     strcat(bufferDistance,dataDistance);                          /////ajout valeur au buffer
 571:../Src/main.c ****     strcat(bufferAngle, dataAngle);
 572:../Src/main.c ****     if (*i==Maxi_char_transmit-1){
 573:../Src/main.c ****         len=strlen(bufferDistance);                       /////longueur du buffer
 574:../Src/main.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)(strcat(bufferDistance,";")), len, 1000); /////transmi
 575:../Src/main.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)(bufferAngle), len, 1000);
 576:../Src/main.c ****         sprintf(ligne, "\n");                                     /////ajout \n a ligne
 577:../Src/main.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)ligne, 1, 1000);     /////transmission pour cloturer l
 578:../Src/main.c ****         (*i)=-1;                                                  /////remise a zero du compteur
 579:../Src/main.c ****         sprintf(bufferDistance, "");                                      /////remise a zero du buf
 580:../Src/main.c ****         sprintf(bufferAngle, "");
 581:../Src/main.c ****         HAL_Delay(Delay);         //////necessaire pour le graphique
 582:../Src/main.c ****     }
 583:../Src/main.c **** }*/
 584:../Src/main.c **** 
 585:../Src/main.c **** void Variation2Angle_maison(XL servo, int* ptr_angle){ ///test fonctionne
 586:../Src/main.c **** 		uint16_t position;
 587:../Src/main.c **** 		char dataAngle[10];
 588:../Src/main.c **** 		int len;
 589:../Src/main.c **** 		if(*ptr_angle<1000 && *ptr_angle>=0){
 590:../Src/main.c **** 				XL_Set_Goal_Position(&servo, *ptr_angle, 1);
 591:../Src/main.c **** 				*ptr_angle+=5;
 592:../Src/main.c **** 		} else {
 593:../Src/main.c **** 				*ptr_angle=50;
 594:../Src/main.c **** 				XL_Set_Goal_Position(&servo, *ptr_angle, 1);
 595:../Src/main.c **** 		}
 596:../Src/main.c **** 		//XL_Set_Goal_Position(&servo, *ptr_angle, 1);   /////test fonctionne Db=115200
 597:../Src/main.c **** 		/*HAL_Delay(1000);
 598:../Src/main.c **** 		XL_Get_Current_Position(&servo, &position);
 599:../Src/main.c **** 		sprintf(dataAngle, "%d,",position);
 600:../Src/main.c **** 		len=strlen(dataAngle);
ARM GAS  /tmp/ccx8Hxdu.s 			page 12


 601:../Src/main.c **** 		HAL_UART_Transmit(&huart2, (uint8_t*)(dataAngle), len, 1000);*/
 602:../Src/main.c **** }
 603:../Src/main.c **** 
 604:../Src/main.c **** void Variation3Angle_maison(XL servo, int* ptr_angle, char* buffer, int* i){ ///test fonctionne
 605:../Src/main.c **** 		uint16_t position;
 606:../Src/main.c **** 		char dataAngle[10];
 607:../Src/main.c **** 		char ligne[2];
 608:../Src/main.c **** 		int len;
 609:../Src/main.c **** 		if(*ptr_angle<1000 && *ptr_angle>=0){
 610:../Src/main.c **** 				XL_Set_Goal_Position(&servo, *ptr_angle, 1);
 611:../Src/main.c **** 				*ptr_angle+=5;
 612:../Src/main.c **** 		} else {
 613:../Src/main.c **** 				*ptr_angle=50;
 614:../Src/main.c **** 				XL_Set_Goal_Position(&servo, *ptr_angle, 1);
 615:../Src/main.c **** 		}
 616:../Src/main.c **** 		XL_Set_Goal_Position(&servo, *ptr_angle, 1);
 617:../Src/main.c **** 		/*HAL_Delay(1000);
 618:../Src/main.c **** 		XL_Get_Current_Position(&servo, &position);   /////test fonctionne Db=115200
 619:../Src/main.c **** 		sprintf(dataAngle, "%d,",position);
 620:../Src/main.c **** 		len=strlen(dataAngle);
 621:../Src/main.c **** 		HAL_UART_Transmit(&huart2, (uint8_t*)(dataAngle), len, 1000); */
 622:../Src/main.c **** 		HAL_Delay(Delay2);
 623:../Src/main.c **** 		XL_Get_Current_Position(&servo, &position);
 624:../Src/main.c **** 		HAL_Delay(Delay2);
 625:../Src/main.c ****     if (*i<Maxi_char_transmit-1){                 /////ajout valeur, dans data
 626:../Src/main.c ****         sprintf(dataAngle, "%d,",position);
 627:../Src/main.c **** 				/*len=strlen(dataAngle);
 628:../Src/main.c **** 				HAL_UART_Transmit(&huart2, (uint8_t*)(dataAngle), len, 1000);*/
 629:../Src/main.c ****     }  else if (*i==Maxi_char_transmit-1){           /////ajout valeur dans data -> pour cloturer l
 630:../Src/main.c ****         sprintf(dataAngle, "%d",position);
 631:../Src/main.c **** 				/*len=strlen(dataAngle);
 632:../Src/main.c **** 				HAL_UART_Transmit(&huart2, (uint8_t*)(dataAngle), len, 1000);*/
 633:../Src/main.c ****     }
 634:../Src/main.c ****     strcat(buffer,dataAngle);                          /////ajout valeur au buffer
 635:../Src/main.c ****     if (*i==Maxi_char_transmit-1){
 636:../Src/main.c ****         len=strlen(buffer);                       /////longueur du buffer
 637:../Src/main.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)(buffer), len, 1000); /////transmission du buffer
 638:../Src/main.c ****         sprintf(ligne, "\n");                                     /////ajout \n a ligne
 639:../Src/main.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)ligne, 1, 1000);     /////transmission pour cloturer l
 640:../Src/main.c ****         (*i)=-1;                                                  /////remise a zero du compteur
 641:../Src/main.c ****         sprintf(buffer, "");                                      /////remise a zero du buffer
 642:../Src/main.c ****         HAL_Delay(Delay);         //////necessaire pour le graphique
 643:../Src/main.c ****     }
 644:../Src/main.c **** }
 645:../Src/main.c **** 
 646:../Src/main.c **** /**
 647:../Src/main.c ****  * Implement the ranging demo with all modes managed through the blue button (short and long press)
 648:../Src/main.c ****  * This function implements a while loop until the blue button is pressed
 649:../Src/main.c ****  * @param UseSensorsMask Mask of any sensors to use if not only one present
 650:../Src/main.c ****  * @param rangingConfig Ranging configuration to be used (same for all sensors)
 651:../Src/main.c ****  */
 652:../Src/main.c **** 
 653:../Src/main.c **** /*void VariationAngle(XL * servo, int* ptr_compteurAngle){ /////fonction de raph bugge
 654:../Src/main.c ****     *ptr_compteurAngle=60;
 655:../Src/main.c ****     XL_Set_Goal_Position(servo, *ptr_compteurAngle, 1);
 656:../Src/main.c ****     if(*compteurAngle<621 && *compteurAngle>=0){
 657:../Src/main.c ****         XL_Set_Goal_Position(servo, *compteurAngle, 1);
ARM GAS  /tmp/ccx8Hxdu.s 			page 13


 658:../Src/main.c ****         *compteurAngle++;
 659:../Src/main.c ****     }
 660:../Src/main.c ****     else if(*compteurAngle == 620){
 661:../Src/main.c ****         *compteurAngle --;
 662:../Src/main.c ****         XL_Set_Goal_Position(servo, *compteurAngle, 1);
 663:../Src/main.c ****     }
 664:../Src/main.c ****     else{
 665:../Src/main.c ****         XL_Set_Goal_Position(servo, *compteurAngle, 1);
 666:../Src/main.c ****         *compteurAngle--;
 667:../Src/main.c ****     }
 668:../Src/main.c **** }*/
 669:../Src/main.c **** 
 670:../Src/main.c **** int RangeDemo(int UseSensorsMask, RangingConfig_e rangingConfig, XL servo){
 671:../Src/main.c ****     int over=0;
 672:../Src/main.c ****     int status;
 673:../Src/main.c ****     char StrDisplay[5];
 674:../Src/main.c ****     char c;
 675:../Src/main.c ****     int i;
 676:../Src/main.c ****     int nSensorToUse;
 677:../Src/main.c ****     int SingleSensorNo=0;
 678:../Src/main.c ****     int distance;     ///creation variable distance
 679:../Src/main.c ****     /*unsigned int angle;        ///creation variable angle*/ //necessaire ?
 680:../Src/main.c ****     int compteur_blink = 0;                ///creation compteur
 681:../Src/main.c ****     int* ptr_compteur_blink = NULL;   ///creation pointeur sur compteur
 682:../Src/main.c ****     ptr_compteur_blink = &compteur_blink;
 683:../Src/main.c ****     int compteur_d = 0;                 ///creation compteur
 684:../Src/main.c ****     int* ptr_compteur = NULL;   ///creation pointeur sur compteur
 685:../Src/main.c ****     ptr_compteur = &compteur_d;
 686:../Src/main.c ****     char buffer[Maxi_char_transmit*4]; /////creation du buffer
 687:../Src/main.c ****     char buffer1[Maxi_char_transmit*5];
 688:../Src/main.c ****     int len;
 689:../Src/main.c ****     sprintf(buffer, "");               /////mise a zero du buffer
 690:../Src/main.c ****     sprintf(buffer1, "");
 691:../Src/main.c **** 		int angle=10;              ////creation
 692:../Src/main.c **** 	  int* ptr_angle = &angle;
 693:../Src/main.c **** 
 694:../Src/main.c ****     /* Setup all sensors in Single Shot mode */
 695:../Src/main.c ****     SetupSingleShot(rangingConfig);
 696:../Src/main.c **** 
 697:../Src/main.c **** 
 698:../Src/main.c ****     /* Which sensor to use ? */
 699:../Src/main.c ****     for(i=0, nSensorToUse=0; i<3; i++){
 700:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 701:../Src/main.c ****             nSensorToUse++;
 702:../Src/main.c ****             if( nSensorToUse==1 )
 703:../Src/main.c ****                 SingleSensorNo=i;
 704:../Src/main.c ****         }
 705:../Src/main.c ****     }
 706:../Src/main.c ****     if( nSensorToUse == 0 ){
 707:../Src/main.c ****         return -1;
 708:../Src/main.c ****     }
 709:../Src/main.c **** 
 710:../Src/main.c ****     /* Start ranging until blue button is pressed */
 711:../Src/main.c ****     do{
 712:../Src/main.c **** 				//Variation2Angle_maison(servo, ptr_angle); ////fait bouger le servo
 713:../Src/main.c ****         if( nSensorToUse >1 ){
 714:../Src/main.c ****         	/* Multiple devices */
ARM GAS  /tmp/ccx8Hxdu.s 			page 14


 715:../Src/main.c ****             strcpy(StrDisplay, "    ");
 716:../Src/main.c ****             for( i=0; i<3; i++){
 717:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 718:../Src/main.c ****                     continue;
 719:../Src/main.c ****                 /* Call All-In-One blocking API function */
 720:../Src/main.c ****                 status = VL53L0X_PerformSingleRangingMeasurement(&VL53L0XDevs[i],&RangingMeasuremen
 721:../Src/main.c ****                 if( status ){
 722:../Src/main.c ****                     HandleError(ERR_DEMO_RANGE_MULTI);
 723:../Src/main.c ****                 }
 724:../Src/main.c ****                 /* Push data logging to UART */
 725:../Src/main.c ****                 trace_printf("%d,%u,%d,%d,%d\n", VL53L0XDevs[i].Id, TimeStamp_Get(), RangingMeasure
 726:../Src/main.c ****                 /* Store new ranging distance */
 727:../Src/main.c ****                 Sensor_SetNewRange(&VL53L0XDevs[i],&RangingMeasurementData);
 728:../Src/main.c ****                 /* Translate distance in bar graph (multiple device) */
 729:../Src/main.c ****                 c = RangeToLetter(&VL53L0XDevs[i],&RangingMeasurementData);
 730:../Src/main.c ****                 StrDisplay[i+1]=c;
 731:../Src/main.c ****             }
 732:../Src/main.c ****         }
 733:../Src/main.c ****         else{
 734:../Src/main.c ****             /* only one sensor */
 735:../Src/main.c ****         	/* Call All-In-One blocking API function */
 736:../Src/main.c ****             status = VL53L0X_PerformSingleRangingMeasurement(&VL53L0XDevs[SingleSensorNo],&RangingM
 737:../Src/main.c ****             if( status ==0 ){
 738:../Src/main.c ****             	/* Push data logging to UART */
 739:../Src/main.c ****             	trace_printf("%d,%u,%d,%d,%d\n", VL53L0XDevs[SingleSensorNo].Id, TimeStamp_Get(), Rang
 740:../Src/main.c ****             	Sensor_SetNewRange(&VL53L0XDevs[SingleSensorNo],&RangingMeasurementData);
 741:../Src/main.c ****                 /* Display distance in cm */
 742:../Src/main.c ****             	if( RangingMeasurementData.RangeStatus == 0 ){  /////boucle de mesures correctes
 743:../Src/main.c ****                     *ptr_compteur_blink+=1;                      /////incrementation du compteur
 744:../Src/main.c ****                     sprintf(StrDisplay, "%3dc",(int)VL53L0XDevs[SingleSensorNo].LeakyRange/10);  //
 745:../Src/main.c ****                     distance = (int)VL53L0XDevs[SingleSensorNo].LeakyRange/10;   /////distance lue 
 746:../Src/main.c ****                     //XL_Get_Current_Position(servo, &angle); necessaire ?
 747:../Src/main.c ****                     blink_led(distance, ptr_compteur_blink);         /////fonction blink_led
 748:../Src/main.c **** 										Variation3Angle_maison(servo, ptr_angle, buffer1, ptr_compteur);
 749:../Src/main.c ****                     //transmit(compteur2, buffer, buffer1, distance, angle);        /////fonction t
 750:../Src/main.c ****                     *ptr_compteur+=1;                              /////incrementation du compteur
 751:../Src/main.c **** 
 752:../Src/main.c **** 
 753:../Src/main.c **** //////bloc structure (je me comprends)
 754:../Src/main.c **** /*
 755:../Src/main.c ****                     //unsigned int angle;
 756:../Src/main.c ****                     //char dataAngle[10];
 757:../Src/main.c ****                     //XL_Set_Goal_Position(servo, 60, 1);
 758:../Src/main.c ****                     //sprintf(dataAngle, "%d,",angle);
 759:../Src/main.c ****                     //len=strlen(dataAngle);
 760:../Src/main.c ****                     //HAL_UART_Transmit(&huart2, (uint8_t*)(dataAngle), len, 1000);*/
 761:../Src/main.c ****                 }
 762:../Src/main.c ****                 else{                                           /////boucle de mesures incorrectes
 763:../Src/main.c ****                     sprintf(StrDisplay, "----");
 764:../Src/main.c ****                     StrDisplay[0]=VL53L0XDevs[SingleSensorNo].DevLetter;
 765:../Src/main.c ****                     //HAL_TIM_Base_Stop_IT(&htim3);             /////version courante : memoire de 
 766:../Src/main.c ****                     //htim3.Instance->ARR=2000;
 767:../Src/main.c ****                     //HAL_TIM_Base_Start_IT(&htim3);
 768:../Src/main.c ****                 }
 769:../Src/main.c ****             }
 770:../Src/main.c ****             else{
 771:../Src/main.c ****                 HandleError(ERR_DEMO_RANGE_ONE);
ARM GAS  /tmp/ccx8Hxdu.s 			page 15


 772:../Src/main.c ****             }
 773:../Src/main.c ****         }
 774:../Src/main.c ****         XNUCLEO53L0A1_SetDisplayString(StrDisplay);
 775:../Src/main.c ****         /* Check blue button */
 776:../Src/main.c ****         if( !BSP_GetPushButton() ){
 777:../Src/main.c ****             over=1;
 778:../Src/main.c ****             break;
 779:../Src/main.c ****         }
 780:../Src/main.c ****     }while( !over);
 781:../Src/main.c ****     /* Wait button to be un-pressed to decide if it is a short or long press */
 782:../Src/main.c ****     status=PusbButton_WaitUnPress();
 783:../Src/main.c ****     htim3.Instance->CNT=0;       /////remise a zero du timer de la led
 784:../Src/main.c ****     return status;
 785:../Src/main.c **** }
 786:../Src/main.c **** 
 787:../Src/main.c **** #if HAVE_ALARM_DEMO
 788:../Src/main.c **** struct AlrmMode_t {
 789:../Src/main.c ****     const int VL53L0X_Mode;
 790:../Src/main.c ****     const char *Name;
 791:../Src/main.c ****     uint32_t ThreshLow;
 792:../Src/main.c ****     uint32_t ThreshHigh;
 793:../Src/main.c **** };
 794:../Src/main.c **** 
 795:../Src/main.c **** struct AlrmMode_t AlarmModes[]={
 796:../Src/main.c ****         { .VL53L0X_Mode = VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW , .Name="Lo" , .ThreshLow
 797:../Src/main.c ****         { .VL53L0X_Mode = VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH, .Name= "hi", .ThreshLow
 798:../Src/main.c ****         { .VL53L0X_Mode = VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT , .Name="out", .ThreshLow
 799:../Src/main.c **** };
 800:../Src/main.c **** 
 801:../Src/main.c **** VL53L0X_Error WaitStopCompleted(VL53L0X_DEV Dev) {
 802:../Src/main.c ****     VL53L0X_Error Status = VL53L0X_ERROR_NONE;
 803:../Src/main.c ****     uint32_t StopCompleted=0;
 804:../Src/main.c ****     uint32_t LoopNb;
 805:../Src/main.c **** 
 806:../Src/main.c ****     // Wait until it finished
 807:../Src/main.c ****     // use timeout to avoid deadlock
 808:../Src/main.c ****     if (Status == VL53L0X_ERROR_NONE) {
 809:../Src/main.c ****         LoopNb = 0;
 810:../Src/main.c ****         do {
 811:../Src/main.c ****             Status = VL53L0X_GetStopCompletedStatus(Dev, &StopCompleted);
 812:../Src/main.c ****             if ((StopCompleted == 0x00) || Status != VL53L0X_ERROR_NONE) {
 813:../Src/main.c ****                 break;
 814:../Src/main.c ****             }
 815:../Src/main.c ****             LoopNb = LoopNb + 1;
 816:../Src/main.c ****             VL53L0X_PollingDelay(Dev);
 817:../Src/main.c ****         } while (LoopNb < VL53L0X_DEFAULT_MAX_LOOP);
 818:../Src/main.c **** 
 819:../Src/main.c ****         if (LoopNb >= VL53L0X_DEFAULT_MAX_LOOP) {
 820:../Src/main.c ****             Status = VL53L0X_ERROR_TIME_OUT;
 821:../Src/main.c ****         }
 822:../Src/main.c **** 
 823:../Src/main.c ****     }
 824:../Src/main.c **** 
 825:../Src/main.c ****     return Status;
 826:../Src/main.c **** }
 827:../Src/main.c **** 
 828:../Src/main.c **** 
ARM GAS  /tmp/ccx8Hxdu.s 			page 16


 829:../Src/main.c **** void AlarmDemo(void){
 830:../Src/main.c ****     VL53L0X_Dev_t *pDev;
 831:../Src/main.c ****     uint8_t VhvSettings;
 832:../Src/main.c ****     uint8_t PhaseCal;
 833:../Src/main.c ****     uint32_t refSpadCount;
 834:../Src/main.c **** 	uint8_t isApertureSpads;
 835:../Src/main.c **** 	VL53L0X_RangingMeasurementData_t RangingMeasurementData;
 836:../Src/main.c ****     int status;
 837:../Src/main.c ****     int Over=0;
 838:../Src/main.c ****     int Mode=0;
 839:../Src/main.c ****     char StrDisplay[5]="----";
 840:../Src/main.c **** 
 841:../Src/main.c ****     /* Only center device is used */
 842:../Src/main.c ****     pDev=&VL53L0XDevs[1];
 843:../Src/main.c **** 
 844:../Src/main.c **** 
 845:../Src/main.c ****     /* configure BSP/MCU center sensor interrupt */
 846:../Src/main.c ****     VL53L0A1_EXTI_IOConfigure(XNUCLEO53L0A1_DEV_CENTER, 0, 0);
 847:../Src/main.c ****     XNUCLEO53L0A1_SetIntrStateId(1, XNUCLEO53L0A1_DEV_CENTER);
 848:../Src/main.c **** 
 849:../Src/main.c ****     /* Initialize the device in continuous ranging mode */
 850:../Src/main.c **** 	VL53L0X_StaticInit(pDev);
 851:../Src/main.c **** 	VL53L0X_PerformRefCalibration(pDev, &VhvSettings, &PhaseCal);
 852:../Src/main.c **** 	VL53L0X_PerformRefSpadManagement(pDev, &refSpadCount, &isApertureSpads);
 853:../Src/main.c **** 	VL53L0X_SetInterMeasurementPeriodMilliSeconds(pDev, 250);
 854:../Src/main.c **** 	VL53L0X_SetDeviceMode(pDev, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING);
 855:../Src/main.c **** 
 856:../Src/main.c ****     do{
 857:../Src/main.c ****        /* set sensor interrupt mode */
 858:../Src/main.c ****        VL53L0X_StopMeasurement(pDev);           // it is safer to do this while sensor is stopped
 859:../Src/main.c ****        VL53L0X_SetInterruptThresholds(pDev, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING ,  AlarmModes[Mod
 860:../Src/main.c ****        status = VL53L0X_SetGpioConfig(pDev, 0, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING, AlarmModes[Mo
 861:../Src/main.c ****        status = VL53L0X_ClearInterruptMask(pDev, -1); // clear interrupt pending if any
 862:../Src/main.c **** 
 863:../Src/main.c ****        /* Start continuous ranging */
 864:../Src/main.c ****        VL53L0X_StartMeasurement(pDev);
 865:../Src/main.c ****        IntrCounts[1]=0;
 866:../Src/main.c **** 
 867:../Src/main.c ****        /* Check for interrupt */
 868:../Src/main.c ****        do{
 869:../Src/main.c ****            __WFI();
 870:../Src/main.c ****            /* Interrupt received */
 871:../Src/main.c ****            if( IntrCounts[1] !=0 ){
 872:../Src/main.c ****         	   /* Reset interrupt counter */
 873:../Src/main.c ****                IntrCounts[1]=0;
 874:../Src/main.c ****                /* Get ranging data and display distance*/
 875:../Src/main.c ****                VL53L0X_GetRangingMeasurementData(pDev, &RangingMeasurementData);
 876:../Src/main.c ****                sprintf(StrDisplay, "%3dc",(int)RangingMeasurementData.RangeMilliMeter/10);
 877:../Src/main.c ****                /* Clear interrupt */
 878:../Src/main.c ****                status = VL53L0X_ClearInterruptMask(pDev, -1);
 879:../Src/main.c ****                /* keep display for at least 100ms otherwise user may never see it on display*/
 880:../Src/main.c ****                XNUCLEO53L0A1_SetDisplayString(StrDisplay);
 881:../Src/main.c ****                HAL_Delay(100);
 882:../Src/main.c ****            }
 883:../Src/main.c ****            else{
 884:../Src/main.c ****         	   /* No interrupt received => Display alarm mode */
 885:../Src/main.c ****                XNUCLEO53L0A1_SetDisplayString(AlarmModes[Mode].Name);
ARM GAS  /tmp/ccx8Hxdu.s 			page 17


 886:../Src/main.c ****            }
 887:../Src/main.c ****            /* Check blue button */
 888:../Src/main.c ****            if( !BSP_GetPushButton() ){
 889:../Src/main.c ****                break;
 890:../Src/main.c ****            }
 891:../Src/main.c ****        }while(1);
 892:../Src/main.c ****        /* Wait button to be released to decide if it is a short or long press */
 893:../Src/main.c ****        status=PusbButton_WaitUnPress();
 894:../Src/main.c ****        /* Long press => stop this demo */
 895:../Src/main.c ****        if( status )
 896:../Src/main.c ****            Over =1;
 897:../Src/main.c ****        /* Short press => change alarm mode */
 898:../Src/main.c ****        Mode=(Mode+1)%ARRAY_SIZE(AlarmModes);
 899:../Src/main.c ****     }while( !Over );
 900:../Src/main.c **** 
 901:../Src/main.c ****     /* Stop continuous ranging */
 902:../Src/main.c ****     VL53L0X_StopMeasurement(pDev);
 903:../Src/main.c **** 
 904:../Src/main.c ****     /* Ensure device is ready for other commands */
 905:../Src/main.c ****     WaitStopCompleted(pDev);
 906:../Src/main.c **** 
 907:../Src/main.c ****     /* Disable configuration of BSP/MCU center sensor interrupt */
 908:../Src/main.c ****     XNUCLEO53L0A1_SetIntrStateId(0, XNUCLEO53L0A1_DEV_CENTER);
 909:../Src/main.c ****     VL53L0A1_EXTI_IOUnconfigure(XNUCLEO53L0A1_DEV_CENTER);
 910:../Src/main.c **** }
 911:../Src/main.c **** #endif
 912:../Src/main.c **** 
 913:../Src/main.c **** void ResetAndDetectSensor(int SetDisplay){
 914:../Src/main.c ****     int nSensor;
 915:../Src/main.c ****     nSensor = DetectSensors(SetDisplay);
 916:../Src/main.c ****     /* at least one sensor and if one it must be the built-in one  */
 917:../Src/main.c ****     if( (nSensor <=0) ||  (nSensor ==1 && VL53L0XDevs[1].Present==0) ){
 918:../Src/main.c ****         HandleError(ERR_DETECT);
 919:../Src/main.c ****     }
 920:../Src/main.c **** }
 921:../Src/main.c **** 
 922:../Src/main.c **** /* USER CODE END 0 */
 923:../Src/main.c **** 
 924:../Src/main.c **** int main(void)
 925:../Src/main.c **** {
 926:../Src/main.c **** 
 927:../Src/main.c ****   /* USER CODE BEGIN 1 */
 928:../Src/main.c ****   int ExitWithLongPress;
 929:../Src/main.c ****   RangingConfig_e RangingConfig = LONG_RANGE;
 930:../Src/main.c ****   DemoMode_e DemoMode = RANGE_VALUE;
 931:../Src/main.c ****   int UseSensorsMask = 1<<XNUCLEO53L0A1_DEV_CENTER;
 932:../Src/main.c ****   /* USER CODE END 1 */
 933:../Src/main.c **** 
 934:../Src/main.c ****   /* MCU Configuration----------------------------------------------------------*/
 935:../Src/main.c **** 
 936:../Src/main.c ****   /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
 937:../Src/main.c ****   HAL_Init();
 938:../Src/main.c **** 
 939:../Src/main.c ****   /* Configure the system clock */
 940:../Src/main.c ****   SystemClock_Config();
 941:../Src/main.c **** 
 942:../Src/main.c ****   /* Initialize all configured peripherals */
ARM GAS  /tmp/ccx8Hxdu.s 			page 18


 943:../Src/main.c ****   MX_GPIO_Init();
 944:../Src/main.c ****   SystemClock_Config();
 945:../Src/main.c ****   MX_I2C1_Init();
 946:../Src/main.c ****   MX_TIM3_Init();
 947:../Src/main.c ****   MX_USART2_UART_Init();
 948:../Src/main.c ****   MX_USART1_UART_Init();
 949:../Src/main.c **** 
 950:../Src/main.c ****   /* USER CODE BEGIN 2 */
 951:../Src/main.c ****   XNUCLEO53L0A1_Init();
 952:../Src/main.c ****   uart_printf(WelcomeMsg);
 953:../Src/main.c ****   XNUCLEO53L0A1_SetDisplayString("53L0");
 954:../Src/main.c ****   HAL_Delay(WelcomeTime);
 955:../Src/main.c ****   ResetAndDetectSensor(1);
 956:../Src/main.c ****   HAL_TIM_Base_Start_IT(&htim3); //
 957:../Src/main.c **** 
 958:../Src/main.c ****   /* Set VL53L0X API trace level */
 959:../Src/main.c ****   VL53L0X_trace_config(NULL, TRACE_MODULE_NONE, TRACE_LEVEL_NONE, TRACE_FUNCTION_NONE); // No Trace
 960:../Src/main.c ****   //VL53L0X_trace_config(NULL,TRACE_MODULE_ALL, TRACE_LEVEL_ALL, TRACE_FUNCTION_ALL); // Full trace
 961:../Src/main.c **** 
 962:../Src/main.c ****   //////XL maintenance ----------------------
 963:../Src/main.c ****   XL_Interface interface;
 964:../Src/main.c ****   XL320InterfaceDefine(&interface);
 965:../Src/main.c **** 
 966:../Src/main.c ****   HAL_Delay(1000);
 967:../Src/main.c **** 
 968:../Src/main.c ****   XL servo;
 969:../Src/main.c ****   uint16_t nbServos; //number of detected servos
 970:../Src/main.c ****   uint8_t nbmServosWanted; //number max of servos controle
 971:../Src/main.c ****   XL320ServosActivation(&interface, &servo, nbmServosWanted, &nbServos);
 972:../Src/main.c **** 
 973:../Src/main.c ****   #if CONFIG==1
 974:../Src/main.c ****   XL_Configure_ID(&servo[0],3);
 975:../Src/main.c ****   #endif
 976:../Src/main.c ****   
 977:../Src/main.c ****   /* USER CODE END 2 */
 978:../Src/main.c **** 
 979:../Src/main.c ****   /* USER CODE BEGIN 3 */
 980:../Src/main.c ****   /* Infinite loop */
 981:../Src/main.c ****   /* USER CODE BEGIN WHILE */
 982:../Src/main.c ****   while (1)
 983:../Src/main.c ****   {
 984:../Src/main.c ****   /* USER CODE END WHILE */
 985:../Src/main.c ****       /* Display demo mode */
 986:../Src/main.c ****       XNUCLEO53L0A1_SetDisplayString(DemoModeTxt[DemoMode]);
 987:../Src/main.c ****       HAL_Delay(ModeChangeDispTime);
 988:../Src/main.c **** 
 989:../Src/main.c ****       /* Display Ranging config */
 990:../Src/main.c **** 	  XNUCLEO53L0A1_SetDisplayString(RangingConfigTxt[RangingConfig]);
 991:../Src/main.c **** 	  HAL_Delay(ModeChangeDispTime);
 992:../Src/main.c **** 
 993:../Src/main.c **** 	  /* Reset and Detect all sensors */
 994:../Src/main.c ****       ResetAndDetectSensor(0);
 995:../Src/main.c **** 
 996:../Src/main.c ****       /* Reset Timestamping */
 997:../Src/main.c ****       TimeStamp_Reset();
 998:../Src/main.c **** 
 999:../Src/main.c **** #if HAVE_ALARM_DEMO
ARM GAS  /tmp/ccx8Hxdu.s 			page 19


1000:../Src/main.c ****       XNUCLEO53L0A1_SetDisplayString(TxtAlarm);
1001:../Src/main.c ****       HAL_Delay(ModeChangeDispTime);
1002:../Src/main.c ****       ResetAndDetectSensor(0);
1003:../Src/main.c ****       AlarmDemo();
1004:../Src/main.c **** #else
1005:../Src/main.c **** 
1006:../Src/main.c **** //////phase de tests simples
1007:../Src/main.c **** 
1008:../Src/main.c ****       /*XL_Set_Goal_Position(&servo, 60, 1); ///test position fonctionne
1009:../Src/main.c ****       uint16_t position;
1010:../Src/main.c ****       XL_Get_Current_Position(&servo, &position);
1011:../Src/main.c **** 			position;*/
1012:../Src/main.c **** 
1013:../Src/main.c **** 			/*void VariationAngle_maison(XL servo, int Angle){ ///test fonctionne
1014:../Src/main.c **** 					uint16_t position;
1015:../Src/main.c **** 					XL_Set_Goal_Position(&servo, Angle, 1);
1016:../Src/main.c **** 					XL_Get_Current_Position(&servo, &position);
1017:../Src/main.c **** 			}
1018:../Src/main.c **** 
1019:../Src/main.c **** 			VariationAngle_maison(servo, compteurAngle);*/
1020:../Src/main.c **** 
1021:../Src/main.c ****       /* Start Ranging demo */
1022:../Src/main.c ****       ExitWithLongPress = RangeDemo(UseSensorsMask, RangingConfig, servo);
1023:../Src/main.c **** 
1024:../Src/main.c ****       /* Blue button has been pressed (long or short press) */
1025:../Src/main.c ****       if(ExitWithLongPress){
1026:../Src/main.c ****     	  /* Long press : change demo mode if multiple sensors present*/
1027:../Src/main.c ****     	  if( nDevPresent >1 ){
1028:../Src/main.c ****     		  /* If more than one sensor is present then toggle demo mode */
1029:../Src/main.c ****     		  DemoMode = (DemoMode == RANGE_VALUE) ? BAR_GRAPH : RANGE_VALUE;
1030:../Src/main.c ****     		  UseSensorsMask = (DemoMode == BAR_GRAPH) ? 0x7 : 1<<XNUCLEO53L0A1_DEV_CENTER;
1031:../Src/main.c ****     	  }
1032:../Src/main.c ****       } else {
1033:../Src/main.c ****     	  /* Short press : change ranging config */
1034:../Src/main.c ****     	  RangingConfig = (RangingConfig == LONG_RANGE) ? HIGH_SPEED : ((RangingConfig == HIGH_SPEED) 
1035:../Src/main.c ****       }
1036:../Src/main.c **** #endif
1037:../Src/main.c ****   }
1038:../Src/main.c ****   /* USER CODE END 3 */
1039:../Src/main.c **** 
1040:../Src/main.c **** }
1041:../Src/main.c **** 
1042:../Src/main.c **** /** System Clock Configuration
1043:../Src/main.c **** */
1044:../Src/main.c **** void SystemClock_Config(void)
1045:../Src/main.c **** {
1046:../Src/main.c **** 
1047:../Src/main.c ****   RCC_OscInitTypeDef RCC_OscInitStruct;
1048:../Src/main.c ****   RCC_ClkInitTypeDef RCC_ClkInitStruct;
1049:../Src/main.c **** 
1050:../Src/main.c ****   __PWR_CLK_ENABLE();
1051:../Src/main.c **** 
1052:../Src/main.c ****   __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
1053:../Src/main.c **** 
1054:../Src/main.c ****   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
1055:../Src/main.c ****   RCC_OscInitStruct.HSIState = RCC_HSI_ON;
1056:../Src/main.c ****   RCC_OscInitStruct.HSICalibrationValue = 6;
ARM GAS  /tmp/ccx8Hxdu.s 			page 20


1057:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
1058:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
1059:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLM = 16;
1060:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLN = 336;
1061:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
1062:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLQ = 7;
1063:../Src/main.c ****   HAL_RCC_OscConfig(&RCC_OscInitStruct);
1064:../Src/main.c **** 
1065:../Src/main.c ****   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1;
1066:../Src/main.c ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
1067:../Src/main.c ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
1068:../Src/main.c ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
1069:../Src/main.c ****   RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
1070:../Src/main.c ****   HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
1071:../Src/main.c **** 
1072:../Src/main.c **** }
1073:../Src/main.c **** 
1074:../Src/main.c **** /* I2C1 init function */
1075:../Src/main.c **** void MX_I2C1_Init(void)
1076:../Src/main.c **** {
1077:../Src/main.c **** 
1078:../Src/main.c ****   hi2c1.Instance = I2C1;
1079:../Src/main.c ****   hi2c1.Init.ClockSpeed = 400000;
1080:../Src/main.c ****   hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
1081:../Src/main.c ****   hi2c1.Init.OwnAddress1 = 0;
1082:../Src/main.c ****   hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
1083:../Src/main.c ****   hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLED;
1084:../Src/main.c ****   hi2c1.Init.OwnAddress2 = 0;
1085:../Src/main.c ****   hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLED;
1086:../Src/main.c ****   hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLED;
1087:../Src/main.c ****   HAL_I2C_Init(&hi2c1);
1088:../Src/main.c **** 
1089:../Src/main.c **** }
1090:../Src/main.c **** 
1091:../Src/main.c **** /* TIM3 init function */
1092:../Src/main.c **** void MX_TIM3_Init(void)
1093:../Src/main.c **** {
1094:../Src/main.c **** 
1095:../Src/main.c ****   TIM_ClockConfigTypeDef sClockSourceConfig;
1096:../Src/main.c ****   TIM_MasterConfigTypeDef sMasterConfig;
1097:../Src/main.c **** 
1098:../Src/main.c ****   htim3.Instance = TIM3;
1099:../Src/main.c ****   htim3.Init.Prescaler = 42000-1;
1100:../Src/main.c ****   htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
1101:../Src/main.c ****   htim3.Init.Period = 1000-1;
1102:../Src/main.c ****   htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
1103:../Src/main.c ****   HAL_TIM_Base_Init(&htim3);
1104:../Src/main.c **** 
1105:../Src/main.c ****   sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
1106:../Src/main.c ****   HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);
1107:../Src/main.c **** 
1108:../Src/main.c ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
1109:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
1110:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);
1111:../Src/main.c **** 
1112:../Src/main.c **** }
1113:../Src/main.c **** 
ARM GAS  /tmp/ccx8Hxdu.s 			page 21


1114:../Src/main.c **** /* USART1 init function */
1115:../Src/main.c **** void MX_USART1_UART_Init(void)
1116:../Src/main.c **** {
1117:../Src/main.c **** 
1118:../Src/main.c ****   huart1.Instance = USART1;
1119:../Src/main.c ****   huart1.Init.BaudRate = 1000000;
1120:../Src/main.c ****   huart1.Init.WordLength = UART_WORDLENGTH_8B;
1121:../Src/main.c ****   huart1.Init.StopBits = UART_STOPBITS_1;
1122:../Src/main.c ****   huart1.Init.Parity = UART_PARITY_NONE;
1123:../Src/main.c ****   huart1.Init.Mode = UART_MODE_TX_RX;
1124:../Src/main.c ****   huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
1125:../Src/main.c ****   huart1.Init.OverSampling = UART_OVERSAMPLING_16;
1126:../Src/main.c ****   HAL_UART_Init(&huart1);
1127:../Src/main.c **** 
1128:../Src/main.c **** }
1129:../Src/main.c **** 
1130:../Src/main.c **** /* USART2 init function */
1131:../Src/main.c **** void MX_USART2_UART_Init(void)
1132:../Src/main.c **** {
1133:../Src/main.c **** 
1134:../Src/main.c ****   huart2.Instance = USART2;
1135:../Src/main.c ****   huart2.Init.BaudRate = 115200;
1136:../Src/main.c ****   huart2.Init.WordLength = UART_WORDLENGTH_8B;
1137:../Src/main.c ****   huart2.Init.StopBits = UART_STOPBITS_1;
1138:../Src/main.c ****   huart2.Init.Parity = UART_PARITY_NONE;
1139:../Src/main.c ****   huart2.Init.Mode = UART_MODE_TX_RX;
1140:../Src/main.c ****   huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
1141:../Src/main.c ****   huart2.Init.OverSampling = UART_OVERSAMPLING_16;
1142:../Src/main.c ****   HAL_UART_Init(&huart2);
1143:../Src/main.c **** 
1144:../Src/main.c **** }
1145:../Src/main.c **** 
1146:../Src/main.c **** /** Configure pins as
1147:../Src/main.c ****         * Analog
1148:../Src/main.c ****         * Input
1149:../Src/main.c ****         * Output
1150:../Src/main.c ****         * EVENT_OUT
1151:../Src/main.c ****         * EXTI
1152:../Src/main.c ****         * Free pins are configured automatically as Analog (this feature is enabled through
1153:../Src/main.c ****         * the Code Generation settings)
1154:../Src/main.c **** */
1155:../Src/main.c **** void MX_GPIO_Init(void)
1156:../Src/main.c **** {
  29              		.loc 1 1156 0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 24
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 24
  36              		.cfi_offset 4, -24
  37              		.cfi_offset 5, -20
  38              		.cfi_offset 6, -16
  39              		.cfi_offset 7, -12
  40              		.cfi_offset 8, -8
  41              		.cfi_offset 14, -4
  42 0004 86B0     		sub	sp, sp, #24
ARM GAS  /tmp/ccx8Hxdu.s 			page 22


  43              	.LCFI1:
  44              		.cfi_def_cfa_offset 48
1157:../Src/main.c **** 
1158:../Src/main.c ****   GPIO_InitTypeDef GPIO_InitStruct;
1159:../Src/main.c **** 
1160:../Src/main.c ****   /* GPIO Ports Clock Enable */
1161:../Src/main.c ****   __GPIOC_CLK_ENABLE();
  45              		.loc 1 1161 0
  46 0006 324B     		ldr	r3, .L3
  47 0008 1A6B     		ldr	r2, [r3, #48]
  48 000a 42F00402 		orr	r2, r2, #4
  49 000e 1A63     		str	r2, [r3, #48]
1162:../Src/main.c ****   __GPIOH_CLK_ENABLE();
  50              		.loc 1 1162 0
  51 0010 1A6B     		ldr	r2, [r3, #48]
  52 0012 42F08002 		orr	r2, r2, #128
  53 0016 1A63     		str	r2, [r3, #48]
1163:../Src/main.c ****   __GPIOA_CLK_ENABLE();
  54              		.loc 1 1163 0
  55 0018 1A6B     		ldr	r2, [r3, #48]
  56 001a 42F00102 		orr	r2, r2, #1
  57 001e 1A63     		str	r2, [r3, #48]
1164:../Src/main.c ****   __GPIOB_CLK_ENABLE();
  58              		.loc 1 1164 0
  59 0020 1A6B     		ldr	r2, [r3, #48]
  60 0022 42F00202 		orr	r2, r2, #2
  61 0026 1A63     		str	r2, [r3, #48]
1165:../Src/main.c ****   __GPIOD_CLK_ENABLE();
  62              		.loc 1 1165 0
  63 0028 1A6B     		ldr	r2, [r3, #48]
  64 002a 42F00802 		orr	r2, r2, #8
  65 002e 1A63     		str	r2, [r3, #48]
1166:../Src/main.c **** 
1167:../Src/main.c ****   /*Configure GPIO pin : PC13 */
1168:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_13;
  66              		.loc 1 1168 0
  67 0030 4FF40053 		mov	r3, #8192
  68 0034 0193     		str	r3, [sp, #4]
1169:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  69              		.loc 1 1169 0
  70 0036 0024     		movs	r4, #0
  71 0038 0294     		str	r4, [sp, #8]
1170:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
  72              		.loc 1 1170 0
  73 003a 0394     		str	r4, [sp, #12]
1171:../Src/main.c ****   HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  74              		.loc 1 1171 0
  75 003c 254E     		ldr	r6, .L3+4
  76 003e 01A9     		add	r1, sp, #4
  77 0040 3046     		mov	r0, r6
  78 0042 FFF7FEFF 		bl	HAL_GPIO_Init
  79              	.LVL0:
1172:../Src/main.c **** 
1173:../Src/main.c ****   /*Configure GPIO pins : PC0 PC1 PC2 PC3
1174:../Src/main.c ****                            PC4 PC5 PC6 PC7
1175:../Src/main.c ****                            PC8 PC10 PC11 PC12 */
1176:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
ARM GAS  /tmp/ccx8Hxdu.s 			page 23


  80              		.loc 1 1176 0
  81 0046 41F6FF53 		movw	r3, #7679
  82 004a 0193     		str	r3, [sp, #4]
1177:../Src/main.c ****                           |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7
1178:../Src/main.c ****                           |GPIO_PIN_8|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
1179:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  83              		.loc 1 1179 0
  84 004c 0325     		movs	r5, #3
  85 004e 0295     		str	r5, [sp, #8]
1180:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
  86              		.loc 1 1180 0
  87 0050 0394     		str	r4, [sp, #12]
1181:../Src/main.c ****   HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  88              		.loc 1 1181 0
  89 0052 01A9     		add	r1, sp, #4
  90 0054 3046     		mov	r0, r6
  91 0056 FFF7FEFF 		bl	HAL_GPIO_Init
  92              	.LVL1:
1182:../Src/main.c **** 
1183:../Src/main.c ****   /*Configure GPIO pin Output Level */
1184:../Src/main.c ****   HAL_GPIO_WritePin(USART1_DIR_GPIO_Port, USART1_DIR_Pin, GPIO_PIN_RESET);
  93              		.loc 1 1184 0
  94 005a 2246     		mov	r2, r4
  95 005c 4FF40071 		mov	r1, #512
  96 0060 3046     		mov	r0, r6
  97 0062 FFF7FEFF 		bl	HAL_GPIO_WritePin
  98              	.LVL2:
1185:../Src/main.c **** 
1186:../Src/main.c ****   /*Configure GPIO pins : PA0 PA1 PA4 PA6
1187:../Src/main.c ****                            PA7 PA8 PA11 PA12
1188:../Src/main.c ****                            PA15 */
1189:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_6
  99              		.loc 1 1189 0
 100 0066 49F6D313 		movw	r3, #39379
 101 006a 0193     		str	r3, [sp, #4]
1190:../Src/main.c ****                           |GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12
1191:../Src/main.c ****                           |GPIO_PIN_15;
1192:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 102              		.loc 1 1192 0
 103 006c 0295     		str	r5, [sp, #8]
1193:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 104              		.loc 1 1193 0
 105 006e 0394     		str	r4, [sp, #12]
1194:../Src/main.c ****   HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 106              		.loc 1 1194 0
 107 0070 DFF86C80 		ldr	r8, .L3+16
 108 0074 01A9     		add	r1, sp, #4
 109 0076 4046     		mov	r0, r8
 110 0078 FFF7FEFF 		bl	HAL_GPIO_Init
 111              	.LVL3:
1195:../Src/main.c **** 
1196:../Src/main.c ****   /*Configure GPIO pin : PA5 */
1197:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_5;
 112              		.loc 1 1197 0
 113 007c 2023     		movs	r3, #32
 114 007e 0193     		str	r3, [sp, #4]
1198:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
ARM GAS  /tmp/ccx8Hxdu.s 			page 24


 115              		.loc 1 1198 0
 116 0080 0127     		movs	r7, #1
 117 0082 0297     		str	r7, [sp, #8]
1199:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 118              		.loc 1 1199 0
 119 0084 0394     		str	r4, [sp, #12]
1200:../Src/main.c ****   GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 120              		.loc 1 1200 0
 121 0086 0494     		str	r4, [sp, #16]
1201:../Src/main.c ****   HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 122              		.loc 1 1201 0
 123 0088 01A9     		add	r1, sp, #4
 124 008a 4046     		mov	r0, r8
 125 008c FFF7FEFF 		bl	HAL_GPIO_Init
 126              	.LVL4:
1202:../Src/main.c **** 
1203:../Src/main.c ****   /*Configure GPIO pins : PB0 PB1 PB2 PB10
1204:../Src/main.c ****                            PB12 PB13 PB14 PB15
1205:../Src/main.c ****                            PB4 PB5 PB6 PB7 */
1206:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10
 127              		.loc 1 1206 0
 128 0090 4FF2F743 		movw	r3, #62711
 129 0094 0193     		str	r3, [sp, #4]
1207:../Src/main.c ****                           |GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15
1208:../Src/main.c ****                           |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
1209:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 130              		.loc 1 1209 0
 131 0096 0295     		str	r5, [sp, #8]
1210:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 132              		.loc 1 1210 0
 133 0098 0394     		str	r4, [sp, #12]
1211:../Src/main.c ****   HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 134              		.loc 1 1211 0
 135 009a 01A9     		add	r1, sp, #4
 136 009c 0E48     		ldr	r0, .L3+8
 137 009e FFF7FEFF 		bl	HAL_GPIO_Init
 138              	.LVL5:
1212:../Src/main.c **** 
1213:../Src/main.c ****   /*Configure GPIO pin : PC9 */
1214:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_9;
 139              		.loc 1 1214 0
 140 00a2 4FF40073 		mov	r3, #512
 141 00a6 0193     		str	r3, [sp, #4]
1215:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 142              		.loc 1 1215 0
 143 00a8 0297     		str	r7, [sp, #8]
1216:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 144              		.loc 1 1216 0
 145 00aa 0394     		str	r4, [sp, #12]
1217:../Src/main.c ****   GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 146              		.loc 1 1217 0
 147 00ac 0494     		str	r4, [sp, #16]
1218:../Src/main.c ****   HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 148              		.loc 1 1218 0
 149 00ae 01A9     		add	r1, sp, #4
 150 00b0 3046     		mov	r0, r6
 151 00b2 FFF7FEFF 		bl	HAL_GPIO_Init
ARM GAS  /tmp/ccx8Hxdu.s 			page 25


 152              	.LVL6:
1219:../Src/main.c **** 
1220:../Src/main.c ****   /*Configure GPIO pin : PD2 */
1221:../Src/main.c ****   GPIO_InitStruct.Pin = GPIO_PIN_2;
 153              		.loc 1 1221 0
 154 00b6 0423     		movs	r3, #4
 155 00b8 0193     		str	r3, [sp, #4]
1222:../Src/main.c ****   GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 156              		.loc 1 1222 0
 157 00ba 0295     		str	r5, [sp, #8]
1223:../Src/main.c ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
 158              		.loc 1 1223 0
 159 00bc 0394     		str	r4, [sp, #12]
1224:../Src/main.c ****   HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 160              		.loc 1 1224 0
 161 00be 0DEB0301 		add	r1, sp, r3
 162 00c2 0648     		ldr	r0, .L3+12
 163 00c4 FFF7FEFF 		bl	HAL_GPIO_Init
 164              	.LVL7:
1225:../Src/main.c **** 
1226:../Src/main.c **** }
 165              		.loc 1 1226 0
 166 00c8 06B0     		add	sp, sp, #24
 167              	.LCFI2:
 168              		.cfi_def_cfa_offset 24
 169              		@ sp needed
 170 00ca BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 171              	.L4:
 172 00ce 00BF     		.align	2
 173              	.L3:
 174 00d0 00380240 		.word	1073887232
 175 00d4 00080240 		.word	1073874944
 176 00d8 00040240 		.word	1073873920
 177 00dc 000C0240 		.word	1073875968
 178 00e0 00000240 		.word	1073872896
 179              		.cfi_endproc
 180              	.LFE135:
 182              		.section	.text.SystemClock_Config,"ax",%progbits
 183              		.align	2
 184              		.thumb
 185              		.thumb_func
 187              	SystemClock_Config:
 188              	.LFB130:
1045:../Src/main.c **** 
 189              		.loc 1 1045 0
 190              		.cfi_startproc
 191              		@ args = 0, pretend = 0, frame = 72
 192              		@ frame_needed = 0, uses_anonymous_args = 0
 193 0000 30B5     		push	{r4, r5, lr}
 194              	.LCFI3:
 195              		.cfi_def_cfa_offset 12
 196              		.cfi_offset 4, -12
 197              		.cfi_offset 5, -8
 198              		.cfi_offset 14, -4
 199 0002 93B0     		sub	sp, sp, #76
 200              	.LCFI4:
 201              		.cfi_def_cfa_offset 88
ARM GAS  /tmp/ccx8Hxdu.s 			page 26


1050:../Src/main.c **** 
 202              		.loc 1 1050 0
 203 0004 174A     		ldr	r2, .L7
 204 0006 136C     		ldr	r3, [r2, #64]
 205 0008 43F08053 		orr	r3, r3, #268435456
 206 000c 1364     		str	r3, [r2, #64]
1052:../Src/main.c **** 
 207              		.loc 1 1052 0
 208 000e A2F5E432 		sub	r2, r2, #116736
 209 0012 1368     		ldr	r3, [r2]
 210 0014 23F44043 		bic	r3, r3, #49152
 211 0018 43F40043 		orr	r3, r3, #32768
 212 001c 1360     		str	r3, [r2]
1054:../Src/main.c ****   RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 213              		.loc 1 1054 0
 214 001e 0224     		movs	r4, #2
 215 0020 0694     		str	r4, [sp, #24]
1055:../Src/main.c ****   RCC_OscInitStruct.HSICalibrationValue = 6;
 216              		.loc 1 1055 0
 217 0022 0123     		movs	r3, #1
 218 0024 0993     		str	r3, [sp, #36]
1056:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 219              		.loc 1 1056 0
 220 0026 0623     		movs	r3, #6
 221 0028 0A93     		str	r3, [sp, #40]
1057:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 222              		.loc 1 1057 0
 223 002a 0C94     		str	r4, [sp, #48]
1058:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLM = 16;
 224              		.loc 1 1058 0
 225 002c 0025     		movs	r5, #0
 226 002e 0D95     		str	r5, [sp, #52]
1059:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLN = 336;
 227              		.loc 1 1059 0
 228 0030 1023     		movs	r3, #16
 229 0032 0E93     		str	r3, [sp, #56]
1060:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 230              		.loc 1 1060 0
 231 0034 4FF4A873 		mov	r3, #336
 232 0038 0F93     		str	r3, [sp, #60]
1061:../Src/main.c ****   RCC_OscInitStruct.PLL.PLLQ = 7;
 233              		.loc 1 1061 0
 234 003a 0423     		movs	r3, #4
 235 003c 1093     		str	r3, [sp, #64]
1062:../Src/main.c ****   HAL_RCC_OscConfig(&RCC_OscInitStruct);
 236              		.loc 1 1062 0
 237 003e 0723     		movs	r3, #7
 238 0040 1193     		str	r3, [sp, #68]
1063:../Src/main.c **** 
 239              		.loc 1 1063 0
 240 0042 06A8     		add	r0, sp, #24
 241 0044 FFF7FEFF 		bl	HAL_RCC_OscConfig
 242              	.LVL8:
1065:../Src/main.c ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 243              		.loc 1 1065 0
 244 0048 0523     		movs	r3, #5
 245 004a 0193     		str	r3, [sp, #4]
ARM GAS  /tmp/ccx8Hxdu.s 			page 27


1066:../Src/main.c ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 246              		.loc 1 1066 0
 247 004c 0294     		str	r4, [sp, #8]
1067:../Src/main.c ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 248              		.loc 1 1067 0
 249 004e 0395     		str	r5, [sp, #12]
1068:../Src/main.c ****   RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 250              		.loc 1 1068 0
 251 0050 4FF48053 		mov	r3, #4096
 252 0054 0493     		str	r3, [sp, #16]
1069:../Src/main.c ****   HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 253              		.loc 1 1069 0
 254 0056 0595     		str	r5, [sp, #20]
1070:../Src/main.c **** 
 255              		.loc 1 1070 0
 256 0058 2146     		mov	r1, r4
 257 005a 01A8     		add	r0, sp, #4
 258 005c FFF7FEFF 		bl	HAL_RCC_ClockConfig
 259              	.LVL9:
1072:../Src/main.c **** 
 260              		.loc 1 1072 0
 261 0060 13B0     		add	sp, sp, #76
 262              	.LCFI5:
 263              		.cfi_def_cfa_offset 12
 264              		@ sp needed
 265 0062 30BD     		pop	{r4, r5, pc}
 266              	.L8:
 267              		.align	2
 268              	.L7:
 269 0064 00380240 		.word	1073887232
 270              		.cfi_endproc
 271              	.LFE130:
 273              		.section	.text.MX_I2C1_Init,"ax",%progbits
 274              		.align	2
 275              		.thumb
 276              		.thumb_func
 278              	MX_I2C1_Init:
 279              	.LFB131:
1076:../Src/main.c **** 
 280              		.loc 1 1076 0
 281              		.cfi_startproc
 282              		@ args = 0, pretend = 0, frame = 0
 283              		@ frame_needed = 0, uses_anonymous_args = 0
 284 0000 08B5     		push	{r3, lr}
 285              	.LCFI6:
 286              		.cfi_def_cfa_offset 8
 287              		.cfi_offset 3, -8
 288              		.cfi_offset 14, -4
1078:../Src/main.c ****   hi2c1.Init.ClockSpeed = 400000;
 289              		.loc 1 1078 0
 290 0002 0948     		ldr	r0, .L11
 291 0004 094B     		ldr	r3, .L11+4
 292 0006 0360     		str	r3, [r0]
1079:../Src/main.c ****   hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
 293              		.loc 1 1079 0
 294 0008 094B     		ldr	r3, .L11+8
 295 000a 4360     		str	r3, [r0, #4]
ARM GAS  /tmp/ccx8Hxdu.s 			page 28


1080:../Src/main.c ****   hi2c1.Init.OwnAddress1 = 0;
 296              		.loc 1 1080 0
 297 000c 0023     		movs	r3, #0
 298 000e 8360     		str	r3, [r0, #8]
1081:../Src/main.c ****   hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 299              		.loc 1 1081 0
 300 0010 C360     		str	r3, [r0, #12]
1082:../Src/main.c ****   hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLED;
 301              		.loc 1 1082 0
 302 0012 4FF48042 		mov	r2, #16384
 303 0016 0261     		str	r2, [r0, #16]
1083:../Src/main.c ****   hi2c1.Init.OwnAddress2 = 0;
 304              		.loc 1 1083 0
 305 0018 4361     		str	r3, [r0, #20]
1084:../Src/main.c ****   hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLED;
 306              		.loc 1 1084 0
 307 001a 8361     		str	r3, [r0, #24]
1085:../Src/main.c ****   hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLED;
 308              		.loc 1 1085 0
 309 001c C361     		str	r3, [r0, #28]
1086:../Src/main.c ****   HAL_I2C_Init(&hi2c1);
 310              		.loc 1 1086 0
 311 001e 0362     		str	r3, [r0, #32]
1087:../Src/main.c **** 
 312              		.loc 1 1087 0
 313 0020 FFF7FEFF 		bl	HAL_I2C_Init
 314              	.LVL10:
 315 0024 08BD     		pop	{r3, pc}
 316              	.L12:
 317 0026 00BF     		.align	2
 318              	.L11:
 319 0028 00000000 		.word	hi2c1
 320 002c 00540040 		.word	1073763328
 321 0030 801A0600 		.word	400000
 322              		.cfi_endproc
 323              	.LFE131:
 325              		.section	.text.MX_TIM3_Init,"ax",%progbits
 326              		.align	2
 327              		.thumb
 328              		.thumb_func
 330              	MX_TIM3_Init:
 331              	.LFB132:
1093:../Src/main.c **** 
 332              		.loc 1 1093 0
 333              		.cfi_startproc
 334              		@ args = 0, pretend = 0, frame = 24
 335              		@ frame_needed = 0, uses_anonymous_args = 0
 336 0000 30B5     		push	{r4, r5, lr}
 337              	.LCFI7:
 338              		.cfi_def_cfa_offset 12
 339              		.cfi_offset 4, -12
 340              		.cfi_offset 5, -8
 341              		.cfi_offset 14, -4
 342 0002 87B0     		sub	sp, sp, #28
 343              	.LCFI8:
 344              		.cfi_def_cfa_offset 40
1098:../Src/main.c ****   htim3.Init.Prescaler = 42000-1;
ARM GAS  /tmp/ccx8Hxdu.s 			page 29


 345              		.loc 1 1098 0
 346 0004 0F4C     		ldr	r4, .L15
 347 0006 104B     		ldr	r3, .L15+4
 348 0008 2360     		str	r3, [r4]
1099:../Src/main.c ****   htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 349              		.loc 1 1099 0
 350 000a 4AF20F43 		movw	r3, #41999
 351 000e 6360     		str	r3, [r4, #4]
1100:../Src/main.c ****   htim3.Init.Period = 1000-1;
 352              		.loc 1 1100 0
 353 0010 0025     		movs	r5, #0
 354 0012 A560     		str	r5, [r4, #8]
1101:../Src/main.c ****   htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 355              		.loc 1 1101 0
 356 0014 40F2E733 		movw	r3, #999
 357 0018 E360     		str	r3, [r4, #12]
1102:../Src/main.c ****   HAL_TIM_Base_Init(&htim3);
 358              		.loc 1 1102 0
 359 001a 2561     		str	r5, [r4, #16]
1103:../Src/main.c **** 
 360              		.loc 1 1103 0
 361 001c 2046     		mov	r0, r4
 362 001e FFF7FEFF 		bl	HAL_TIM_Base_Init
 363              	.LVL11:
1105:../Src/main.c ****   HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);
 364              		.loc 1 1105 0
 365 0022 06A9     		add	r1, sp, #24
 366 0024 4FF48053 		mov	r3, #4096
 367 0028 41F8103D 		str	r3, [r1, #-16]!
1106:../Src/main.c **** 
 368              		.loc 1 1106 0
 369 002c 2046     		mov	r0, r4
 370 002e FFF7FEFF 		bl	HAL_TIM_ConfigClockSource
 371              	.LVL12:
1108:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 372              		.loc 1 1108 0
 373 0032 0095     		str	r5, [sp]
1109:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);
 374              		.loc 1 1109 0
 375 0034 0195     		str	r5, [sp, #4]
1110:../Src/main.c **** 
 376              		.loc 1 1110 0
 377 0036 6946     		mov	r1, sp
 378 0038 2046     		mov	r0, r4
 379 003a FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 380              	.LVL13:
1112:../Src/main.c **** 
 381              		.loc 1 1112 0
 382 003e 07B0     		add	sp, sp, #28
 383              	.LCFI9:
 384              		.cfi_def_cfa_offset 12
 385              		@ sp needed
 386 0040 30BD     		pop	{r4, r5, pc}
 387              	.L16:
 388 0042 00BF     		.align	2
 389              	.L15:
 390 0044 00000000 		.word	htim3
ARM GAS  /tmp/ccx8Hxdu.s 			page 30


 391 0048 00040040 		.word	1073742848
 392              		.cfi_endproc
 393              	.LFE132:
 395              		.section	.text.MX_USART2_UART_Init,"ax",%progbits
 396              		.align	2
 397              		.thumb
 398              		.thumb_func
 400              	MX_USART2_UART_Init:
 401              	.LFB134:
1132:../Src/main.c **** 
 402              		.loc 1 1132 0
 403              		.cfi_startproc
 404              		@ args = 0, pretend = 0, frame = 0
 405              		@ frame_needed = 0, uses_anonymous_args = 0
 406 0000 08B5     		push	{r3, lr}
 407              	.LCFI10:
 408              		.cfi_def_cfa_offset 8
 409              		.cfi_offset 3, -8
 410              		.cfi_offset 14, -4
1134:../Src/main.c ****   huart2.Init.BaudRate = 115200;
 411              		.loc 1 1134 0
 412 0002 0848     		ldr	r0, .L19
 413 0004 084B     		ldr	r3, .L19+4
 414 0006 0360     		str	r3, [r0]
1135:../Src/main.c ****   huart2.Init.WordLength = UART_WORDLENGTH_8B;
 415              		.loc 1 1135 0
 416 0008 4FF4E133 		mov	r3, #115200
 417 000c 4360     		str	r3, [r0, #4]
1136:../Src/main.c ****   huart2.Init.StopBits = UART_STOPBITS_1;
 418              		.loc 1 1136 0
 419 000e 0023     		movs	r3, #0
 420 0010 8360     		str	r3, [r0, #8]
1137:../Src/main.c ****   huart2.Init.Parity = UART_PARITY_NONE;
 421              		.loc 1 1137 0
 422 0012 C360     		str	r3, [r0, #12]
1138:../Src/main.c ****   huart2.Init.Mode = UART_MODE_TX_RX;
 423              		.loc 1 1138 0
 424 0014 0361     		str	r3, [r0, #16]
1139:../Src/main.c ****   huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 425              		.loc 1 1139 0
 426 0016 0C22     		movs	r2, #12
 427 0018 4261     		str	r2, [r0, #20]
1140:../Src/main.c ****   huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 428              		.loc 1 1140 0
 429 001a 8361     		str	r3, [r0, #24]
1141:../Src/main.c ****   HAL_UART_Init(&huart2);
 430              		.loc 1 1141 0
 431 001c C361     		str	r3, [r0, #28]
1142:../Src/main.c **** 
 432              		.loc 1 1142 0
 433 001e FFF7FEFF 		bl	HAL_UART_Init
 434              	.LVL14:
 435 0022 08BD     		pop	{r3, pc}
 436              	.L20:
 437              		.align	2
 438              	.L19:
 439 0024 00000000 		.word	huart2
ARM GAS  /tmp/ccx8Hxdu.s 			page 31


 440 0028 00440040 		.word	1073759232
 441              		.cfi_endproc
 442              	.LFE134:
 444              		.section	.text.MX_USART1_UART_Init,"ax",%progbits
 445              		.align	2
 446              		.thumb
 447              		.thumb_func
 449              	MX_USART1_UART_Init:
 450              	.LFB133:
1116:../Src/main.c **** 
 451              		.loc 1 1116 0
 452              		.cfi_startproc
 453              		@ args = 0, pretend = 0, frame = 0
 454              		@ frame_needed = 0, uses_anonymous_args = 0
 455 0000 08B5     		push	{r3, lr}
 456              	.LCFI11:
 457              		.cfi_def_cfa_offset 8
 458              		.cfi_offset 3, -8
 459              		.cfi_offset 14, -4
1118:../Src/main.c ****   huart1.Init.BaudRate = 1000000;
 460              		.loc 1 1118 0
 461 0002 0848     		ldr	r0, .L23
 462 0004 084B     		ldr	r3, .L23+4
 463 0006 0360     		str	r3, [r0]
1119:../Src/main.c ****   huart1.Init.WordLength = UART_WORDLENGTH_8B;
 464              		.loc 1 1119 0
 465 0008 084B     		ldr	r3, .L23+8
 466 000a 4360     		str	r3, [r0, #4]
1120:../Src/main.c ****   huart1.Init.StopBits = UART_STOPBITS_1;
 467              		.loc 1 1120 0
 468 000c 0023     		movs	r3, #0
 469 000e 8360     		str	r3, [r0, #8]
1121:../Src/main.c ****   huart1.Init.Parity = UART_PARITY_NONE;
 470              		.loc 1 1121 0
 471 0010 C360     		str	r3, [r0, #12]
1122:../Src/main.c ****   huart1.Init.Mode = UART_MODE_TX_RX;
 472              		.loc 1 1122 0
 473 0012 0361     		str	r3, [r0, #16]
1123:../Src/main.c ****   huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 474              		.loc 1 1123 0
 475 0014 0C22     		movs	r2, #12
 476 0016 4261     		str	r2, [r0, #20]
1124:../Src/main.c ****   huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 477              		.loc 1 1124 0
 478 0018 8361     		str	r3, [r0, #24]
1125:../Src/main.c ****   HAL_UART_Init(&huart1);
 479              		.loc 1 1125 0
 480 001a C361     		str	r3, [r0, #28]
1126:../Src/main.c **** 
 481              		.loc 1 1126 0
 482 001c FFF7FEFF 		bl	HAL_UART_Init
 483              	.LVL15:
 484 0020 08BD     		pop	{r3, pc}
 485              	.L24:
 486 0022 00BF     		.align	2
 487              	.L23:
 488 0024 00000000 		.word	huart1
ARM GAS  /tmp/ccx8Hxdu.s 			page 32


 489 0028 00100140 		.word	1073811456
 490 002c 40420F00 		.word	1000000
 491              		.cfi_endproc
 492              	.LFE133:
 494              		.section	.text.MX_TIM5_Init,"ax",%progbits
 495              		.align	2
 496              		.global	MX_TIM5_Init
 497              		.thumb
 498              		.thumb_func
 500              	MX_TIM5_Init:
 501              	.LFB113:
 178:../Src/main.c **** 
 502              		.loc 1 178 0
 503              		.cfi_startproc
 504              		@ args = 0, pretend = 0, frame = 40
 505              		@ frame_needed = 0, uses_anonymous_args = 0
 506 0000 30B5     		push	{r4, r5, lr}
 507              	.LCFI12:
 508              		.cfi_def_cfa_offset 12
 509              		.cfi_offset 4, -12
 510              		.cfi_offset 5, -8
 511              		.cfi_offset 14, -4
 512 0002 8BB0     		sub	sp, sp, #44
 513              	.LCFI13:
 514              		.cfi_def_cfa_offset 56
 183:../Src/main.c ****   htim5.Init.Prescaler = 83;
 515              		.loc 1 183 0
 516 0004 0F4D     		ldr	r5, .L27
 517 0006 104B     		ldr	r3, .L27+4
 518 0008 2B60     		str	r3, [r5]
 184:../Src/main.c ****   htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 519              		.loc 1 184 0
 520 000a 5323     		movs	r3, #83
 521 000c 6B60     		str	r3, [r5, #4]
 185:../Src/main.c ****   htim5.Init.Period = 0xFFFFFFFF;
 522              		.loc 1 185 0
 523 000e 0024     		movs	r4, #0
 524 0010 AC60     		str	r4, [r5, #8]
 186:../Src/main.c ****   htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 525              		.loc 1 186 0
 526 0012 4FF0FF33 		mov	r3, #-1
 527 0016 EB60     		str	r3, [r5, #12]
 187:../Src/main.c ****   HAL_TIM_OC_Init(&htim5);
 528              		.loc 1 187 0
 529 0018 2C61     		str	r4, [r5, #16]
 188:../Src/main.c **** 
 530              		.loc 1 188 0
 531 001a 2846     		mov	r0, r5
 532 001c FFF7FEFF 		bl	HAL_TIM_OC_Init
 533              	.LVL16:
 190:../Src/main.c ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 534              		.loc 1 190 0
 535 0020 0894     		str	r4, [sp, #32]
 191:../Src/main.c ****   HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig);
 536              		.loc 1 191 0
 537 0022 0994     		str	r4, [sp, #36]
 192:../Src/main.c **** 
ARM GAS  /tmp/ccx8Hxdu.s 			page 33


 538              		.loc 1 192 0
 539 0024 08A9     		add	r1, sp, #32
 540 0026 2846     		mov	r0, r5
 541 0028 FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 542              	.LVL17:
 194:../Src/main.c ****   sConfigOC.Pulse = 0;
 543              		.loc 1 194 0
 544 002c 0194     		str	r4, [sp, #4]
 195:../Src/main.c ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 545              		.loc 1 195 0
 546 002e 0294     		str	r4, [sp, #8]
 196:../Src/main.c ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 547              		.loc 1 196 0
 548 0030 0394     		str	r4, [sp, #12]
 197:../Src/main.c ****   HAL_TIM_OC_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1);
 549              		.loc 1 197 0
 550 0032 0594     		str	r4, [sp, #20]
 198:../Src/main.c **** 
 551              		.loc 1 198 0
 552 0034 2246     		mov	r2, r4
 553 0036 01A9     		add	r1, sp, #4
 554 0038 2846     		mov	r0, r5
 555 003a FFF7FEFF 		bl	HAL_TIM_OC_ConfigChannel
 556              	.LVL18:
 200:../Src/main.c **** 
 557              		.loc 1 200 0
 558 003e 0BB0     		add	sp, sp, #44
 559              	.LCFI14:
 560              		.cfi_def_cfa_offset 12
 561              		@ sp needed
 562 0040 30BD     		pop	{r4, r5, pc}
 563              	.L28:
 564 0042 00BF     		.align	2
 565              	.L27:
 566 0044 00000000 		.word	htim5
 567 0048 000C0040 		.word	1073744896
 568              		.cfi_endproc
 569              	.LFE113:
 571              		.section	.text.TimeStamp_Init,"ax",%progbits
 572              		.align	2
 573              		.global	TimeStamp_Init
 574              		.thumb
 575              		.thumb_func
 577              	TimeStamp_Init:
 578              	.LFB114:
 202:../Src/main.c ****     MX_TIM5_Init();
 579              		.loc 1 202 0
 580              		.cfi_startproc
 581              		@ args = 0, pretend = 0, frame = 0
 582              		@ frame_needed = 0, uses_anonymous_args = 0
 583 0000 08B5     		push	{r3, lr}
 584              	.LCFI15:
 585              		.cfi_def_cfa_offset 8
 586              		.cfi_offset 3, -8
 587              		.cfi_offset 14, -4
 203:../Src/main.c **** }
 588              		.loc 1 203 0
ARM GAS  /tmp/ccx8Hxdu.s 			page 34


 589 0002 FFF7FEFF 		bl	MX_TIM5_Init
 590              	.LVL19:
 591 0006 08BD     		pop	{r3, pc}
 592              		.cfi_endproc
 593              	.LFE114:
 595              		.section	.text.TimeStamp_Reset,"ax",%progbits
 596              		.align	2
 597              		.global	TimeStamp_Reset
 598              		.thumb
 599              		.thumb_func
 601              	TimeStamp_Reset:
 602              	.LFB115:
 206:../Src/main.c ****     HAL_TIM_Base_Start(&htim5);
 603              		.loc 1 206 0
 604              		.cfi_startproc
 605              		@ args = 0, pretend = 0, frame = 0
 606              		@ frame_needed = 0, uses_anonymous_args = 0
 607 0000 10B5     		push	{r4, lr}
 608              	.LCFI16:
 609              		.cfi_def_cfa_offset 8
 610              		.cfi_offset 4, -8
 611              		.cfi_offset 14, -4
 207:../Src/main.c ****     htim5.Instance->CNT=0;
 612              		.loc 1 207 0
 613 0002 044C     		ldr	r4, .L33
 614 0004 2046     		mov	r0, r4
 615 0006 FFF7FEFF 		bl	HAL_TIM_Base_Start
 616              	.LVL20:
 208:../Src/main.c **** }
 617              		.loc 1 208 0
 618 000a 2368     		ldr	r3, [r4]
 619 000c 0022     		movs	r2, #0
 620 000e 5A62     		str	r2, [r3, #36]
 621 0010 10BD     		pop	{r4, pc}
 622              	.L34:
 623 0012 00BF     		.align	2
 624              	.L33:
 625 0014 00000000 		.word	htim5
 626              		.cfi_endproc
 627              	.LFE115:
 629              		.section	.text.TimeStamp_Get,"ax",%progbits
 630              		.align	2
 631              		.global	TimeStamp_Get
 632              		.thumb
 633              		.thumb_func
 635              	TimeStamp_Get:
 636              	.LFB116:
 211:../Src/main.c ****     return htim5.Instance->CNT;
 637              		.loc 1 211 0
 638              		.cfi_startproc
 639              		@ args = 0, pretend = 0, frame = 0
 640              		@ frame_needed = 0, uses_anonymous_args = 0
 641              		@ link register save eliminated.
 212:../Src/main.c **** }
 642              		.loc 1 212 0
 643 0000 014B     		ldr	r3, .L36
 644 0002 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccx8Hxdu.s 			page 35


 645 0004 586A     		ldr	r0, [r3, #36]
 213:../Src/main.c **** 
 646              		.loc 1 213 0
 647 0006 7047     		bx	lr
 648              	.L37:
 649              		.align	2
 650              	.L36:
 651 0008 00000000 		.word	htim5
 652              		.cfi_endproc
 653              	.LFE116:
 655              		.section	.text.BSP_GetPushButton,"ax",%progbits
 656              		.align	2
 657              		.global	BSP_GetPushButton
 658              		.thumb
 659              		.thumb_func
 661              	BSP_GetPushButton:
 662              	.LFB117:
 246:../Src/main.c ****     GPIO_PinState state ;
 663              		.loc 1 246 0
 664              		.cfi_startproc
 665              		@ args = 0, pretend = 0, frame = 0
 666              		@ frame_needed = 0, uses_anonymous_args = 0
 667 0000 08B5     		push	{r3, lr}
 668              	.LCFI17:
 669              		.cfi_def_cfa_offset 8
 670              		.cfi_offset 3, -8
 671              		.cfi_offset 14, -4
 248:../Src/main.c ****     return state;
 672              		.loc 1 248 0
 673 0002 4FF40051 		mov	r1, #8192
 674 0006 0248     		ldr	r0, .L40
 675 0008 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 676              	.LVL21:
 250:../Src/main.c **** 
 677              		.loc 1 250 0
 678 000c 08BD     		pop	{r3, pc}
 679              	.L41:
 680 000e 00BF     		.align	2
 681              	.L40:
 682 0010 00080240 		.word	1073874944
 683              		.cfi_endproc
 684              	.LFE117:
 686              		.section	.text.PusbButton_WaitUnPress,"ax",%progbits
 687              		.align	2
 688              		.global	PusbButton_WaitUnPress
 689              		.thumb
 690              		.thumb_func
 692              	PusbButton_WaitUnPress:
 693              	.LFB118:
 262:../Src/main.c ****     uint32_t TimeStarted;
 694              		.loc 1 262 0
 695              		.cfi_startproc
 696              		@ args = 0, pretend = 0, frame = 0
 697              		@ frame_needed = 0, uses_anonymous_args = 0
 698 0000 10B5     		push	{r4, lr}
 699              	.LCFI18:
 700              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccx8Hxdu.s 			page 36


 701              		.cfi_offset 4, -8
 702              		.cfi_offset 14, -4
 264:../Src/main.c ****     while( !BSP_GetPushButton() ){ ; /* debounce */
 703              		.loc 1 264 0
 704 0002 FFF7FEFF 		bl	HAL_GetTick
 705              	.LVL22:
 706 0006 0446     		mov	r4, r0
 707              	.LVL23:
 265:../Src/main.c ****         if(HAL_GetTick()- TimeStarted> PressBPSwicthTime){
 708              		.loc 1 265 0
 709 0008 08E0     		b	.L44
 710              	.LVL24:
 711              	.L45:
 266:../Src/main.c ****             XNUCLEO53L0A1_SetDisplayString (" rb ");
 712              		.loc 1 266 0
 713 000a FFF7FEFF 		bl	HAL_GetTick
 714              	.LVL25:
 715 000e 001B     		subs	r0, r0, r4
 716 0010 B0F57A7F 		cmp	r0, #1000
 717 0014 02D9     		bls	.L44
 267:../Src/main.c ****         }
 718              		.loc 1 267 0
 719 0016 0848     		ldr	r0, .L47
 720 0018 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 721              	.LVL26:
 722              	.L44:
 265:../Src/main.c ****         if(HAL_GetTick()- TimeStarted> PressBPSwicthTime){
 723              		.loc 1 265 0
 724 001c FFF7FEFF 		bl	BSP_GetPushButton
 725              	.LVL27:
 726 0020 0028     		cmp	r0, #0
 727 0022 F2D0     		beq	.L45
 270:../Src/main.c **** 
 728              		.loc 1 270 0
 729 0024 FFF7FEFF 		bl	HAL_GetTick
 730              	.LVL28:
 731 0028 001B     		subs	r0, r0, r4
 272:../Src/main.c **** 
 732              		.loc 1 272 0
 733 002a B0F57A7F 		cmp	r0, #1000
 734 002e 94BF     		ite	ls
 735 0030 0020     		movls	r0, #0
 736 0032 0120     		movhi	r0, #1
 737 0034 10BD     		pop	{r4, pc}
 738              	.LVL29:
 739              	.L48:
 740 0036 00BF     		.align	2
 741              	.L47:
 742 0038 00000000 		.word	.LC0
 743              		.cfi_endproc
 744              	.LFE118:
 746              		.section	.text.HandleError,"ax",%progbits
 747              		.align	2
 748              		.global	HandleError
 749              		.thumb
 750              		.thumb_func
 752              	HandleError:
ARM GAS  /tmp/ccx8Hxdu.s 			page 37


 753              	.LFB119:
 297:../Src/main.c ****     char msg[16];
 754              		.loc 1 297 0
 755              		.cfi_startproc
 756              		@ args = 0, pretend = 0, frame = 16
 757              		@ frame_needed = 0, uses_anonymous_args = 0
 758              	.LVL30:
 759 0000 00B5     		push	{lr}
 760              	.LCFI19:
 761              		.cfi_def_cfa_offset 4
 762              		.cfi_offset 14, -4
 763 0002 85B0     		sub	sp, sp, #20
 764              	.LCFI20:
 765              		.cfi_def_cfa_offset 24
 299:../Src/main.c ****     XNUCLEO53L0A1_SetDisplayString(msg);
 766              		.loc 1 299 0
 767 0004 0246     		mov	r2, r0
 768 0006 0449     		ldr	r1, .L52
 769 0008 6846     		mov	r0, sp
 770              	.LVL31:
 771 000a FFF7FEFF 		bl	sprintf
 772              	.LVL32:
 300:../Src/main.c ****     while(1){};
 773              		.loc 1 300 0
 774 000e 6846     		mov	r0, sp
 775 0010 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 776              	.LVL33:
 777              	.L50:
 778 0014 FEE7     		b	.L50
 779              	.L53:
 780 0016 00BF     		.align	2
 781              	.L52:
 782 0018 08000000 		.word	.LC1
 783              		.cfi_endproc
 784              	.LFE119:
 786              		.section	.text.DetectSensors,"ax",%progbits
 787              		.align	2
 788              		.global	DetectSensors
 789              		.thumb
 790              		.thumb_func
 792              	DetectSensors:
 793              	.LFB120:
 310:../Src/main.c ****     int i;
 794              		.loc 1 310 0
 795              		.cfi_startproc
 796              		@ args = 0, pretend = 0, frame = 8
 797              		@ frame_needed = 0, uses_anonymous_args = 0
 798              	.LVL34:
 799 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 800              	.LCFI21:
 801              		.cfi_def_cfa_offset 24
 802              		.cfi_offset 4, -24
 803              		.cfi_offset 5, -20
 804              		.cfi_offset 6, -16
 805              		.cfi_offset 7, -12
 806              		.cfi_offset 8, -8
 807              		.cfi_offset 14, -4
ARM GAS  /tmp/ccx8Hxdu.s 			page 38


 808 0004 82B0     		sub	sp, sp, #8
 809              	.LCFI22:
 810              		.cfi_def_cfa_offset 32
 811 0006 0746     		mov	r7, r0
 316:../Src/main.c ****     /* Reset all */
 812              		.loc 1 316 0
 813 0008 4F4B     		ldr	r3, .L69
 814 000a 93E80300 		ldmia	r3, {r0, r1}
 815              	.LVL35:
 816 000e 0090     		str	r0, [sp]
 817 0010 8DF80410 		strb	r1, [sp, #4]
 318:../Src/main.c ****     for (i = 0; i < 3; i++)
 818              		.loc 1 318 0
 819 0014 0024     		movs	r4, #0
 820 0016 4D4B     		ldr	r3, .L69+4
 821 0018 1C60     		str	r4, [r3]
 822              	.LVL36:
 319:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 823              		.loc 1 319 0
 824 001a 04E0     		b	.L55
 825              	.LVL37:
 826              	.L56:
 320:../Src/main.c **** 
 827              		.loc 1 320 0 discriminator 3
 828 001c 0021     		movs	r1, #0
 829 001e 2046     		mov	r0, r4
 830 0020 FFF7FEFF 		bl	XNUCLEO53L0A1_ResetId
 831              	.LVL38:
 319:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 832              		.loc 1 319 0 discriminator 3
 833 0024 0134     		adds	r4, r4, #1
 834              	.LVL39:
 835              	.L55:
 319:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId(i, 0);
 836              		.loc 1 319 0 is_stmt 0 discriminator 1
 837 0026 022C     		cmp	r4, #2
 838 0028 F8DD     		ble	.L56
 839 002a 0025     		movs	r5, #0
 840 002c 60E0     		b	.L57
 841              	.LVL40:
 842              	.L61:
 843              	.LBB2:
 325:../Src/main.c ****         pDev->I2cDevAddr = 0x52;
 844              		.loc 1 325 0 is_stmt 1
 845 002e 4FF4C874 		mov	r4, #400
 846 0032 474B     		ldr	r3, .L69+8
 847 0034 04FB0534 		mla	r4, r4, r5, r3
 848              	.LVL41:
 326:../Src/main.c ****         pDev->Present = 0;
 849              		.loc 1 326 0
 850 0038 5223     		movs	r3, #82
 851 003a 84F86031 		strb	r3, [r4, #352]
 327:../Src/main.c ****         status = XNUCLEO53L0A1_ResetId( pDev->Id, 1);
 852              		.loc 1 327 0
 853 003e 0023     		movs	r3, #0
 854 0040 C4F86831 		str	r3, [r4, #360]
 328:../Src/main.c ****         HAL_Delay(2);
ARM GAS  /tmp/ccx8Hxdu.s 			page 39


 855              		.loc 1 328 0
 856 0044 0121     		movs	r1, #1
 857 0046 D4F86401 		ldr	r0, [r4, #356]
 858 004a FFF7FEFF 		bl	XNUCLEO53L0A1_ResetId
 859              	.LVL42:
 860 004e 0646     		mov	r6, r0
 861              	.LVL43:
 329:../Src/main.c ****         FinalAddress=0x52+(i+1)*2;
 862              		.loc 1 329 0
 863 0050 0220     		movs	r0, #2
 864              	.LVL44:
 865 0052 FFF7FEFF 		bl	HAL_Delay
 866              	.LVL45:
 330:../Src/main.c **** 
 867              		.loc 1 330 0
 868 0056 05F12A03 		add	r3, r5, #42
 869 005a 4FEA4308 		lsl	r8, r3, #1
 870              	.LVL46:
 334:../Src/main.c ****         		status = VL53L0X_WrByte(pDev, 0x88, 0x00);
 871              		.loc 1 334 0
 872 005e 26B9     		cbnz	r6, .L58
 335:../Src/main.c **** 
 873              		.loc 1 335 0
 874 0060 0022     		movs	r2, #0
 875 0062 8821     		movs	r1, #136
 876 0064 2046     		mov	r0, r4
 877 0066 FFF7FEFF 		bl	VL53L0X_WrByte
 878              	.LVL47:
 879              	.L58:
 338:../Src/main.c ****             if (status) {
 880              		.loc 1 338 0
 881 006a 0DF10602 		add	r2, sp, #6
 882 006e C021     		movs	r1, #192
 883 0070 2046     		mov	r0, r4
 884 0072 FFF7FEFF 		bl	VL53L0X_RdWord
 885              	.LVL48:
 886 0076 0346     		mov	r3, r0
 887              	.LVL49:
 339:../Src/main.c ****                 debug_printf("#%d Read id fail\n", i);
 888              		.loc 1 339 0
 889 0078 A0BB     		cbnz	r0, .L59
 343:../Src/main.c **** 				/* Sensor is found => Change its I2C address to final one */
 890              		.loc 1 343 0
 891 007a BDF80620 		ldrh	r2, [sp, #6]
 892 007e 4EF6AA63 		movw	r3, #61098
 893 0082 9A42     		cmp	r2, r3
 894 0084 2DD1     		bne	.L66
 345:../Src/main.c ****                 if (status != 0) {
 895              		.loc 1 345 0
 896 0086 5FFA88F8 		uxtb	r8, r8
 897              	.LVL50:
 898 008a 4146     		mov	r1, r8
 899 008c 2046     		mov	r0, r4
 900              	.LVL51:
 901 008e FFF7FEFF 		bl	VL53L0X_SetDeviceAddress
 902              	.LVL52:
 903 0092 0346     		mov	r3, r0
ARM GAS  /tmp/ccx8Hxdu.s 			page 40


 904              	.LVL53:
 346:../Src/main.c ****                     debug_printf("#i VL53L0X_SetDeviceAddress fail\n", i);
 905              		.loc 1 346 0
 906 0094 30BB     		cbnz	r0, .L59
 350:../Src/main.c ****                 /* Check all is OK with the new I2C address and initialize the sensor */
 907              		.loc 1 350 0
 908 0096 4FF4C873 		mov	r3, #400
 909 009a 2D4A     		ldr	r2, .L69+8
 910 009c 03FB0523 		mla	r3, r3, r5, r2
 911 00a0 83F86081 		strb	r8, [r3, #352]
 352:../Src/main.c ****                 if (status != 0) {
 912              		.loc 1 352 0
 913 00a4 0DF10602 		add	r2, sp, #6
 914 00a8 C021     		movs	r1, #192
 915 00aa 2046     		mov	r0, r4
 916              	.LVL54:
 917 00ac FFF7FEFF 		bl	VL53L0X_RdWord
 918              	.LVL55:
 919 00b0 0346     		mov	r3, r0
 920              	.LVL56:
 353:../Src/main.c **** 					debug_printf("#i VL53L0X_RdWord fail\n", i);
 921              		.loc 1 353 0
 922 00b2 B8B9     		cbnz	r0, .L59
 358:../Src/main.c ****                 if( status == 0 ){
 923              		.loc 1 358 0
 924 00b4 2046     		mov	r0, r4
 925              	.LVL57:
 926 00b6 FFF7FEFF 		bl	VL53L0X_DataInit
 927              	.LVL58:
 928 00ba 0346     		mov	r3, r0
 929              	.LVL59:
 359:../Src/main.c ****                     pDev->Present = 1;
 930              		.loc 1 359 0
 931 00bc 90B9     		cbnz	r0, .L59
 360:../Src/main.c ****                 }
 932              		.loc 1 360 0
 933 00be 4FF4C872 		mov	r2, #400
 934 00c2 2349     		ldr	r1, .L69+8
 935 00c4 02FB0511 		mla	r1, r2, r5, r1
 936 00c8 0122     		movs	r2, #1
 937 00ca C1F86821 		str	r2, [r1, #360]
 367:../Src/main.c ****                 nDevMask |= 1 << i;
 938              		.loc 1 367 0
 939 00ce 1F48     		ldr	r0, .L69+4
 940              	.LVL60:
 941 00d0 0168     		ldr	r1, [r0]
 942 00d2 1144     		add	r1, r1, r2
 943 00d4 0160     		str	r1, [r0]
 368:../Src/main.c ****                 pDev->Present = 1;
 944              		.loc 1 368 0
 945 00d6 AA40     		lsls	r2, r2, r5
 946 00d8 1E49     		ldr	r1, .L69+12
 947 00da 0868     		ldr	r0, [r1]
 948 00dc 0243     		orrs	r2, r2, r0
 949 00de 0A60     		str	r2, [r1]
 950 00e0 00E0     		b	.L59
 951              	.LVL61:
ARM GAS  /tmp/ccx8Hxdu.s 			page 41


 952              	.L66:
 373:../Src/main.c ****             }
 953              		.loc 1 373 0
 954 00e2 0123     		movs	r3, #1
 955              	.LVL62:
 956              	.L59:
 377:../Src/main.c ****             XNUCLEO53L0A1_ResetId(i, 0);
 957              		.loc 1 377 0
 958 00e4 1BB1     		cbz	r3, .L60
 378:../Src/main.c ****         }
 959              		.loc 1 378 0
 960 00e6 0021     		movs	r1, #0
 961 00e8 2846     		mov	r0, r5
 962 00ea FFF7FEFF 		bl	XNUCLEO53L0A1_ResetId
 963              	.LVL63:
 964              	.L60:
 965              	.LBE2:
 323:../Src/main.c ****         VL53L0X_Dev_t *pDev;
 966              		.loc 1 323 0 discriminator 2
 967 00ee 0135     		adds	r5, r5, #1
 968              	.LVL64:
 969              	.L57:
 323:../Src/main.c ****         VL53L0X_Dev_t *pDev;
 970              		.loc 1 323 0 is_stmt 0 discriminator 1
 971 00f0 022D     		cmp	r5, #2
 972 00f2 9CDD     		ble	.L61
 382:../Src/main.c ****         for(i=0; i<3; i++){
 973              		.loc 1 382 0 is_stmt 1
 974 00f4 B7B9     		cbnz	r7, .L67
 975 00f6 22E0     		b	.L63
 976              	.LVL65:
 977              	.L65:
 384:../Src/main.c ****                 PresentMsg[i+1]=VL53L0XDevs[i].DevLetter;
 978              		.loc 1 384 0
 979 00f8 4FF4C872 		mov	r2, #400
 980 00fc 1449     		ldr	r1, .L69+8
 981 00fe 02FB0312 		mla	r2, r2, r3, r1
 982 0102 D2F86821 		ldr	r2, [r2, #360]
 983 0106 5AB1     		cbz	r2, .L64
 385:../Src/main.c ****             }
 984              		.loc 1 385 0
 985 0108 5A1C     		adds	r2, r3, #1
 986 010a 4FF4C871 		mov	r1, #400
 987 010e 1048     		ldr	r0, .L69+8
 988 0110 01FB0301 		mla	r1, r1, r3, r0
 989 0114 91F86111 		ldrb	r1, [r1, #353]	@ zero_extendqisi2
 990 0118 02A8     		add	r0, sp, #8
 991 011a 0244     		add	r2, r2, r0
 992 011c 02F8081C 		strb	r1, [r2, #-8]
 993              	.L64:
 383:../Src/main.c ****             if( VL53L0XDevs[i].Present ){
 994              		.loc 1 383 0 discriminator 2
 995 0120 0133     		adds	r3, r3, #1
 996              	.LVL66:
 997 0122 00E0     		b	.L62
 998              	.LVL67:
 999              	.L67:
ARM GAS  /tmp/ccx8Hxdu.s 			page 42


 1000 0124 0023     		movs	r3, #0
 1001              	.LVL68:
 1002              	.L62:
 383:../Src/main.c ****             if( VL53L0XDevs[i].Present ){
 1003              		.loc 1 383 0 is_stmt 0 discriminator 1
 1004 0126 022B     		cmp	r3, #2
 1005 0128 E6DD     		ble	.L65
 388:../Src/main.c ****         XNUCLEO53L0A1_SetDisplayString(PresentMsg);
 1006              		.loc 1 388 0 is_stmt 1
 1007 012a 02A8     		add	r0, sp, #8
 1008 012c 2023     		movs	r3, #32
 1009              	.LVL69:
 1010 012e 00F8083D 		strb	r3, [r0, #-8]!
 389:../Src/main.c ****         HAL_Delay(1000);
 1011              		.loc 1 389 0
 1012 0132 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 1013              	.LVL70:
 390:../Src/main.c ****     }
 1014              		.loc 1 390 0
 1015 0136 4FF47A70 		mov	r0, #1000
 1016 013a FFF7FEFF 		bl	HAL_Delay
 1017              	.LVL71:
 1018              	.L63:
 394:../Src/main.c **** 
 1019              		.loc 1 394 0
 1020 013e 034B     		ldr	r3, .L69+4
 1021 0140 1868     		ldr	r0, [r3]
 1022 0142 02B0     		add	sp, sp, #8
 1023              	.LCFI23:
 1024              		.cfi_def_cfa_offset 24
 1025              		@ sp needed
 1026 0144 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1027              	.LVL72:
 1028              	.L70:
 1029              		.align	2
 1030              	.L69:
 1031 0148 10000000 		.word	.LC2
 1032 014c 00000000 		.word	.LANCHOR0
 1033 0150 00000000 		.word	.LANCHOR1
 1034 0154 00000000 		.word	nDevMask
 1035              		.cfi_endproc
 1036              	.LFE120:
 1038              		.section	.text.SetupSingleShot,"ax",%progbits
 1039              		.align	2
 1040              		.global	SetupSingleShot
 1041              		.thumb
 1042              		.thumb_func
 1044              	SetupSingleShot:
 1045              	.LFB121:
 399:../Src/main.c ****     int i;
 1046              		.loc 1 399 0
 1047              		.cfi_startproc
 1048              		@ args = 0, pretend = 0, frame = 16
 1049              		@ frame_needed = 0, uses_anonymous_args = 0
 1050              	.LVL73:
 1051 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1052              	.LCFI24:
ARM GAS  /tmp/ccx8Hxdu.s 			page 43


 1053              		.cfi_def_cfa_offset 36
 1054              		.cfi_offset 4, -36
 1055              		.cfi_offset 5, -32
 1056              		.cfi_offset 6, -28
 1057              		.cfi_offset 7, -24
 1058              		.cfi_offset 8, -20
 1059              		.cfi_offset 9, -16
 1060              		.cfi_offset 10, -12
 1061              		.cfi_offset 11, -8
 1062              		.cfi_offset 14, -4
 1063 0004 85B0     		sub	sp, sp, #20
 1064              	.LCFI25:
 1065              		.cfi_def_cfa_offset 56
 1066 0006 0646     		mov	r6, r0
 1067              	.LVL74:
 410:../Src/main.c **** 
 1068              		.loc 1 410 0
 1069 0008 4FF00A0B 		mov	fp, #10
 409:../Src/main.c **** 	uint8_t finalRangeVcselPeriod = 10;
 1070              		.loc 1 409 0
 1071 000c 4FF00E0A 		mov	r10, #14
 408:../Src/main.c **** 	uint8_t preRangeVcselPeriod = 14;
 1072              		.loc 1 408 0
 1073 0010 48F2E809 		movw	r9, #33000
 407:../Src/main.c **** 	uint32_t timingBudget = 33000;
 1074              		.loc 1 407 0
 1075 0014 4FF49018 		mov	r8, #1179648
 406:../Src/main.c **** 	FixPoint1616_t sigmaLimit = (FixPoint1616_t)(18*65536);
 1076              		.loc 1 406 0
 1077 0018 4FF48047 		mov	r7, #16384
 412:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 1078              		.loc 1 412 0
 1079 001c 0024     		movs	r4, #0
 1080 001e 77E0     		b	.L72
 1081              	.LVL75:
 1082              	.L78:
 413:../Src/main.c ****             status=VL53L0X_StaticInit(&VL53L0XDevs[i]);
 1083              		.loc 1 413 0
 1084 0020 4FF4C873 		mov	r3, #400
 1085 0024 3D4A     		ldr	r2, .L81
 1086 0026 03FB0423 		mla	r3, r3, r4, r2
 1087 002a D3F86831 		ldr	r3, [r3, #360]
 1088 002e 002B     		cmp	r3, #0
 1089 0030 6DD0     		beq	.L73
 414:../Src/main.c ****             if( status ){
 1090              		.loc 1 414 0
 1091 0032 4FF4C873 		mov	r3, #400
 1092 0036 03FB0425 		mla	r5, r3, r4, r2
 1093 003a 2846     		mov	r0, r5
 1094 003c FFF7FEFF 		bl	VL53L0X_StaticInit
 1095              	.LVL76:
 419:../Src/main.c **** 			if( status ){
 1096              		.loc 1 419 0
 1097 0040 0DF10E02 		add	r2, sp, #14
 1098 0044 0DF10F01 		add	r1, sp, #15
 1099 0048 2846     		mov	r0, r5
 1100 004a FFF7FEFF 		bl	VL53L0X_PerformRefCalibration
ARM GAS  /tmp/ccx8Hxdu.s 			page 44


 1101              	.LVL77:
 424:../Src/main.c **** 			if( status ){
 1102              		.loc 1 424 0
 1103 004e 0DF10702 		add	r2, sp, #7
 1104 0052 02A9     		add	r1, sp, #8
 1105 0054 2846     		mov	r0, r5
 1106 0056 FFF7FEFF 		bl	VL53L0X_PerformRefSpadManagement
 1107              	.LVL78:
 429:../Src/main.c ****             if( status ){
 1108              		.loc 1 429 0
 1109 005a 0021     		movs	r1, #0
 1110 005c 2846     		mov	r0, r5
 1111 005e FFF7FEFF 		bl	VL53L0X_SetDeviceMode
 1112              	.LVL79:
 434:../Src/main.c **** 			if( status ){
 1113              		.loc 1 434 0
 1114 0062 0122     		movs	r2, #1
 1115 0064 0021     		movs	r1, #0
 1116 0066 2846     		mov	r0, r5
 1117 0068 FFF7FEFF 		bl	VL53L0X_SetLimitCheckEnable
 1118              	.LVL80:
 439:../Src/main.c **** 			if( status ){
 1119              		.loc 1 439 0
 1120 006c 0122     		movs	r2, #1
 1121 006e 1146     		mov	r1, r2
 1122 0070 2846     		mov	r0, r5
 1123 0072 FFF7FEFF 		bl	VL53L0X_SetLimitCheckEnable
 1124              	.LVL81:
 444:../Src/main.c ****             case LONG_RANGE:
 1125              		.loc 1 444 0
 1126 0076 012E     		cmp	r6, #1
 1127 0078 0DD0     		beq	.L75
 1128 007a BEB1     		cbz	r6, .L79
 1129 007c 022E     		cmp	r6, #2
 1130 007e 1FD1     		bne	.L76
 1131              	.LVL82:
 457:../Src/main.c **** 				break;
 1132              		.loc 1 457 0
 1133 0080 4FF00A0B 		mov	fp, #10
 456:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 1134              		.loc 1 456 0
 1135 0084 4FF00E0A 		mov	r10, #14
 455:../Src/main.c **** 				preRangeVcselPeriod = 14; //laser pulse periods
 1136              		.loc 1 455 0
 1137 0088 DFF89490 		ldr	r9, .L81+4
 454:../Src/main.c **** 				timingBudget = 200000; //200ms
 1138              		.loc 1 454 0
 1139 008c 4FF49018 		mov	r8, #1179648
 453:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(18*65536);
 1140              		.loc 1 453 0
 1141 0090 4FF48047 		mov	r7, #16384
 458:../Src/main.c ****             case HIGH_SPEED:
 1142              		.loc 1 458 0
 1143 0094 14E0     		b	.L76
 1144              	.LVL83:
 1145              	.L75:
 464:../Src/main.c **** 				break;
ARM GAS  /tmp/ccx8Hxdu.s 			page 45


 1146              		.loc 1 464 0
 1147 0096 4FF00A0B 		mov	fp, #10
 463:../Src/main.c **** 				finalRangeVcselPeriod = 10;
 1148              		.loc 1 463 0
 1149 009a 4FF00E0A 		mov	r10, #14
 462:../Src/main.c **** 				preRangeVcselPeriod = 14;
 1150              		.loc 1 462 0
 1151 009e 44F62069 		movw	r9, #20000
 461:../Src/main.c **** 				timingBudget = 20000; //20ms
 1152              		.loc 1 461 0
 1153 00a2 4FF40018 		mov	r8, #2097152
 460:../Src/main.c **** 				sigmaLimit = (FixPoint1616_t)(32*65536);
 1154              		.loc 1 460 0
 1155 00a6 4FF48047 		mov	r7, #16384
 465:../Src/main.c ****             default:
 1156              		.loc 1 465 0
 1157 00aa 09E0     		b	.L76
 1158              	.LVL84:
 1159              	.L79:
 450:../Src/main.c ****             	break;
 1160              		.loc 1 450 0
 1161 00ac 4FF00E0B 		mov	fp, #14
 1162              	.LVL85:
 449:../Src/main.c ****             	finalRangeVcselPeriod = 14;
 1163              		.loc 1 449 0
 1164 00b0 4FF0120A 		mov	r10, #18
 1165              	.LVL86:
 448:../Src/main.c ****             	preRangeVcselPeriod = 18;
 1166              		.loc 1 448 0
 1167 00b4 48F2E809 		movw	r9, #33000
 1168              	.LVL87:
 447:../Src/main.c ****             	timingBudget = 33000; //33ms
 1169              		.loc 1 447 0
 1170 00b8 4FF47018 		mov	r8, #3932160
 1171              	.LVL88:
 446:../Src/main.c ****             	sigmaLimit = (FixPoint1616_t)(60*65536);
 1172              		.loc 1 446 0
 1173 00bc 41F69917 		movw	r7, #6553
 1174              	.LVL89:
 1175              	.L76:
 470:../Src/main.c **** 			if( status ){
 1176              		.loc 1 470 0
 1177 00c0 3A46     		mov	r2, r7
 1178 00c2 0121     		movs	r1, #1
 1179 00c4 2846     		mov	r0, r5
 1180 00c6 FFF7FEFF 		bl	VL53L0X_SetLimitCheckValue
 1181              	.LVL90:
 475:../Src/main.c **** 			if( status ){
 1182              		.loc 1 475 0
 1183 00ca 4246     		mov	r2, r8
 1184 00cc 0021     		movs	r1, #0
 1185 00ce 2846     		mov	r0, r5
 1186 00d0 FFF7FEFF 		bl	VL53L0X_SetLimitCheckValue
 1187              	.LVL91:
 480:../Src/main.c ****             if( status ){
 1188              		.loc 1 480 0
 1189 00d4 4946     		mov	r1, r9
ARM GAS  /tmp/ccx8Hxdu.s 			page 46


 1190 00d6 2846     		mov	r0, r5
 1191 00d8 FFF7FEFF 		bl	VL53L0X_SetMeasurementTimingBudgetMicroSeconds
 1192              	.LVL92:
 485:../Src/main.c **** 			if( status ){
 1193              		.loc 1 485 0
 1194 00dc 5246     		mov	r2, r10
 1195 00de 0021     		movs	r1, #0
 1196 00e0 2846     		mov	r0, r5
 1197 00e2 FFF7FEFF 		bl	VL53L0X_SetVcselPulsePeriod
 1198              	.LVL93:
 490:../Src/main.c **** 			if( status ){
 1199              		.loc 1 490 0
 1200 00e6 5A46     		mov	r2, fp
 1201 00e8 0121     		movs	r1, #1
 1202 00ea 2846     		mov	r0, r5
 1203 00ec FFF7FEFF 		bl	VL53L0X_SetVcselPulsePeriod
 1204              	.LVL94:
 495:../Src/main.c **** 			if( status ){
 1205              		.loc 1 495 0
 1206 00f0 0DF10E02 		add	r2, sp, #14
 1207 00f4 0DF10F01 		add	r1, sp, #15
 1208 00f8 2846     		mov	r0, r5
 1209 00fa FFF7FEFF 		bl	VL53L0X_PerformRefCalibration
 1210              	.LVL95:
 500:../Src/main.c ****         }
 1211              		.loc 1 500 0
 1212 00fe 4FF4C873 		mov	r3, #400
 1213 0102 064A     		ldr	r2, .L81
 1214 0104 03FB0423 		mla	r3, r3, r4, r2
 1215 0108 0122     		movs	r2, #1
 1216 010a C3F87C21 		str	r2, [r3, #380]
 1217              	.L73:
 412:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 1218              		.loc 1 412 0 discriminator 2
 1219 010e 0134     		adds	r4, r4, #1
 1220              	.LVL96:
 1221              	.L72:
 412:../Src/main.c ****         if( VL53L0XDevs[i].Present){
 1222              		.loc 1 412 0 is_stmt 0 discriminator 1
 1223 0110 022C     		cmp	r4, #2
 1224 0112 85DD     		ble	.L78
 503:../Src/main.c **** 
 1225              		.loc 1 503 0 is_stmt 1
 1226 0114 05B0     		add	sp, sp, #20
 1227              	.LCFI26:
 1228              		.cfi_def_cfa_offset 36
 1229              		@ sp needed
 1230 0116 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1231              	.LVL97:
 1232              	.L82:
 1233 011a 00BF     		.align	2
 1234              	.L81:
 1235 011c 00000000 		.word	.LANCHOR1
 1236 0120 400D0300 		.word	200000
 1237              		.cfi_endproc
 1238              	.LFE121:
 1240              		.section	.text.RangeToLetter,"ax",%progbits
ARM GAS  /tmp/ccx8Hxdu.s 			page 47


 1241              		.align	2
 1242              		.global	RangeToLetter
 1243              		.thumb
 1244              		.thumb_func
 1246              	RangeToLetter:
 1247              	.LFB122:
 505:../Src/main.c ****     char c;
 1248              		.loc 1 505 0
 1249              		.cfi_startproc
 1250              		@ args = 0, pretend = 0, frame = 0
 1251              		@ frame_needed = 0, uses_anonymous_args = 0
 1252              		@ link register save eliminated.
 1253              	.LVL98:
 507:../Src/main.c ****         if( pDev->LeakyRange < RangeLow ){
 1254              		.loc 1 507 0
 1255 0000 0B7E     		ldrb	r3, [r1, #24]	@ zero_extendqisi2
 1256 0002 5BB9     		cbnz	r3, .L85
 508:../Src/main.c ****             c='_';
 1257              		.loc 1 508 0
 1258 0004 D0F87831 		ldr	r3, [r0, #376]
 1259 0008 074A     		ldr	r2, .L88
 1260 000a 1268     		ldr	r2, [r2]
 1261 000c 9342     		cmp	r3, r2
 1262 000e 07DB     		blt	.L86
 511:../Src/main.c ****                 c='=';
 1263              		.loc 1 511 0
 1264 0010 064A     		ldr	r2, .L88+4
 1265 0012 1268     		ldr	r2, [r2]
 1266 0014 9342     		cmp	r3, r2
 1267 0016 05DA     		bge	.L87
 512:../Src/main.c ****         }
 1268              		.loc 1 512 0
 1269 0018 3D20     		movs	r0, #61
 1270              	.LVL99:
 1271 001a 7047     		bx	lr
 1272              	.LVL100:
 1273              	.L85:
 520:../Src/main.c ****     }
 1274              		.loc 1 520 0
 1275 001c 2D20     		movs	r0, #45
 1276              	.LVL101:
 1277 001e 7047     		bx	lr
 1278              	.LVL102:
 1279              	.L86:
 509:../Src/main.c ****         }
 1280              		.loc 1 509 0
 1281 0020 5F20     		movs	r0, #95
 1282              	.LVL103:
 1283 0022 7047     		bx	lr
 1284              	.LVL104:
 1285              	.L87:
 515:../Src/main.c ****         }
 1286              		.loc 1 515 0
 1287 0024 7E20     		movs	r0, #126
 1288              	.LVL105:
 523:../Src/main.c **** 
 1289              		.loc 1 523 0
ARM GAS  /tmp/ccx8Hxdu.s 			page 48


 1290 0026 7047     		bx	lr
 1291              	.L89:
 1292              		.align	2
 1293              	.L88:
 1294 0028 00000000 		.word	.LANCHOR2
 1295 002c 00000000 		.word	.LANCHOR3
 1296              		.cfi_endproc
 1297              	.LFE122:
 1299              		.section	.text.Sensor_SetNewRange,"ax",%progbits
 1300              		.align	2
 1301              		.global	Sensor_SetNewRange
 1302              		.thumb
 1303              		.thumb_func
 1305              	Sensor_SetNewRange:
 1306              	.LFB123:
 526:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 1307              		.loc 1 526 0
 1308              		.cfi_startproc
 1309              		@ args = 0, pretend = 0, frame = 0
 1310              		@ frame_needed = 0, uses_anonymous_args = 0
 1311              		@ link register save eliminated.
 1312              	.LVL106:
 527:../Src/main.c ****         if( pDev->LeakyFirst ){
 1313              		.loc 1 527 0
 1314 0000 0B7E     		ldrb	r3, [r1, #24]	@ zero_extendqisi2
 1315 0002 CBB9     		cbnz	r3, .L91
 528:../Src/main.c ****             pDev->LeakyFirst = 0;
 1316              		.loc 1 528 0
 1317 0004 D0F87C31 		ldr	r3, [r0, #380]
 1318 0008 33B1     		cbz	r3, .L92
 529:../Src/main.c ****             pDev->LeakyRange = pRange->RangeMilliMeter;
 1319              		.loc 1 529 0
 1320 000a 0023     		movs	r3, #0
 1321 000c C0F87C31 		str	r3, [r0, #380]
 530:../Src/main.c ****         }
 1322              		.loc 1 530 0
 1323 0010 0B89     		ldrh	r3, [r1, #8]
 1324 0012 C0F87831 		str	r3, [r0, #376]
 1325 0016 7047     		bx	lr
 1326              	.L92:
 526:../Src/main.c ****     if( pRange->RangeStatus == 0 ){
 1327              		.loc 1 526 0
 1328 0018 10B4     		push	{r4}
 1329              	.LCFI27:
 1330              		.cfi_def_cfa_offset 4
 1331              		.cfi_offset 4, -4
 533:../Src/main.c ****         }
 1332              		.loc 1 533 0
 1333 001a D0F87831 		ldr	r3, [r0, #376]
 1334 001e 0A4A     		ldr	r2, .L96
 1335 0020 1468     		ldr	r4, [r2]
 1336 0022 C4F58072 		rsb	r2, r4, #256
 1337 0026 0989     		ldrh	r1, [r1, #8]
 1338              	.LVL107:
 1339 0028 02FB01F2 		mul	r2, r2, r1
 1340 002c 04FB0323 		mla	r3, r4, r3, r2
 1341 0030 1B12     		asrs	r3, r3, #8
ARM GAS  /tmp/ccx8Hxdu.s 			page 49


 1342 0032 C0F87831 		str	r3, [r0, #376]
 1343 0036 03E0     		b	.L90
 1344              	.LVL108:
 1345              	.L91:
 1346              	.LCFI28:
 1347              		.cfi_def_cfa_offset 0
 1348              		.cfi_restore 4
 537:../Src/main.c ****     }
 1349              		.loc 1 537 0
 1350 0038 0123     		movs	r3, #1
 1351 003a C0F87C31 		str	r3, [r0, #380]
 539:../Src/main.c **** 
 1352              		.loc 1 539 0
 1353 003e 7047     		bx	lr
 1354              	.LVL109:
 1355              	.L90:
 1356              	.LCFI29:
 1357              		.cfi_def_cfa_offset 4
 1358              		.cfi_offset 4, -4
 1359 0040 5DF8044B 		ldr	r4, [sp], #4
 1360              	.LCFI30:
 1361              		.cfi_restore 4
 1362              		.cfi_def_cfa_offset 0
 1363 0044 7047     		bx	lr
 1364              	.L97:
 1365 0046 00BF     		.align	2
 1366              	.L96:
 1367 0048 00000000 		.word	.LANCHOR4
 1368              		.cfi_endproc
 1369              	.LFE123:
 1371              		.section	.text.blink_led,"ax",%progbits
 1372              		.align	2
 1373              		.global	blink_led
 1374              		.thumb
 1375              		.thumb_func
 1377              	blink_led:
 1378              	.LFB124:
 541:../Src/main.c ****     if (*compteur == 6){                       /////modification toutes les 6 mesures correctes du 
 1379              		.loc 1 541 0
 1380              		.cfi_startproc
 1381              		@ args = 0, pretend = 0, frame = 0
 1382              		@ frame_needed = 0, uses_anonymous_args = 0
 1383              	.LVL110:
 542:../Src/main.c ****         HAL_TIM_Base_Stop_IT(&htim3);
 1384              		.loc 1 542 0
 1385 0000 0B68     		ldr	r3, [r1]
 1386 0002 062B     		cmp	r3, #6
 1387 0004 12D1     		bne	.L101
 541:../Src/main.c ****     if (*compteur == 6){                       /////modification toutes les 6 mesures correctes du 
 1388              		.loc 1 541 0
 1389 0006 70B5     		push	{r4, r5, r6, lr}
 1390              	.LCFI31:
 1391              		.cfi_def_cfa_offset 16
 1392              		.cfi_offset 4, -16
 1393              		.cfi_offset 5, -12
 1394              		.cfi_offset 6, -8
 1395              		.cfi_offset 14, -4
ARM GAS  /tmp/ccx8Hxdu.s 			page 50


 1396 0008 0D46     		mov	r5, r1
 1397 000a 0446     		mov	r4, r0
 543:../Src/main.c ****         htim3.Instance->ARR = 2*valeur-1+20;   /////modification de la periode du capteur (voir wik
 1398              		.loc 1 543 0
 1399 000c 084E     		ldr	r6, .L102
 1400 000e 3046     		mov	r0, r6
 1401              	.LVL111:
 1402 0010 FFF7FEFF 		bl	HAL_TIM_Base_Stop_IT
 1403              	.LVL112:
 544:../Src/main.c ****         HAL_TIM_Base_Start_IT(&htim3);
 1404              		.loc 1 544 0
 1405 0014 3368     		ldr	r3, [r6]
 1406 0016 6000     		lsls	r0, r4, #1
 1407 0018 1330     		adds	r0, r0, #19
 1408 001a D862     		str	r0, [r3, #44]
 545:../Src/main.c ****         htim3.Instance->CNT = 0;               /////remise a zero du timer de la led
 1409              		.loc 1 545 0
 1410 001c 3046     		mov	r0, r6
 1411 001e FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1412              	.LVL113:
 546:../Src/main.c ****         *compteur = 0;                         /////remise a zero du compteur
 1413              		.loc 1 546 0
 1414 0022 3268     		ldr	r2, [r6]
 1415 0024 0023     		movs	r3, #0
 1416 0026 5362     		str	r3, [r2, #36]
 547:../Src/main.c ****     }
 1417              		.loc 1 547 0
 1418 0028 2B60     		str	r3, [r5]
 1419 002a 70BD     		pop	{r4, r5, r6, pc}
 1420              	.LVL114:
 1421              	.L101:
 1422              	.LCFI32:
 1423              		.cfi_def_cfa_offset 0
 1424              		.cfi_restore 4
 1425              		.cfi_restore 5
 1426              		.cfi_restore 6
 1427              		.cfi_restore 14
 1428 002c 7047     		bx	lr
 1429              	.L103:
 1430 002e 00BF     		.align	2
 1431              	.L102:
 1432 0030 00000000 		.word	htim3
 1433              		.cfi_endproc
 1434              	.LFE124:
 1436              		.section	.text.Variation2Angle_maison,"ax",%progbits
 1437              		.align	2
 1438              		.global	Variation2Angle_maison
 1439              		.thumb
 1440              		.thumb_func
 1442              	Variation2Angle_maison:
 1443              	.LFB125:
 585:../Src/main.c **** 		uint16_t position;
 1444              		.loc 1 585 0
 1445              		.cfi_startproc
 1446              		@ args = 0, pretend = 0, frame = 8
 1447              		@ frame_needed = 0, uses_anonymous_args = 0
 1448              	.LVL115:
ARM GAS  /tmp/ccx8Hxdu.s 			page 51


 1449 0000 10B5     		push	{r4, lr}
 1450              	.LCFI33:
 1451              		.cfi_def_cfa_offset 8
 1452              		.cfi_offset 4, -8
 1453              		.cfi_offset 14, -4
 1454 0002 82B0     		sub	sp, sp, #8
 1455              	.LCFI34:
 1456              		.cfi_def_cfa_offset 16
 1457 0004 02AB     		add	r3, sp, #8
 1458 0006 03E90300 		stmdb	r3, {r0, r1}
 1459 000a 1446     		mov	r4, r2
 589:../Src/main.c **** 				XL_Set_Goal_Position(&servo, *ptr_angle, 1);
 1460              		.loc 1 589 0
 1461 000c 1168     		ldr	r1, [r2]
 1462 000e B1F57A7F 		cmp	r1, #1000
 1463 0012 08D2     		bcs	.L105
 590:../Src/main.c **** 				*ptr_angle+=5;
 1464              		.loc 1 590 0
 1465 0014 0122     		movs	r2, #1
 1466              	.LVL116:
 1467 0016 89B2     		uxth	r1, r1
 1468 0018 6846     		mov	r0, sp
 1469 001a FFF7FEFF 		bl	XL_Set_Goal_Position
 1470              	.LVL117:
 591:../Src/main.c **** 		} else {
 1471              		.loc 1 591 0
 1472 001e 2368     		ldr	r3, [r4]
 1473 0020 0533     		adds	r3, r3, #5
 1474 0022 2360     		str	r3, [r4]
 1475 0024 05E0     		b	.L104
 1476              	.LVL118:
 1477              	.L105:
 593:../Src/main.c **** 				XL_Set_Goal_Position(&servo, *ptr_angle, 1);
 1478              		.loc 1 593 0
 1479 0026 3221     		movs	r1, #50
 1480 0028 1160     		str	r1, [r2]
 594:../Src/main.c **** 		}
 1481              		.loc 1 594 0
 1482 002a 0122     		movs	r2, #1
 1483              	.LVL119:
 1484 002c 6846     		mov	r0, sp
 1485 002e FFF7FEFF 		bl	XL_Set_Goal_Position
 1486              	.LVL120:
 1487              	.L104:
 602:../Src/main.c **** 
 1488              		.loc 1 602 0
 1489 0032 02B0     		add	sp, sp, #8
 1490              	.LCFI35:
 1491              		.cfi_def_cfa_offset 8
 1492              		@ sp needed
 1493 0034 10BD     		pop	{r4, pc}
 1494              		.cfi_endproc
 1495              	.LFE125:
 1497 0036 00BF     		.section	.text.Variation3Angle_maison,"ax",%progbits
 1498              		.align	2
 1499              		.global	Variation3Angle_maison
 1500              		.thumb
ARM GAS  /tmp/ccx8Hxdu.s 			page 52


 1501              		.thumb_func
 1503              	Variation3Angle_maison:
 1504              	.LFB126:
 604:../Src/main.c **** 		uint16_t position;
 1505              		.loc 1 604 0
 1506              		.cfi_startproc
 1507              		@ args = 4, pretend = 0, frame = 24
 1508              		@ frame_needed = 0, uses_anonymous_args = 0
 1509              	.LVL121:
 1510 0000 70B5     		push	{r4, r5, r6, lr}
 1511              	.LCFI36:
 1512              		.cfi_def_cfa_offset 16
 1513              		.cfi_offset 4, -16
 1514              		.cfi_offset 5, -12
 1515              		.cfi_offset 6, -8
 1516              		.cfi_offset 14, -4
 1517 0002 86B0     		sub	sp, sp, #24
 1518              	.LCFI37:
 1519              		.cfi_def_cfa_offset 40
 1520 0004 8DE80300 		stmia	sp, {r0, r1}
 1521 0008 1446     		mov	r4, r2
 1522 000a 1E46     		mov	r6, r3
 1523 000c 0A9D     		ldr	r5, [sp, #40]
 609:../Src/main.c **** 				XL_Set_Goal_Position(&servo, *ptr_angle, 1);
 1524              		.loc 1 609 0
 1525 000e 1168     		ldr	r1, [r2]
 1526 0010 B1F57A7F 		cmp	r1, #1000
 1527 0014 08D2     		bcs	.L109
 610:../Src/main.c **** 				*ptr_angle+=5;
 1528              		.loc 1 610 0
 1529 0016 0122     		movs	r2, #1
 1530              	.LVL122:
 1531 0018 89B2     		uxth	r1, r1
 1532 001a 6846     		mov	r0, sp
 1533 001c FFF7FEFF 		bl	XL_Set_Goal_Position
 1534              	.LVL123:
 611:../Src/main.c **** 		} else {
 1535              		.loc 1 611 0
 1536 0020 2368     		ldr	r3, [r4]
 1537 0022 0533     		adds	r3, r3, #5
 1538 0024 2360     		str	r3, [r4]
 1539 0026 05E0     		b	.L110
 1540              	.LVL124:
 1541              	.L109:
 613:../Src/main.c **** 				XL_Set_Goal_Position(&servo, *ptr_angle, 1);
 1542              		.loc 1 613 0
 1543 0028 3221     		movs	r1, #50
 1544 002a 1160     		str	r1, [r2]
 614:../Src/main.c **** 		}
 1545              		.loc 1 614 0
 1546 002c 0122     		movs	r2, #1
 1547              	.LVL125:
 1548 002e 6846     		mov	r0, sp
 1549 0030 FFF7FEFF 		bl	XL_Set_Goal_Position
 1550              	.LVL126:
 1551              	.L110:
 616:../Src/main.c **** 		/*HAL_Delay(1000);
ARM GAS  /tmp/ccx8Hxdu.s 			page 53


 1552              		.loc 1 616 0
 1553 0034 0122     		movs	r2, #1
 1554 0036 2188     		ldrh	r1, [r4]
 1555 0038 6846     		mov	r0, sp
 1556 003a FFF7FEFF 		bl	XL_Set_Goal_Position
 1557              	.LVL127:
 622:../Src/main.c **** 		XL_Get_Current_Position(&servo, &position);
 1558              		.loc 1 622 0
 1559 003e 0A20     		movs	r0, #10
 1560 0040 FFF7FEFF 		bl	HAL_Delay
 1561              	.LVL128:
 623:../Src/main.c **** 		HAL_Delay(Delay2);
 1562              		.loc 1 623 0
 1563 0044 0DF11601 		add	r1, sp, #22
 1564 0048 6846     		mov	r0, sp
 1565 004a FFF7FEFF 		bl	XL_Get_Current_Position
 1566              	.LVL129:
 624:../Src/main.c ****     if (*i<Maxi_char_transmit-1){                 /////ajout valeur, dans data
 1567              		.loc 1 624 0
 1568 004e 0A20     		movs	r0, #10
 1569 0050 FFF7FEFF 		bl	HAL_Delay
 1570              	.LVL130:
 625:../Src/main.c ****         sprintf(dataAngle, "%d,",position);
 1571              		.loc 1 625 0
 1572 0054 2B68     		ldr	r3, [r5]
 1573 0056 082B     		cmp	r3, #8
 1574 0058 06DC     		bgt	.L111
 626:../Src/main.c **** 				/*len=strlen(dataAngle);
 1575              		.loc 1 626 0
 1576 005a BDF81620 		ldrh	r2, [sp, #22]
 1577 005e 1A49     		ldr	r1, .L115
 1578 0060 03A8     		add	r0, sp, #12
 1579 0062 FFF7FEFF 		bl	sprintf
 1580              	.LVL131:
 1581 0066 07E0     		b	.L112
 1582              	.L111:
 629:../Src/main.c ****         sprintf(dataAngle, "%d",position);
 1583              		.loc 1 629 0
 1584 0068 092B     		cmp	r3, #9
 1585 006a 05D1     		bne	.L112
 630:../Src/main.c **** 				/*len=strlen(dataAngle);
 1586              		.loc 1 630 0
 1587 006c BDF81620 		ldrh	r2, [sp, #22]
 1588 0070 1649     		ldr	r1, .L115+4
 1589 0072 03A8     		add	r0, sp, #12
 1590 0074 FFF7FEFF 		bl	sprintf
 1591              	.LVL132:
 1592              	.L112:
 634:../Src/main.c ****     if (*i==Maxi_char_transmit-1){
 1593              		.loc 1 634 0
 1594 0078 03A9     		add	r1, sp, #12
 1595 007a 3046     		mov	r0, r6
 1596 007c FFF7FEFF 		bl	strcat
 1597              	.LVL133:
 635:../Src/main.c ****         len=strlen(buffer);                       /////longueur du buffer
 1598              		.loc 1 635 0
 1599 0080 2B68     		ldr	r3, [r5]
ARM GAS  /tmp/ccx8Hxdu.s 			page 54


 1600 0082 092B     		cmp	r3, #9
 1601 0084 1DD1     		bne	.L108
 636:../Src/main.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)(buffer), len, 1000); /////transmission du buffer
 1602              		.loc 1 636 0
 1603 0086 3046     		mov	r0, r6
 1604 0088 FFF7FEFF 		bl	strlen
 1605              	.LVL134:
 637:../Src/main.c ****         sprintf(ligne, "\n");                                     /////ajout \n a ligne
 1606              		.loc 1 637 0
 1607 008c 104C     		ldr	r4, .L115+8
 1608              	.LVL135:
 1609 008e 4FF47A73 		mov	r3, #1000
 1610 0092 82B2     		uxth	r2, r0
 1611 0094 3146     		mov	r1, r6
 1612 0096 2046     		mov	r0, r4
 1613              	.LVL136:
 1614 0098 FFF7FEFF 		bl	HAL_UART_Transmit
 1615              	.LVL137:
 638:../Src/main.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)ligne, 1, 1000);     /////transmission pour cloturer l
 1616              		.loc 1 638 0
 1617 009c 06A9     		add	r1, sp, #24
 1618 009e 0A23     		movs	r3, #10
 1619 00a0 21F8103D 		strh	r3, [r1, #-16]!	@ movhi
 639:../Src/main.c ****         (*i)=-1;                                                  /////remise a zero du compteur
 1620              		.loc 1 639 0
 1621 00a4 4FF47A73 		mov	r3, #1000
 1622 00a8 0122     		movs	r2, #1
 1623 00aa 2046     		mov	r0, r4
 1624 00ac FFF7FEFF 		bl	HAL_UART_Transmit
 1625              	.LVL138:
 640:../Src/main.c ****         sprintf(buffer, "");                                      /////remise a zero du buffer
 1626              		.loc 1 640 0
 1627 00b0 4FF0FF33 		mov	r3, #-1
 1628 00b4 2B60     		str	r3, [r5]
 641:../Src/main.c ****         HAL_Delay(Delay);         //////necessaire pour le graphique
 1629              		.loc 1 641 0
 1630 00b6 0023     		movs	r3, #0
 1631 00b8 3370     		strb	r3, [r6]
 642:../Src/main.c ****     }
 1632              		.loc 1 642 0
 1633 00ba 4FF47A70 		mov	r0, #1000
 1634 00be FFF7FEFF 		bl	HAL_Delay
 1635              	.LVL139:
 1636              	.L108:
 644:../Src/main.c **** 
 1637              		.loc 1 644 0
 1638 00c2 06B0     		add	sp, sp, #24
 1639              	.LCFI38:
 1640              		.cfi_def_cfa_offset 16
 1641              		@ sp needed
 1642 00c4 70BD     		pop	{r4, r5, r6, pc}
 1643              	.LVL140:
 1644              	.L116:
 1645 00c6 00BF     		.align	2
 1646              	.L115:
 1647 00c8 18000000 		.word	.LC3
 1648 00cc 1C000000 		.word	.LC4
ARM GAS  /tmp/ccx8Hxdu.s 			page 55


 1649 00d0 00000000 		.word	huart2
 1650              		.cfi_endproc
 1651              	.LFE126:
 1653              		.section	.text.RangeDemo,"ax",%progbits
 1654              		.align	2
 1655              		.global	RangeDemo
 1656              		.thumb
 1657              		.thumb_func
 1659              	RangeDemo:
 1660              	.LFB127:
 670:../Src/main.c ****     int over=0;
 1661              		.loc 1 670 0
 1662              		.cfi_startproc
 1663              		@ args = 0, pretend = 0, frame = 80
 1664              		@ frame_needed = 0, uses_anonymous_args = 0
 1665              	.LVL141:
 1666 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 1667              	.LCFI39:
 1668              		.cfi_def_cfa_offset 28
 1669              		.cfi_offset 4, -28
 1670              		.cfi_offset 5, -24
 1671              		.cfi_offset 6, -20
 1672              		.cfi_offset 7, -16
 1673              		.cfi_offset 8, -12
 1674              		.cfi_offset 9, -8
 1675              		.cfi_offset 14, -4
 1676 0004 97B0     		sub	sp, sp, #92
 1677              	.LCFI40:
 1678              		.cfi_def_cfa_offset 120
 1679 0006 0546     		mov	r5, r0
 1680 0008 02A8     		add	r0, sp, #8
 1681              	.LVL142:
 1682 000a 80E80C00 		stmia	r0, {r2, r3}
 1683              	.LVL143:
 680:../Src/main.c ****     int* ptr_compteur_blink = NULL;   ///creation pointeur sur compteur
 1684              		.loc 1 680 0
 1685 000e 0024     		movs	r4, #0
 1686 0010 1394     		str	r4, [sp, #76]
 1687              	.LVL144:
 683:../Src/main.c ****     int* ptr_compteur = NULL;   ///creation pointeur sur compteur
 1688              		.loc 1 683 0
 1689 0012 1294     		str	r4, [sp, #72]
 1690              	.LVL145:
 690:../Src/main.c **** 		int angle=10;              ////creation
 1691              		.loc 1 690 0
 1692 0014 8DF81440 		strb	r4, [sp, #20]
 691:../Src/main.c **** 	  int* ptr_angle = &angle;
 1693              		.loc 1 691 0
 1694 0018 0A23     		movs	r3, #10
 1695 001a 0493     		str	r3, [sp, #16]
 1696              	.LVL146:
 695:../Src/main.c **** 
 1697              		.loc 1 695 0
 1698 001c 0846     		mov	r0, r1
 1699 001e FFF7FEFF 		bl	SetupSingleShot
 1700              	.LVL147:
 677:../Src/main.c ****     int distance;     ///creation variable distance
ARM GAS  /tmp/ccx8Hxdu.s 			page 56


 1701              		.loc 1 677 0
 1702 0022 2746     		mov	r7, r4
 699:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 1703              		.loc 1 699 0
 1704 0024 2646     		mov	r6, r4
 1705 0026 2346     		mov	r3, r4
 1706 0028 11E0     		b	.L118
 1707              	.LVL148:
 1708              	.L120:
 700:../Src/main.c ****             nSensorToUse++;
 1709              		.loc 1 700 0
 1710 002a 45FA03F2 		asr	r2, r5, r3
 1711 002e 12F0010F 		tst	r2, #1
 1712 0032 0BD0     		beq	.L119
 700:../Src/main.c ****             nSensorToUse++;
 1713              		.loc 1 700 0 is_stmt 0 discriminator 1
 1714 0034 4FF4C872 		mov	r2, #400
 1715 0038 5349     		ldr	r1, .L134
 1716 003a 02FB0312 		mla	r2, r2, r3, r1
 1717 003e D2F86821 		ldr	r2, [r2, #360]
 1718 0042 1AB1     		cbz	r2, .L119
 701:../Src/main.c ****             if( nSensorToUse==1 )
 1719              		.loc 1 701 0 is_stmt 1
 1720 0044 0136     		adds	r6, r6, #1
 1721              	.LVL149:
 702:../Src/main.c ****                 SingleSensorNo=i;
 1722              		.loc 1 702 0
 1723 0046 012E     		cmp	r6, #1
 1724 0048 00D1     		bne	.L119
 703:../Src/main.c ****         }
 1725              		.loc 1 703 0
 1726 004a 1F46     		mov	r7, r3
 1727              	.LVL150:
 1728              	.L119:
 699:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 1729              		.loc 1 699 0 discriminator 2
 1730 004c 0133     		adds	r3, r3, #1
 1731              	.LVL151:
 1732              	.L118:
 699:../Src/main.c ****         if(( UseSensorsMask& (1<<i) ) && VL53L0XDevs[i].Present ){
 1733              		.loc 1 699 0 is_stmt 0 discriminator 1
 1734 004e 022B     		cmp	r3, #2
 1735 0050 EBDD     		ble	.L120
 706:../Src/main.c ****         return -1;
 1736              		.loc 1 706 0 is_stmt 1
 1737 0052 002E     		cmp	r6, #0
 1738 0054 00F09280 		beq	.L132
 1739              	.LVL152:
 1740              	.L130:
 713:../Src/main.c ****         	/* Multiple devices */
 1741              		.loc 1 713 0
 1742 0058 012E     		cmp	r6, #1
 1743 005a 33DD     		ble	.L122
 715:../Src/main.c ****             for( i=0; i<3; i++){
 1744              		.loc 1 715 0
 1745 005c 4B4B     		ldr	r3, .L134+4
 1746 005e 93E80300 		ldmia	r3, {r0, r1}
ARM GAS  /tmp/ccx8Hxdu.s 			page 57


 1747 0062 1490     		str	r0, [sp, #80]
 1748 0064 8DF85410 		strb	r1, [sp, #84]
 1749              	.LVL153:
 716:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 1750              		.loc 1 716 0
 1751 0068 0024     		movs	r4, #0
 1752 006a 28E0     		b	.L123
 1753              	.LVL154:
 1754              	.L126:
 717:../Src/main.c ****                     continue;
 1755              		.loc 1 717 0
 1756 006c 4FF4C873 		mov	r3, #400
 1757 0070 454A     		ldr	r2, .L134
 1758 0072 03FB0423 		mla	r3, r3, r4, r2
 1759 0076 D3F86831 		ldr	r3, [r3, #360]
 1760 007a FBB1     		cbz	r3, .L124
 717:../Src/main.c ****                     continue;
 1761              		.loc 1 717 0 is_stmt 0 discriminator 1
 1762 007c 45FA04F3 		asr	r3, r5, r4
 1763 0080 13F0010F 		tst	r3, #1
 1764 0084 1AD0     		beq	.L124
 720:../Src/main.c ****                 if( status ){
 1765              		.loc 1 720 0 is_stmt 1
 1766 0086 4FF4C873 		mov	r3, #400
 1767 008a 03FB0428 		mla	r8, r3, r4, r2
 1768 008e 4049     		ldr	r1, .L134+8
 1769 0090 4046     		mov	r0, r8
 1770 0092 FFF7FEFF 		bl	VL53L0X_PerformSingleRangingMeasurement
 1771              	.LVL155:
 721:../Src/main.c ****                     HandleError(ERR_DEMO_RANGE_MULTI);
 1772              		.loc 1 721 0
 1773 0096 10B1     		cbz	r0, .L125
 722:../Src/main.c ****                 }
 1774              		.loc 1 722 0
 1775 0098 0220     		movs	r0, #2
 1776              	.LVL156:
 1777 009a FFF7FEFF 		bl	HandleError
 1778              	.LVL157:
 1779              	.L125:
 727:../Src/main.c ****                 /* Translate distance in bar graph (multiple device) */
 1780              		.loc 1 727 0
 1781 009e DFF8F090 		ldr	r9, .L134+8
 1782 00a2 4946     		mov	r1, r9
 1783 00a4 4046     		mov	r0, r8
 1784              	.LVL158:
 1785 00a6 FFF7FEFF 		bl	Sensor_SetNewRange
 1786              	.LVL159:
 729:../Src/main.c ****                 StrDisplay[i+1]=c;
 1787              		.loc 1 729 0
 1788 00aa 4946     		mov	r1, r9
 1789 00ac 4046     		mov	r0, r8
 1790 00ae FFF7FEFF 		bl	RangeToLetter
 1791              	.LVL160:
 730:../Src/main.c ****             }
 1792              		.loc 1 730 0
 1793 00b2 631C     		adds	r3, r4, #1
 1794 00b4 16AA     		add	r2, sp, #88
ARM GAS  /tmp/ccx8Hxdu.s 			page 58


 1795 00b6 1344     		add	r3, r3, r2
 1796 00b8 03F8080C 		strb	r0, [r3, #-8]
 1797              	.LVL161:
 1798              	.L124:
 716:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 1799              		.loc 1 716 0 discriminator 2
 1800 00bc 0134     		adds	r4, r4, #1
 1801              	.LVL162:
 1802              	.L123:
 716:../Src/main.c ****                 if( ! VL53L0XDevs[i].Present  || (UseSensorsMask & (1<<i))==0 )
 1803              		.loc 1 716 0 is_stmt 0 discriminator 1
 1804 00be 022C     		cmp	r4, #2
 1805 00c0 D4DD     		ble	.L126
 1806 00c2 4CE0     		b	.L127
 1807              	.LVL163:
 1808              	.L122:
 736:../Src/main.c ****             if( status ==0 ){
 1809              		.loc 1 736 0 is_stmt 1
 1810 00c4 4FF4C873 		mov	r3, #400
 1811 00c8 2F4C     		ldr	r4, .L134
 1812 00ca 03FB0744 		mla	r4, r3, r7, r4
 1813 00ce 3049     		ldr	r1, .L134+8
 1814 00d0 2046     		mov	r0, r4
 1815 00d2 FFF7FEFF 		bl	VL53L0X_PerformSingleRangingMeasurement
 1816              	.LVL164:
 737:../Src/main.c ****             	/* Push data logging to UART */
 1817              		.loc 1 737 0
 1818 00d6 0028     		cmp	r0, #0
 1819 00d8 3ED1     		bne	.L128
 740:../Src/main.c ****                 /* Display distance in cm */
 1820              		.loc 1 740 0
 1821 00da DFF8B480 		ldr	r8, .L134+8
 1822 00de 4146     		mov	r1, r8
 1823 00e0 2046     		mov	r0, r4
 1824              	.LVL165:
 1825 00e2 FFF7FEFF 		bl	Sensor_SetNewRange
 1826              	.LVL166:
 742:../Src/main.c ****                     *ptr_compteur_blink+=1;                      /////incrementation du compteur
 1827              		.loc 1 742 0
 1828 00e6 98F81830 		ldrb	r3, [r8, #24]	@ zero_extendqisi2
 1829 00ea 2BBB     		cbnz	r3, .L129
 743:../Src/main.c ****                     sprintf(StrDisplay, "%3dc",(int)VL53L0XDevs[SingleSensorNo].LeakyRange/10);  //
 1830              		.loc 1 743 0
 1831 00ec 139B     		ldr	r3, [sp, #76]
 1832 00ee 0133     		adds	r3, r3, #1
 1833 00f0 1393     		str	r3, [sp, #76]
 744:../Src/main.c ****                     distance = (int)VL53L0XDevs[SingleSensorNo].LeakyRange/10;   /////distance lue 
 1834              		.loc 1 744 0
 1835 00f2 A046     		mov	r8, r4
 1836 00f4 D4F87831 		ldr	r3, [r4, #376]
 1837 00f8 264C     		ldr	r4, .L134+12
 1838 00fa 84FB0312 		smull	r1, r2, r4, r3
 1839 00fe DB17     		asrs	r3, r3, #31
 1840 0100 C3EBA202 		rsb	r2, r3, r2, asr #2
 1841 0104 2449     		ldr	r1, .L134+16
 1842 0106 14A8     		add	r0, sp, #80
 1843 0108 FFF7FEFF 		bl	sprintf
ARM GAS  /tmp/ccx8Hxdu.s 			page 59


 1844              	.LVL167:
 745:../Src/main.c ****                     //XL_Get_Current_Position(servo, &angle); necessaire ?
 1845              		.loc 1 745 0
 1846 010c D8F87831 		ldr	r3, [r8, #376]
 1847 0110 84FB0320 		smull	r2, r0, r4, r3
 1848 0114 DB17     		asrs	r3, r3, #31
 1849              	.LVL168:
 747:../Src/main.c **** 										Variation3Angle_maison(servo, ptr_angle, buffer1, ptr_compteur);
 1850              		.loc 1 747 0
 1851 0116 13A9     		add	r1, sp, #76
 1852              	.LVL169:
 1853 0118 C3EBA000 		rsb	r0, r3, r0, asr #2
 1854              	.LVL170:
 1855 011c FFF7FEFF 		bl	blink_led
 1856              	.LVL171:
 748:../Src/main.c ****                     //transmit(compteur2, buffer, buffer1, distance, angle);        /////fonction t
 1857              		.loc 1 748 0
 1858 0120 12AB     		add	r3, sp, #72
 1859              	.LVL172:
 1860 0122 0093     		str	r3, [sp]
 1861 0124 05AB     		add	r3, sp, #20
 1862              	.LVL173:
 1863 0126 04AA     		add	r2, sp, #16
 1864              	.LVL174:
 1865 0128 02A9     		add	r1, sp, #8
 1866 012a 03C9     		ldmia	r1, {r0, r1}
 1867 012c FFF7FEFF 		bl	Variation3Angle_maison
 1868              	.LVL175:
 750:../Src/main.c **** 
 1869              		.loc 1 750 0
 1870 0130 129B     		ldr	r3, [sp, #72]
 1871 0132 0133     		adds	r3, r3, #1
 1872 0134 1293     		str	r3, [sp, #72]
 1873 0136 12E0     		b	.L127
 1874              	.L129:
 763:../Src/main.c ****                     StrDisplay[0]=VL53L0XDevs[SingleSensorNo].DevLetter;
 1875              		.loc 1 763 0
 1876 0138 184B     		ldr	r3, .L134+20
 1877 013a 93E80300 		ldmia	r3, {r0, r1}
 1878 013e 1490     		str	r0, [sp, #80]
 1879 0140 8DF85410 		strb	r1, [sp, #84]
 764:../Src/main.c ****                     //HAL_TIM_Base_Stop_IT(&htim3);             /////version courante : memoire de 
 1880              		.loc 1 764 0
 1881 0144 4FF4C873 		mov	r3, #400
 1882 0148 0F4A     		ldr	r2, .L134
 1883 014a 03FB0723 		mla	r3, r3, r7, r2
 1884 014e 93F86131 		ldrb	r3, [r3, #353]	@ zero_extendqisi2
 1885 0152 8DF85030 		strb	r3, [sp, #80]
 1886 0156 02E0     		b	.L127
 1887              	.LVL176:
 1888              	.L128:
 771:../Src/main.c ****             }
 1889              		.loc 1 771 0
 1890 0158 0120     		movs	r0, #1
 1891              	.LVL177:
 1892 015a FFF7FEFF 		bl	HandleError
 1893              	.LVL178:
ARM GAS  /tmp/ccx8Hxdu.s 			page 60


 1894              	.L127:
 774:../Src/main.c ****         /* Check blue button */
 1895              		.loc 1 774 0
 1896 015e 14A8     		add	r0, sp, #80
 1897 0160 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 1898              	.LVL179:
 776:../Src/main.c ****             over=1;
 1899              		.loc 1 776 0
 1900 0164 FFF7FEFF 		bl	BSP_GetPushButton
 1901              	.LVL180:
 1902 0168 0028     		cmp	r0, #0
 1903 016a 7FF475AF 		bne	.L130
 782:../Src/main.c ****     htim3.Instance->CNT=0;       /////remise a zero du timer de la led
 1904              		.loc 1 782 0
 1905 016e FFF7FEFF 		bl	PusbButton_WaitUnPress
 1906              	.LVL181:
 783:../Src/main.c ****     return status;
 1907              		.loc 1 783 0
 1908 0172 0B4B     		ldr	r3, .L134+24
 1909 0174 1B68     		ldr	r3, [r3]
 1910 0176 0022     		movs	r2, #0
 1911 0178 5A62     		str	r2, [r3, #36]
 784:../Src/main.c **** }
 1912              		.loc 1 784 0
 1913 017a 01E0     		b	.L121
 1914              	.LVL182:
 1915              	.L132:
 707:../Src/main.c ****     }
 1916              		.loc 1 707 0
 1917 017c 4FF0FF30 		mov	r0, #-1
 1918              	.LVL183:
 1919              	.L121:
 785:../Src/main.c **** 
 1920              		.loc 1 785 0
 1921 0180 17B0     		add	sp, sp, #92
 1922              	.LCFI41:
 1923              		.cfi_def_cfa_offset 28
 1924              		@ sp needed
 1925 0182 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 1926              	.LVL184:
 1927              	.L135:
 1928 0186 00BF     		.align	2
 1929              	.L134:
 1930 0188 00000000 		.word	.LANCHOR1
 1931 018c 10000000 		.word	.LC2
 1932 0190 00000000 		.word	RangingMeasurementData
 1933 0194 67666666 		.word	1717986919
 1934 0198 20000000 		.word	.LC5
 1935 019c 28000000 		.word	.LC6
 1936 01a0 00000000 		.word	htim3
 1937              		.cfi_endproc
 1938              	.LFE127:
 1940              		.section	.text.ResetAndDetectSensor,"ax",%progbits
 1941              		.align	2
 1942              		.global	ResetAndDetectSensor
 1943              		.thumb
 1944              		.thumb_func
ARM GAS  /tmp/ccx8Hxdu.s 			page 61


 1946              	ResetAndDetectSensor:
 1947              	.LFB128:
 913:../Src/main.c ****     int nSensor;
 1948              		.loc 1 913 0
 1949              		.cfi_startproc
 1950              		@ args = 0, pretend = 0, frame = 0
 1951              		@ frame_needed = 0, uses_anonymous_args = 0
 1952              	.LVL185:
 1953 0000 08B5     		push	{r3, lr}
 1954              	.LCFI42:
 1955              		.cfi_def_cfa_offset 8
 1956              		.cfi_offset 3, -8
 1957              		.cfi_offset 14, -4
 915:../Src/main.c ****     /* at least one sensor and if one it must be the built-in one  */
 1958              		.loc 1 915 0
 1959 0002 FFF7FEFF 		bl	DetectSensors
 1960              	.LVL186:
 917:../Src/main.c ****         HandleError(ERR_DETECT);
 1961              		.loc 1 917 0
 1962 0006 0028     		cmp	r0, #0
 1963 0008 05DD     		ble	.L137
 917:../Src/main.c ****         HandleError(ERR_DETECT);
 1964              		.loc 1 917 0 is_stmt 0 discriminator 1
 1965 000a 0128     		cmp	r0, #1
 1966 000c 07D1     		bne	.L136
 917:../Src/main.c ****         HandleError(ERR_DETECT);
 1967              		.loc 1 917 0 discriminator 2
 1968 000e 044B     		ldr	r3, .L140
 1969 0010 D3F8F832 		ldr	r3, [r3, #760]
 1970 0014 1BB9     		cbnz	r3, .L136
 1971              	.L137:
 918:../Src/main.c ****     }
 1972              		.loc 1 918 0 is_stmt 1
 1973 0016 4FF0FF30 		mov	r0, #-1
 1974              	.LVL187:
 1975 001a FFF7FEFF 		bl	HandleError
 1976              	.LVL188:
 1977              	.L136:
 1978 001e 08BD     		pop	{r3, pc}
 1979              	.L141:
 1980              		.align	2
 1981              	.L140:
 1982 0020 00000000 		.word	.LANCHOR1
 1983              		.cfi_endproc
 1984              	.LFE128:
 1986              		.section	.text.main,"ax",%progbits
 1987              		.align	2
 1988              		.global	main
 1989              		.thumb
 1990              		.thumb_func
 1992              	main:
 1993              	.LFB129:
 925:../Src/main.c **** 
 1994              		.loc 1 925 0
 1995              		.cfi_startproc
 1996              		@ args = 0, pretend = 0, frame = 120
 1997              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccx8Hxdu.s 			page 62


 1998 0000 70B5     		push	{r4, r5, r6, lr}
 1999              	.LCFI43:
 2000              		.cfi_def_cfa_offset 16
 2001              		.cfi_offset 4, -16
 2002              		.cfi_offset 5, -12
 2003              		.cfi_offset 6, -8
 2004              		.cfi_offset 14, -4
 2005 0002 9EB0     		sub	sp, sp, #120
 2006              	.LCFI44:
 2007              		.cfi_def_cfa_offset 136
 2008              	.LVL189:
 937:../Src/main.c **** 
 2009              		.loc 1 937 0
 2010 0004 FFF7FEFF 		bl	HAL_Init
 2011              	.LVL190:
 940:../Src/main.c **** 
 2012              		.loc 1 940 0
 2013 0008 FFF7FEFF 		bl	SystemClock_Config
 2014              	.LVL191:
 943:../Src/main.c ****   SystemClock_Config();
 2015              		.loc 1 943 0
 2016 000c FFF7FEFF 		bl	MX_GPIO_Init
 2017              	.LVL192:
 944:../Src/main.c ****   MX_I2C1_Init();
 2018              		.loc 1 944 0
 2019 0010 FFF7FEFF 		bl	SystemClock_Config
 2020              	.LVL193:
 945:../Src/main.c ****   MX_TIM3_Init();
 2021              		.loc 1 945 0
 2022 0014 FFF7FEFF 		bl	MX_I2C1_Init
 2023              	.LVL194:
 946:../Src/main.c ****   MX_USART2_UART_Init();
 2024              		.loc 1 946 0
 2025 0018 FFF7FEFF 		bl	MX_TIM3_Init
 2026              	.LVL195:
 947:../Src/main.c ****   MX_USART1_UART_Init();
 2027              		.loc 1 947 0
 2028 001c FFF7FEFF 		bl	MX_USART2_UART_Init
 2029              	.LVL196:
 948:../Src/main.c **** 
 2030              		.loc 1 948 0
 2031 0020 FFF7FEFF 		bl	MX_USART1_UART_Init
 2032              	.LVL197:
 951:../Src/main.c ****   uart_printf(WelcomeMsg);
 2033              		.loc 1 951 0
 2034 0024 FFF7FEFF 		bl	XNUCLEO53L0A1_Init
 2035              	.LVL198:
 953:../Src/main.c ****   HAL_Delay(WelcomeTime);
 2036              		.loc 1 953 0
 2037 0028 2848     		ldr	r0, .L150
 2038 002a FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 2039              	.LVL199:
 954:../Src/main.c ****   ResetAndDetectSensor(1);
 2040              		.loc 1 954 0
 2041 002e 4FF42570 		mov	r0, #660
 2042 0032 FFF7FEFF 		bl	HAL_Delay
 2043              	.LVL200:
ARM GAS  /tmp/ccx8Hxdu.s 			page 63


 955:../Src/main.c ****   HAL_TIM_Base_Start_IT(&htim3); //
 2044              		.loc 1 955 0
 2045 0036 0120     		movs	r0, #1
 2046 0038 FFF7FEFF 		bl	ResetAndDetectSensor
 2047              	.LVL201:
 956:../Src/main.c **** 
 2048              		.loc 1 956 0
 2049 003c 2448     		ldr	r0, .L150+4
 2050 003e FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 2051              	.LVL202:
 964:../Src/main.c **** 
 2052              		.loc 1 964 0
 2053 0042 04A8     		add	r0, sp, #16
 2054 0044 FFF7FEFF 		bl	XL320InterfaceDefine
 2055              	.LVL203:
 966:../Src/main.c **** 
 2056              		.loc 1 966 0
 2057 0048 4FF47A70 		mov	r0, #1000
 2058 004c FFF7FEFF 		bl	HAL_Delay
 2059              	.LVL204:
 971:../Src/main.c **** 
 2060              		.loc 1 971 0
 2061 0050 0DF10603 		add	r3, sp, #6
 2062 0054 0022     		movs	r2, #0
 2063 0056 02A9     		add	r1, sp, #8
 2064 0058 04A8     		add	r0, sp, #16
 2065 005a FFF7FEFF 		bl	XL320ServosActivation
 2066              	.LVL205:
 931:../Src/main.c ****   /* USER CODE END 1 */
 2067              		.loc 1 931 0
 2068 005e 0226     		movs	r6, #2
 930:../Src/main.c ****   int UseSensorsMask = 1<<XNUCLEO53L0A1_DEV_CENTER;
 2069              		.loc 1 930 0
 2070 0060 0025     		movs	r5, #0
 929:../Src/main.c ****   DemoMode_e DemoMode = RANGE_VALUE;
 2071              		.loc 1 929 0
 2072 0062 2C46     		mov	r4, r5
 2073 0064 04E0     		b	.L143
 2074              	.LVL206:
 2075              	.L146:
1030:../Src/main.c ****     	  }
 2076              		.loc 1 1030 0
 2077 0066 0226     		movs	r6, #2
 2078              	.LVL207:
 2079 0068 02E0     		b	.L143
 2080              	.LVL208:
 2081              	.L147:
1034:../Src/main.c ****       }
 2082              		.loc 1 1034 0
 2083 006a 0124     		movs	r4, #1
 2084              	.LVL209:
 2085 006c 00E0     		b	.L143
 2086              	.LVL210:
 2087              	.L148:
 2088 006e 0024     		movs	r4, #0
 2089              	.LVL211:
 2090              	.L143:
ARM GAS  /tmp/ccx8Hxdu.s 			page 64


 986:../Src/main.c ****       HAL_Delay(ModeChangeDispTime);
 2091              		.loc 1 986 0
 2092 0070 184B     		ldr	r3, .L150+8
 2093 0072 53F82500 		ldr	r0, [r3, r5, lsl #2]
 2094 0076 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 2095              	.LVL212:
 987:../Src/main.c **** 
 2096              		.loc 1 987 0
 2097 007a 4FF4FA70 		mov	r0, #500
 2098 007e FFF7FEFF 		bl	HAL_Delay
 2099              	.LVL213:
 990:../Src/main.c **** 	  HAL_Delay(ModeChangeDispTime);
 2100              		.loc 1 990 0
 2101 0082 154B     		ldr	r3, .L150+12
 2102 0084 53F82400 		ldr	r0, [r3, r4, lsl #2]
 2103 0088 FFF7FEFF 		bl	XNUCLEO53L0A1_SetDisplayString
 2104              	.LVL214:
 991:../Src/main.c **** 
 2105              		.loc 1 991 0
 2106 008c 4FF4FA70 		mov	r0, #500
 2107 0090 FFF7FEFF 		bl	HAL_Delay
 2108              	.LVL215:
 994:../Src/main.c **** 
 2109              		.loc 1 994 0
 2110 0094 0020     		movs	r0, #0
 2111 0096 FFF7FEFF 		bl	ResetAndDetectSensor
 2112              	.LVL216:
 997:../Src/main.c **** 
 2113              		.loc 1 997 0
 2114 009a FFF7FEFF 		bl	TimeStamp_Reset
 2115              	.LVL217:
1022:../Src/main.c **** 
 2116              		.loc 1 1022 0
 2117 009e 02AB     		add	r3, sp, #8
 2118 00a0 0CCB     		ldmia	r3, {r2, r3}
 2119 00a2 2146     		mov	r1, r4
 2120 00a4 3046     		mov	r0, r6
 2121 00a6 FFF7FEFF 		bl	RangeDemo
 2122              	.LVL218:
1025:../Src/main.c ****     	  /* Long press : change demo mode if multiple sensors present*/
 2123              		.loc 1 1025 0
 2124 00aa 40B1     		cbz	r0, .L144
1027:../Src/main.c ****     		  /* If more than one sensor is present then toggle demo mode */
 2125              		.loc 1 1027 0
 2126 00ac 0B4B     		ldr	r3, .L150+16
 2127 00ae 1B68     		ldr	r3, [r3]
 2128 00b0 012B     		cmp	r3, #1
 2129 00b2 DDDD     		ble	.L143
 2130              	.LVL219:
1030:../Src/main.c ****     	  }
 2131              		.loc 1 1030 0
 2132 00b4 95F00105 		eors	r5, r5, #1
 2133              	.LVL220:
 2134 00b8 D5D0     		beq	.L146
 2135 00ba 0726     		movs	r6, #7
 2136              	.LVL221:
 2137 00bc D8E7     		b	.L143
ARM GAS  /tmp/ccx8Hxdu.s 			page 65


 2138              	.LVL222:
 2139              	.L144:
1034:../Src/main.c ****       }
 2140              		.loc 1 1034 0
 2141 00be 002C     		cmp	r4, #0
 2142 00c0 D3D0     		beq	.L147
1034:../Src/main.c ****       }
 2143              		.loc 1 1034 0 is_stmt 0 discriminator 1
 2144 00c2 012C     		cmp	r4, #1
 2145 00c4 D3D1     		bne	.L148
1034:../Src/main.c ****       }
 2146              		.loc 1 1034 0
 2147 00c6 0224     		movs	r4, #2
 2148              	.LVL223:
 2149 00c8 D2E7     		b	.L143
 2150              	.L151:
 2151 00ca 00BF     		.align	2
 2152              	.L150:
 2153 00cc 30000000 		.word	.LC7
 2154 00d0 00000000 		.word	htim3
 2155 00d4 00000000 		.word	.LANCHOR5
 2156 00d8 00000000 		.word	.LANCHOR6
 2157 00dc 00000000 		.word	.LANCHOR0
 2158              		.cfi_endproc
 2159              	.LFE129:
 2161              		.section	.text.HAL_TIM_PeriodElapsedCallback,"ax",%progbits
 2162              		.align	2
 2163              		.global	HAL_TIM_PeriodElapsedCallback
 2164              		.thumb
 2165              		.thumb_func
 2167              	HAL_TIM_PeriodElapsedCallback:
 2168              	.LFB136:
1227:../Src/main.c **** 
1228:../Src/main.c **** /* USER CODE BEGIN 4 */
1229:../Src/main.c **** 
1230:../Src/main.c **** void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim){ //
 2169              		.loc 1 1230 0 is_stmt 1
 2170              		.cfi_startproc
 2171              		@ args = 0, pretend = 0, frame = 0
 2172              		@ frame_needed = 0, uses_anonymous_args = 0
 2173              	.LVL224:
 2174 0000 08B5     		push	{r3, lr}
 2175              	.LCFI45:
 2176              		.cfi_def_cfa_offset 8
 2177              		.cfi_offset 3, -8
 2178              		.cfi_offset 14, -4
1231:../Src/main.c ****   if(htim->Instance == htim3.Instance){
 2179              		.loc 1 1231 0
 2180 0002 0268     		ldr	r2, [r0]
 2181 0004 044B     		ldr	r3, .L155
 2182 0006 1B68     		ldr	r3, [r3]
 2183 0008 9A42     		cmp	r2, r3
 2184 000a 03D1     		bne	.L152
1232:../Src/main.c ****     HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);              /////changement d'etat de la led
 2185              		.loc 1 1232 0
 2186 000c 2021     		movs	r1, #32
 2187 000e 0348     		ldr	r0, .L155+4
ARM GAS  /tmp/ccx8Hxdu.s 			page 66


 2188              	.LVL225:
 2189 0010 FFF7FEFF 		bl	HAL_GPIO_TogglePin
 2190              	.LVL226:
 2191              	.L152:
 2192 0014 08BD     		pop	{r3, pc}
 2193              	.L156:
 2194 0016 00BF     		.align	2
 2195              	.L155:
 2196 0018 00000000 		.word	htim3
 2197 001c 00000240 		.word	1073872896
 2198              		.cfi_endproc
 2199              	.LFE136:
 2201              		.global	WelcomeMsg
 2202              		.comm	htim5,60,4
 2203              		.global	RangeMedium
 2204              		.global	RangeLow
 2205              		.global	VL53L0XDevs
 2206              		.comm	nDevMask,4,4
 2207              		.global	nDevPresent
 2208              		.global	LeakyFactorFix8
 2209              		.comm	RangingMeasurementData,28,4
 2210              		.global	DemoModeTxt
 2211              		.global	RangingConfigTxt
 2212              		.global	TxtBarGraph
 2213              		.global	TxtRangeValue
 2214              		.comm	huart2,60,4
 2215              		.comm	huart1,60,4
 2216              		.comm	htim3,60,4
 2217              		.comm	hi2c1,56,4
 2218              		.section	.bss.nDevPresent,"aw",%nobits
 2219              		.align	2
 2220              		.set	.LANCHOR0,. + 0
 2223              	nDevPresent:
 2224 0000 00000000 		.space	4
 2225              		.section	.rodata.TxtRangeValue,"a",%progbits
 2226              		.align	2
 2229              	TxtRangeValue:
 2230 0000 726E6700 		.ascii	"rng\000"
 2231              		.section	.data.VL53L0XDevs,"aw",%progbits
 2232              		.align	2
 2233              		.set	.LANCHOR1,. + 0
 2236              	VL53L0XDevs:
 2237 0000 00000000 		.space	348
 2237      00000000 
 2237      00000000 
 2237      00000000 
 2237      00000000 
 2238 015c 00000000 		.word	XNUCLEO53L0A1_hi2c
 2239 0160 52       		.byte	82
 2240 0161 6C       		.byte	108
 2241 0162 0000     		.space	2
 2242 0164 00000000 		.word	0
 2243 0168 00000000 		.space	40
 2243      00000000 
 2243      00000000 
 2243      00000000 
 2243      00000000 
ARM GAS  /tmp/ccx8Hxdu.s 			page 67


 2244 0190 00000000 		.space	348
 2244      00000000 
 2244      00000000 
 2244      00000000 
 2244      00000000 
 2245 02ec 00000000 		.word	XNUCLEO53L0A1_hi2c
 2246 02f0 52       		.byte	82
 2247 02f1 63       		.byte	99
 2248 02f2 0000     		.space	2
 2249 02f4 01000000 		.word	1
 2250 02f8 00000000 		.space	40
 2250      00000000 
 2250      00000000 
 2250      00000000 
 2250      00000000 
 2251 0320 00000000 		.space	348
 2251      00000000 
 2251      00000000 
 2251      00000000 
 2251      00000000 
 2252 047c 00000000 		.word	XNUCLEO53L0A1_hi2c
 2253 0480 52       		.byte	82
 2254 0481 72       		.byte	114
 2255 0482 0000     		.space	2
 2256 0484 02000000 		.word	2
 2257 0488 00000000 		.space	40
 2257      00000000 
 2257      00000000 
 2257      00000000 
 2257      00000000 
 2258              		.section	.data.LeakyFactorFix8,"aw",%progbits
 2259              		.align	2
 2260              		.set	.LANCHOR4,. + 0
 2263              	LeakyFactorFix8:
 2264 0000 99000000 		.word	153
 2265              		.section	.data.WelcomeMsg,"aw",%progbits
 2266              		.align	2
 2269              	WelcomeMsg:
 2270 0000 48692049 		.ascii	"Hi I am Ranging VL53L0X mcu STM32F401xE\012\000"
 2270      20616D20 
 2270      52616E67 
 2270      696E6720 
 2270      564C3533 
 2271              		.section	.rodata.str1.4,"aMS",%progbits,1
 2272              		.align	2
 2273              	.LC0:
 2274 0000 20726220 		.ascii	" rb \000"
 2274      00
 2275 0005 000000   		.space	3
 2276              	.LC1:
 2277 0008 45722564 		.ascii	"Er%d\000"
 2277      00
 2278 000d 000000   		.space	3
 2279              	.LC2:
 2280 0010 20202020 		.ascii	"    \000"
 2280      00
 2281 0015 000000   		.space	3
ARM GAS  /tmp/ccx8Hxdu.s 			page 68


 2282              	.LC3:
 2283 0018 25642C00 		.ascii	"%d,\000"
 2284              	.LC4:
 2285 001c 256400   		.ascii	"%d\000"
 2286 001f 00       		.space	1
 2287              	.LC5:
 2288 0020 25336463 		.ascii	"%3dc\000"
 2288      00
 2289 0025 000000   		.space	3
 2290              	.LC6:
 2291 0028 2D2D2D2D 		.ascii	"----\000"
 2291      00
 2292 002d 000000   		.space	3
 2293              	.LC7:
 2294 0030 35334C30 		.ascii	"53L0\000"
 2294      00
 2295 0035 000000   		.space	3
 2296              	.LC8:
 2297 0038 726E6700 		.ascii	"rng\000"
 2298              	.LC9:
 2299 003c 62617200 		.ascii	"bar\000"
 2300              	.LC10:
 2301 0040 4C5200   		.ascii	"LR\000"
 2302 0043 00       		.space	1
 2303              	.LC11:
 2304 0044 485300   		.ascii	"HS\000"
 2305 0047 00       		.space	1
 2306              	.LC12:
 2307 0048 484100   		.ascii	"HA\000"
 2308              		.section	.data.RangingConfigTxt,"aw",%progbits
 2309              		.align	2
 2310              		.set	.LANCHOR6,. + 0
 2313              	RangingConfigTxt:
 2314 0000 40000000 		.word	.LC10
 2315 0004 44000000 		.word	.LC11
 2316 0008 48000000 		.word	.LC12
 2317              		.section	.rodata.TxtBarGraph,"a",%progbits
 2318              		.align	2
 2321              	TxtBarGraph:
 2322 0000 62617200 		.ascii	"bar\000"
 2323              		.section	.data.RangeLow,"aw",%progbits
 2324              		.align	2
 2325              		.set	.LANCHOR2,. + 0
 2328              	RangeLow:
 2329 0000 64000000 		.word	100
 2330              		.section	.data.RangeMedium,"aw",%progbits
 2331              		.align	2
 2332              		.set	.LANCHOR3,. + 0
 2335              	RangeMedium:
 2336 0000 2C010000 		.word	300
 2337              		.section	.data.DemoModeTxt,"aw",%progbits
 2338              		.align	2
 2339              		.set	.LANCHOR5,. + 0
 2342              	DemoModeTxt:
 2343 0000 38000000 		.word	.LC8
 2344 0004 3C000000 		.word	.LC9
 2345              		.text
ARM GAS  /tmp/ccx8Hxdu.s 			page 69


 2346              	.Letext0:
 2347              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 2348              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 2349              		.file 4 "../Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f401xe.h"
 2350              		.file 5 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 2351              		.file 6 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_rcc.h"
 2352              		.file 7 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_gpio.h"
 2353              		.file 8 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 2354              		.file 9 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_i2c.h"
 2355              		.file 10 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_tim.h"
 2356              		.file 11 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_tim_ex.h"
 2357              		.file 12 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_uart.h"
 2358              		.file 13 "../Drivers/BSP/Components/vl53l0x/vl53l0x_types.h"
 2359              		.file 14 "../Drivers/BSP/Components/vl53l0x/vl53l0x_device.h"
 2360              		.file 15 "../Drivers/BSP/Components/vl53l0x/vl53l0x_def.h"
 2361              		.file 16 "../Drivers/BSP/X-NUCLEO-53L0A1/vl53l0x_platform.h"
 2362              		.file 17 "../Inc/xl_320.h"
 2363              		.file 18 "../Drivers/BSP/X-NUCLEO-53L0A1/X-NUCLEO-53L0A1.h"
 2364              		.file 19 "../Drivers/CMSIS/Include/core_cm4.h"
 2365              		.file 20 "../Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal.h"
 2366              		.file 21 "/usr/include/newlib/stdio.h"
 2367              		.file 22 "../Drivers/BSP/Components/vl53l0x/vl53l0x_api.h"
 2368              		.file 23 "/usr/include/newlib/string.h"
 2369              		.file 24 "../Inc/servo.h"
ARM GAS  /tmp/ccx8Hxdu.s 			page 70


DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccx8Hxdu.s:22     .text.MX_GPIO_Init:00000000 $t
     /tmp/ccx8Hxdu.s:26     .text.MX_GPIO_Init:00000000 MX_GPIO_Init
     /tmp/ccx8Hxdu.s:174    .text.MX_GPIO_Init:000000d0 $d
     /tmp/ccx8Hxdu.s:183    .text.SystemClock_Config:00000000 $t
     /tmp/ccx8Hxdu.s:187    .text.SystemClock_Config:00000000 SystemClock_Config
     /tmp/ccx8Hxdu.s:269    .text.SystemClock_Config:00000064 $d
     /tmp/ccx8Hxdu.s:274    .text.MX_I2C1_Init:00000000 $t
     /tmp/ccx8Hxdu.s:278    .text.MX_I2C1_Init:00000000 MX_I2C1_Init
     /tmp/ccx8Hxdu.s:319    .text.MX_I2C1_Init:00000028 $d
                            *COM*:00000038 hi2c1
     /tmp/ccx8Hxdu.s:326    .text.MX_TIM3_Init:00000000 $t
     /tmp/ccx8Hxdu.s:330    .text.MX_TIM3_Init:00000000 MX_TIM3_Init
     /tmp/ccx8Hxdu.s:390    .text.MX_TIM3_Init:00000044 $d
                            *COM*:0000003c htim3
     /tmp/ccx8Hxdu.s:396    .text.MX_USART2_UART_Init:00000000 $t
     /tmp/ccx8Hxdu.s:400    .text.MX_USART2_UART_Init:00000000 MX_USART2_UART_Init
     /tmp/ccx8Hxdu.s:439    .text.MX_USART2_UART_Init:00000024 $d
                            *COM*:0000003c huart2
     /tmp/ccx8Hxdu.s:445    .text.MX_USART1_UART_Init:00000000 $t
     /tmp/ccx8Hxdu.s:449    .text.MX_USART1_UART_Init:00000000 MX_USART1_UART_Init
     /tmp/ccx8Hxdu.s:488    .text.MX_USART1_UART_Init:00000024 $d
                            *COM*:0000003c huart1
     /tmp/ccx8Hxdu.s:495    .text.MX_TIM5_Init:00000000 $t
     /tmp/ccx8Hxdu.s:500    .text.MX_TIM5_Init:00000000 MX_TIM5_Init
     /tmp/ccx8Hxdu.s:566    .text.MX_TIM5_Init:00000044 $d
                            *COM*:0000003c htim5
     /tmp/ccx8Hxdu.s:572    .text.TimeStamp_Init:00000000 $t
     /tmp/ccx8Hxdu.s:577    .text.TimeStamp_Init:00000000 TimeStamp_Init
     /tmp/ccx8Hxdu.s:596    .text.TimeStamp_Reset:00000000 $t
     /tmp/ccx8Hxdu.s:601    .text.TimeStamp_Reset:00000000 TimeStamp_Reset
     /tmp/ccx8Hxdu.s:625    .text.TimeStamp_Reset:00000014 $d
     /tmp/ccx8Hxdu.s:630    .text.TimeStamp_Get:00000000 $t
     /tmp/ccx8Hxdu.s:635    .text.TimeStamp_Get:00000000 TimeStamp_Get
     /tmp/ccx8Hxdu.s:651    .text.TimeStamp_Get:00000008 $d
     /tmp/ccx8Hxdu.s:656    .text.BSP_GetPushButton:00000000 $t
     /tmp/ccx8Hxdu.s:661    .text.BSP_GetPushButton:00000000 BSP_GetPushButton
     /tmp/ccx8Hxdu.s:682    .text.BSP_GetPushButton:00000010 $d
     /tmp/ccx8Hxdu.s:687    .text.PusbButton_WaitUnPress:00000000 $t
     /tmp/ccx8Hxdu.s:692    .text.PusbButton_WaitUnPress:00000000 PusbButton_WaitUnPress
     /tmp/ccx8Hxdu.s:742    .text.PusbButton_WaitUnPress:00000038 $d
     /tmp/ccx8Hxdu.s:747    .text.HandleError:00000000 $t
     /tmp/ccx8Hxdu.s:752    .text.HandleError:00000000 HandleError
     /tmp/ccx8Hxdu.s:782    .text.HandleError:00000018 $d
     /tmp/ccx8Hxdu.s:787    .text.DetectSensors:00000000 $t
     /tmp/ccx8Hxdu.s:792    .text.DetectSensors:00000000 DetectSensors
     /tmp/ccx8Hxdu.s:1031   .text.DetectSensors:00000148 $d
                            *COM*:00000004 nDevMask
     /tmp/ccx8Hxdu.s:1039   .text.SetupSingleShot:00000000 $t
     /tmp/ccx8Hxdu.s:1044   .text.SetupSingleShot:00000000 SetupSingleShot
     /tmp/ccx8Hxdu.s:1235   .text.SetupSingleShot:0000011c $d
     /tmp/ccx8Hxdu.s:1241   .text.RangeToLetter:00000000 $t
     /tmp/ccx8Hxdu.s:1246   .text.RangeToLetter:00000000 RangeToLetter
     /tmp/ccx8Hxdu.s:1294   .text.RangeToLetter:00000028 $d
     /tmp/ccx8Hxdu.s:1300   .text.Sensor_SetNewRange:00000000 $t
     /tmp/ccx8Hxdu.s:1305   .text.Sensor_SetNewRange:00000000 Sensor_SetNewRange
ARM GAS  /tmp/ccx8Hxdu.s 			page 71


     /tmp/ccx8Hxdu.s:1367   .text.Sensor_SetNewRange:00000048 $d
     /tmp/ccx8Hxdu.s:1372   .text.blink_led:00000000 $t
     /tmp/ccx8Hxdu.s:1377   .text.blink_led:00000000 blink_led
     /tmp/ccx8Hxdu.s:1432   .text.blink_led:00000030 $d
     /tmp/ccx8Hxdu.s:1437   .text.Variation2Angle_maison:00000000 $t
     /tmp/ccx8Hxdu.s:1442   .text.Variation2Angle_maison:00000000 Variation2Angle_maison
     /tmp/ccx8Hxdu.s:1498   .text.Variation3Angle_maison:00000000 $t
     /tmp/ccx8Hxdu.s:1503   .text.Variation3Angle_maison:00000000 Variation3Angle_maison
     /tmp/ccx8Hxdu.s:1647   .text.Variation3Angle_maison:000000c8 $d
     /tmp/ccx8Hxdu.s:1654   .text.RangeDemo:00000000 $t
     /tmp/ccx8Hxdu.s:1659   .text.RangeDemo:00000000 RangeDemo
     /tmp/ccx8Hxdu.s:1930   .text.RangeDemo:00000188 $d
                            *COM*:0000001c RangingMeasurementData
     /tmp/ccx8Hxdu.s:1941   .text.ResetAndDetectSensor:00000000 $t
     /tmp/ccx8Hxdu.s:1946   .text.ResetAndDetectSensor:00000000 ResetAndDetectSensor
     /tmp/ccx8Hxdu.s:1982   .text.ResetAndDetectSensor:00000020 $d
     /tmp/ccx8Hxdu.s:1987   .text.main:00000000 $t
     /tmp/ccx8Hxdu.s:1992   .text.main:00000000 main
     /tmp/ccx8Hxdu.s:2153   .text.main:000000cc $d
     /tmp/ccx8Hxdu.s:2162   .text.HAL_TIM_PeriodElapsedCallback:00000000 $t
     /tmp/ccx8Hxdu.s:2167   .text.HAL_TIM_PeriodElapsedCallback:00000000 HAL_TIM_PeriodElapsedCallback
     /tmp/ccx8Hxdu.s:2196   .text.HAL_TIM_PeriodElapsedCallback:00000018 $d
     /tmp/ccx8Hxdu.s:2269   .data.WelcomeMsg:00000000 WelcomeMsg
     /tmp/ccx8Hxdu.s:2335   .data.RangeMedium:00000000 RangeMedium
     /tmp/ccx8Hxdu.s:2328   .data.RangeLow:00000000 RangeLow
     /tmp/ccx8Hxdu.s:2236   .data.VL53L0XDevs:00000000 VL53L0XDevs
     /tmp/ccx8Hxdu.s:2223   .bss.nDevPresent:00000000 nDevPresent
     /tmp/ccx8Hxdu.s:2263   .data.LeakyFactorFix8:00000000 LeakyFactorFix8
     /tmp/ccx8Hxdu.s:2342   .data.DemoModeTxt:00000000 DemoModeTxt
     /tmp/ccx8Hxdu.s:2313   .data.RangingConfigTxt:00000000 RangingConfigTxt
     /tmp/ccx8Hxdu.s:2321   .rodata.TxtBarGraph:00000000 TxtBarGraph
     /tmp/ccx8Hxdu.s:2229   .rodata.TxtRangeValue:00000000 TxtRangeValue
     /tmp/ccx8Hxdu.s:2219   .bss.nDevPresent:00000000 $d
     /tmp/ccx8Hxdu.s:2226   .rodata.TxtRangeValue:00000000 $d
     /tmp/ccx8Hxdu.s:2232   .data.VL53L0XDevs:00000000 $d
     /tmp/ccx8Hxdu.s:2259   .data.LeakyFactorFix8:00000000 $d
     /tmp/ccx8Hxdu.s:2266   .data.WelcomeMsg:00000000 $d
     /tmp/ccx8Hxdu.s:2272   .rodata.str1.4:00000000 $d
     /tmp/ccx8Hxdu.s:2309   .data.RangingConfigTxt:00000000 $d
     /tmp/ccx8Hxdu.s:2318   .rodata.TxtBarGraph:00000000 $d
     /tmp/ccx8Hxdu.s:2324   .data.RangeLow:00000000 $d
     /tmp/ccx8Hxdu.s:2331   .data.RangeMedium:00000000 $d
     /tmp/ccx8Hxdu.s:2338   .data.DemoModeTxt:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
HAL_GPIO_Init
HAL_GPIO_WritePin
HAL_RCC_OscConfig
HAL_RCC_ClockConfig
HAL_I2C_Init
HAL_TIM_Base_Init
HAL_TIM_ConfigClockSource
HAL_TIMEx_MasterConfigSynchronization
HAL_UART_Init
HAL_TIM_OC_Init
HAL_TIM_OC_ConfigChannel
ARM GAS  /tmp/ccx8Hxdu.s 			page 72


HAL_TIM_Base_Start
HAL_GPIO_ReadPin
HAL_GetTick
XNUCLEO53L0A1_SetDisplayString
sprintf
XNUCLEO53L0A1_ResetId
HAL_Delay
VL53L0X_WrByte
VL53L0X_RdWord
VL53L0X_SetDeviceAddress
VL53L0X_DataInit
VL53L0X_StaticInit
VL53L0X_PerformRefCalibration
VL53L0X_PerformRefSpadManagement
VL53L0X_SetDeviceMode
VL53L0X_SetLimitCheckEnable
VL53L0X_SetLimitCheckValue
VL53L0X_SetMeasurementTimingBudgetMicroSeconds
VL53L0X_SetVcselPulsePeriod
HAL_TIM_Base_Stop_IT
HAL_TIM_Base_Start_IT
XL_Set_Goal_Position
XL_Get_Current_Position
strcat
strlen
HAL_UART_Transmit
VL53L0X_PerformSingleRangingMeasurement
HAL_Init
XNUCLEO53L0A1_Init
XL320InterfaceDefine
XL320ServosActivation
HAL_GPIO_TogglePin
XNUCLEO53L0A1_hi2c
